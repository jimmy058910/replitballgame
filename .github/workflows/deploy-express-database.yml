name: Deploy Express + Database (Step 2) - DISABLED

on:
  # DISABLED: This workflow contains Neon references and conflicts with simple database
  # workflow_dispatch:
  #   inputs:
  #     deployment_type:
  #       description: 'Deployment type'
  #       required: true
  #       default: 'staging'
  #       type: choice
  #       options:
  #         - staging
  #         - production

env:
  PROJECT_ID: direct-glider-465821-p7
  PROJECT_NUMBER: 465821
  REGION: us-central1
  SERVICE_NAME: realm-rivalry-express-database
  REPOSITORY: realm-rivalry
  IMAGE_NAME: us-central1-docker.pkg.dev/direct-glider-465821-p7/realm-rivalry/express-database
  MIN_INSTANCES: 1
  MAX_INSTANCES: 3
  MEMORY: 1Gi
  CPU: 1
  TIMEOUT: 60
  CONCURRENCY: 100

jobs:
  pre-deployment-validation:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.set-tag.outputs.tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set image tag
      id: set-tag
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
        echo "tag=$SHORT_SHA" >> $GITHUB_OUTPUT
        echo "Image tag: $SHORT_SHA"
        
    - name: Validate deployment files
      run: |
        echo "Validating Step 2 deployment files..."
        test -f server-express-database-nuclear.js || (echo "‚ùå server-express-database-nuclear.js missing" && exit 1)
        test -f Dockerfile.express-database || (echo "‚ùå Dockerfile.express-database missing" && exit 1)
        test -f package.json || (echo "‚ùå package.json missing" && exit 1)
        test -f prisma/schema.prisma || (echo "‚ùå prisma/schema.prisma missing" && exit 1)
        echo "‚úÖ All required files present including Prisma schema"

  build-and-push:
    needs: pre-deployment-validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        version: latest
        
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker us-central1-docker.pkg.dev
        
    - name: Verify build context
      run: |
        echo "Build context verification:"
        ls -la server-express-database.js Dockerfile.express-database package.json
        ls -la prisma/schema.prisma
        echo "Express + Database server file size: $(wc -c < server-express-database.js) bytes"
        echo "Prisma schema size: $(wc -c < prisma/schema.prisma) bytes"
        
    - name: Build production image with security scanning
      run: |
        echo "Building Express + Database with ISOLATED build context (NEON FIX)..."
        
        # Create isolated build directory to eliminate ALL external dependencies
        mkdir -p isolated-build
        cp server-express-database-nuclear.js isolated-build/server.js
        cp package.json package-lock.json isolated-build/
        cp -r prisma isolated-build/
        
        # Create isolated Dockerfile with CLEAN Prisma generation
        cat > isolated-build/Dockerfile << 'EOF'
        FROM node:20.19.4-alpine AS production
        RUN apk add --no-cache curl
        WORKDIR /app
        COPY package.json package-lock.json ./
        RUN npm ci --only=production && npm cache clean --force
        COPY server.js ./
        COPY prisma ./prisma/
        RUN npx prisma generate
        RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001 -G nodejs
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        EXPOSE 8080
        ENV NODE_ENV=production HOST=0.0.0.0 PORT=8080
        HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
          CMD curl -f http://localhost:8080/health || exit 1
        CMD ["node", "server.js"]
        EOF
        
        # Build from completely isolated context
        docker build \
          -f isolated-build/Dockerfile \
          --tag ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} \
          --tag ${{ env.IMAGE_NAME }}:latest \
          isolated-build/
          
        echo "‚úÖ Build completed from ISOLATED context (external dependencies eliminated)"
        
    - name: Security scan
      run: |
        echo "Running container security validation..."
        
        # Inspect the built image
        docker inspect ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }}
        
        # Verify non-root user
        USER_CHECK=$(docker run --rm ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} whoami)
        if [ "$USER_CHECK" != "nodejs" ]; then
          echo "‚ùå Security check failed: Container not running as nodejs user"
          exit 1
        fi
        echo "‚úÖ Security check passed: Running as non-root user"
        
    - name: Test container functionality
      run: |
        echo "Testing container startup and endpoints..."
        
        # Start container in background with database URL
        CONTAINER_ID=$(docker run -d -p 8080:8080 \
          -e DATABASE_URL="postgresql://test:test@localhost:5432/testdb" \
          -e NODE_ENV=production \
          ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }})
        
        # Wait for startup
        sleep 5
        
        # Test health endpoint
        if curl -f http://localhost:8080/health; then
          echo "‚úÖ Health check endpoint working"
        else
          echo "‚ùå Health check failed"
          docker logs $CONTAINER_ID
          exit 1
        fi
        
        # Test main endpoint
        if curl -f http://localhost:8080/ | grep -q "EXPRESS + DATABASE SUCCESS"; then
          echo "‚úÖ Main endpoint working"
        else
          echo "‚ùå Main endpoint failed"
          docker logs $CONTAINER_ID
          exit 1
        fi
        
        # Cleanup
        docker stop $CONTAINER_ID
        echo "‚úÖ Container functionality verified"
        
    - name: Push to Artifact Registry
      run: |
        echo "Pushing Express + Database image to registry..."
        docker push ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }}
        docker push ${{ env.IMAGE_NAME }}:latest
        echo "‚úÖ Images pushed successfully"

  deploy-to-cloud-run:
    needs: [pre-deployment-validation, build-and-push]
    runs-on: ubuntu-latest
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        version: latest
        
    - name: Deploy to Cloud Run with Blue-Green strategy
      run: |
        echo "Deploying Express + Database service with industry-standard configuration..."
        
        REVISION_SUFFIX="${{ needs.pre-deployment-validation.outputs.image-tag }}"
        
        # Check if service exists
        if gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --quiet 2>/dev/null; then
          echo "üì¶ Updating existing service with Blue-Green deployment"
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --memory=${{ env.MEMORY }} \
            --cpu=${{ env.CPU }} \
            --timeout=${{ env.TIMEOUT }} \
            --concurrency=${{ env.CONCURRENCY }} \
            --min-instances=${{ env.MIN_INSTANCES }} \
            --max-instances=${{ env.MAX_INSTANCES }} \
            --port=8080 \
            --execution-environment=gen2 \
            --cpu-boost \
            --revision-suffix="${REVISION_SUFFIX}" \
            --tag="latest" \
            --no-traffic \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="NODE_ENV=production"
        else
          echo "üÜï Creating new service"
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --memory=${{ env.MEMORY }} \
            --cpu=${{ env.CPU }} \
            --timeout=${{ env.TIMEOUT }} \
            --concurrency=${{ env.CONCURRENCY }} \
            --min-instances=${{ env.MIN_INSTANCES }} \
            --max-instances=${{ env.MAX_INSTANCES }} \
            --port=8080 \
            --execution-environment=gen2 \
            --cpu-boost \
            --revision-suffix="${REVISION_SUFFIX}" \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="NODE_ENV=production"
        fi
          
        echo "‚úÖ Service deployment completed"
        
    - name: Health check verification
      run: |
        echo "Verifying service health..."
        
        # Get the service URL for the new revision
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
          --region=${{ env.REGION }} \
          --format='value(status.url)')
          
        REVISION_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
          --region=${{ env.REGION }} \
          --format='value(status.traffic[0].url)')
          
        echo "Service URL: $SERVICE_URL"
        echo "Revision URL: $REVISION_URL"
        
        # Test health endpoints  
        if curl -f "${SERVICE_URL}/health"; then
          echo "‚úÖ Health check endpoint working"
        else
          echo "‚ùå Health check failed"
          exit 1
        fi
        
        if curl -f "${SERVICE_URL}/" | grep -q "EXPRESS + DATABASE SUCCESS"; then
          echo "‚úÖ Full health endpoint working"
        else
          echo "‚ùå Full health endpoint failed"
          exit 1
        fi
        
        # Test database connectivity (allow some initialization time)
        echo "üîç Testing database connectivity..."
        RETRY_COUNT=0
        MAX_RETRIES=3
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f "${SERVICE_URL}/db-test"; then
            echo "‚úÖ Database connectivity test passed"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚ö†Ô∏è Database test attempt $RETRY_COUNT failed, retrying in 10 seconds..."
            sleep 10
          fi
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "‚ùå Database connectivity test failed after $MAX_RETRIES attempts"
          echo "üìä Current service status:"
          curl -s "${SERVICE_URL}/health" | jq '.'
          exit 1
        fi
        
    - name: Switch traffic to new revision
      run: |
        echo "Switching 100% traffic to new revision..."
        
        gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
          --region=${{ env.REGION }} \
          --to-latest
          
        echo "‚úÖ Traffic switched to new revision"
        
    - name: Final verification
      run: |
        echo "Final deployment verification..."
        
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
          --region=${{ env.REGION }} \
          --format='value(status.url)')
          
        echo "üåê Service deployed at: $SERVICE_URL"
        echo "üîç Testing all endpoints..."
        
        # Test all endpoints
        curl -f "$SERVICE_URL/" 
        curl -f "$SERVICE_URL/health"
        curl -f "$SERVICE_URL/db-test"
        
        echo "‚úÖ Step 2 (Express + Database) deployment completed successfully!"
        echo "üéØ Next: Step 3 - Express + Database + Authentication"