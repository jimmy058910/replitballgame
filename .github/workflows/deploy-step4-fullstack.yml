name: Deploy Step 4 - Complete Fullstack Application

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  PROJECT_ID: direct-glider-465821-p7
  PROJECT_NUMBER: 465821
  REGION: us-central1
  SERVICE_NAME: realm-rivalry-fullstack
  REPOSITORY: realm-rivalry
  IMAGE_NAME: us-central1-docker.pkg.dev/direct-glider-465821-p7/realm-rivalry/fullstack
  MIN_INSTANCES: 1
  MAX_INSTANCES: 3
  MEMORY: 1Gi
  CPU: 1
  TIMEOUT: 60
  CONCURRENCY: 100

jobs:
  pre-deployment-validation:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      image-tag: ${{ steps.tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for changes or force deploy
        id: changes
        run: |
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Force deploy requested"
          else
            # Check for changes in relevant files
            if git diff --name-only HEAD~1 HEAD | grep -E '\.(ts|tsx|js|jsx|json|yml|yaml|md)$|Dockerfile|server/|client/|shared/'; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Relevant changes detected, will deploy"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "No relevant changes detected, skipping deployment"
            fi
          fi

      - name: Generate image tag
        id: tag
        run: |
          TAG=$(echo "${{ github.sha }}" | cut -c1-8)
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

  deploy-to-cloud-run:
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker to use gcloud as a credential helper
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev

      - name: Verify Step 4 architecture and build context
        run: |
          echo "üìã STEP 4 FULLSTACK ARCHITECTURE VERIFICATION"
          echo "============================================="
          
          echo "üìÅ Root directory contents:"
          ls -la
          
          echo ""
          echo "üìÑ Checking established server architecture:"
          if [ -f "server/index.ts" ]; then
            echo "‚úÖ server/index.ts exists (main server with frontend serving)"
            echo "Size: $(wc -c < server/index.ts) bytes"
          else
            echo "‚ùå server/index.ts not found"
            exit 1
          fi
          
          echo ""
          echo "üìÑ Checking React frontend:"
          if [ -d "client/src" ]; then
            echo "‚úÖ client/src exists (React application)"
            echo "TypeScript files: $(find client/src -name "*.tsx" -o -name "*.ts" | wc -l)"
          else
            echo "‚ùå client/src not found"
            exit 1
          fi
          
          echo ""
          echo "üìÑ Checking production Dockerfile:"
          if [ -f "Dockerfile.production" ]; then
            echo "‚úÖ Dockerfile.production exists"
            echo "Verifying it builds both frontend and server..."
            grep -E "(npm run build|npm run build:server)" Dockerfile.production && echo "‚úÖ Builds both components"
          else
            echo "‚ùå Dockerfile.production not found"
            exit 1
          fi
          
          echo ""
          echo "üì¶ Checking package.json build scripts:"
          if [ -f "package.json" ]; then
            echo "‚úÖ package.json exists"
            echo "Build scripts:"
            grep -E '"(build|build:server|build:all)"' package.json || echo "‚ö†Ô∏è Build scripts not found"
          else
            echo "‚ùå package.json not found"
            exit 1
          fi
          
          echo ""
          echo "üö´ Verifying obsolete files are removed:"
          if [ -f "server-frontend-auth.js" ]; then
            echo "‚ùå Obsolete server-frontend-auth.js still exists - must be removed"
            exit 1
          else
            echo "‚úÖ No obsolete server files found"
          fi
          
          echo ""
          echo "‚úÖ Step 4 architecture verification complete - using established tech stack"

      - name: Build and push Docker image
        run: |
          echo "üî® Building Step 4: Complete fullstack application with established architecture..."
          
          # Use the proven Dockerfile.production with established architecture
          # This builds React frontend to dist/public/ and compiles TypeScript server
          docker build -f Dockerfile.production \
            -t ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} .
          
          docker push ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }}

      - name: Deploy to Cloud Run with comprehensive configuration
        run: |
          echo "üöÄ Deploying Step 4: Complete fullstack application to Cloud Run..."

          # Base64 encode the service account JSON to avoid all shell/gcloud parsing issues
          # This is the industry standard approach for complex configuration data
          ENCODED_SERVICE_ACCOUNT=$(echo '${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}' | base64 -w 0)

          # Deploy with comprehensive Cloud Run configuration
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --port=8080 \
            --memory=${{ env.MEMORY }} \
            --cpu=${{ env.CPU }} \
            --timeout=${{ env.TIMEOUT }} \
            --concurrency=${{ env.CONCURRENCY }} \
            --min-instances=${{ env.MIN_INSTANCES }} \
            --max-instances=${{ env.MAX_INSTANCES }} \
            --set-env-vars="NODE_ENV=production,GOOGLE_CLOUD_PROJECT=${{ env.PROJECT_ID }}" \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="GOOGLE_SERVICE_ACCOUNT_KEY_BASE64=${ENCODED_SERVICE_ACCOUNT}" \
            --set-env-vars="SESSION_SECRET=${{ secrets.SESSION_SECRET }}" \
            --set-env-vars="GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" \
            --set-env-vars="GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            --execution-environment=gen2 \


      - name: Verify deployment success
        run: |
          echo "üîç Verifying Step 4 deployment success..."
          
          # Wait for deployment to fully propagate and get the service URL with retries
          echo "Waiting for deployment propagation..."
          sleep 10
          
          for i in {1..3}; do
            SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format='value(status.url)')
            if [ -n "$SERVICE_URL" ]; then
              break
            fi
            echo "Retry $i: Waiting for service URL..."
            sleep 5
          done
          
          echo "Service deployed at: $SERVICE_URL"
          
          # Test health endpoint with retries
          echo "Testing health endpoint..."
          for i in {1..5}; do
            if curl -f --max-time 30 "${SERVICE_URL}/health" 2>/dev/null; then
              echo "‚úÖ Health check successful (attempt $i)"
              break
            else
              echo "Retry $i: Health check..."
              sleep 10
            fi
            if [ $i -eq 5 ]; then
              echo "‚ùå Health check failed after 5 attempts"
              exit 1
            fi
          done
          
          # Test frontend serving (should serve React app) with retries
          echo "Testing frontend serving..."
          for i in {1..3}; do
            if curl -f --max-time 30 "${SERVICE_URL}/" 2>/dev/null | grep -q "<!DOCTYPE html>"; then
              echo "‚úÖ Frontend serving successful - React app accessible (attempt $i)"
              break
            else
              echo "Retry $i: Frontend serving test..."
              sleep 5
            fi
            if [ $i -eq 3 ]; then
              echo "‚ùå Frontend serving failed after 3 attempts"
              exit 1
            fi
          done
          
          echo ""
          echo "üéâ STEP 4 DEPLOYMENT SUCCESS!"
          echo "‚úÖ Complete fullstack application deployed"
          echo "‚úÖ React frontend served by Express server"
          echo "‚úÖ Firebase Authentication integrated"
          echo "‚úÖ Cloud SQL PostgreSQL connected"
          echo "‚úÖ Service URL: $SERVICE_URL"