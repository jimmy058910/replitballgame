name: Deploy Simple Database Server

on:
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'
        type: boolean
  push:
    branches: [ main ]
    paths:
      - 'server-database-dual.js'
      - '.github/workflows/deploy-simple-database.yml'

jobs:
  pre-deployment-validation:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.generate-tag.outputs.tag }}
    steps:
      - name: Generate deployment tag
        id: generate-tag
        run: |
          TAG=$(echo "${GITHUB_SHA::8}")
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Generated tag: ${TAG}"

  deploy-to-cloud-run:
    needs: pre-deployment-validation
    runs-on: ubuntu-latest
    environment: production
    env:
      PROJECT_ID: direct-glider-465821-p7
      PROJECT_NUMBER: 465821
      REGION: us-central1
      SERVICE_NAME: realm-rivalry-simple-database
      REPOSITORY: realm-rivalry
      IMAGE_NAME: us-central1-docker.pkg.dev/direct-glider-465821-p7/realm-rivalry/simple-database
      MIN_INSTANCES: 1
      MAX_INSTANCES: 3
      MEMORY: 1Gi
      CPU: 1
      TIMEOUT: 60
      CONCURRENCY: 100

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker us-central1-docker.pkg.dev

      - name: Build and push Docker image
        run: |
          echo "Building simple database server image..."
          
          # Create build context with only required files
          mkdir -p build-context
          cd build-context
          
          # Create package.json with minimal dependencies
          cat > package.json << 'EOF'
          {
            "name": "simple-database-server",
            "version": "1.0.0",
            "type": "module",
            "dependencies": {
              "express": "^4.19.2",
              "pg": "^8.11.3"
            },
            "engines": {
              "node": ">=20.0.0"
            }
          }
          EOF
          
          # Create dual-mode server
          cat > server-database-simple.js << 'EOF'
          // DUAL-MODE DATABASE SERVER: Works with both unix socket and public IP
          import express from 'express';
          import pkg from 'pg';
          const { Pool } = pkg;
          
          const PORT = process.env.PORT || 8080;
          const HOST = '0.0.0.0';
          
          console.log('🚀 DUAL-MODE SERVER: Starting with universal database connectivity...');
          console.log(`Environment: NODE_ENV=${process.env.NODE_ENV || 'production'}`);
          console.log(`Target: ${HOST}:${PORT}`);
          
          const app = express();
          app.use(express.json({ limit: '1mb' }));
          
          let dbPool = null;
          let dbStatus = 'not-connected';
          let connectionMethod = 'unknown';
          
          async function createDualModeConnection() {
            const dbUrl = process.env.DATABASE_URL;
            
            if (!dbUrl) {
              throw new Error('DATABASE_URL not found');
            }
          
            console.log(`🔍 Database URL type: ${dbUrl.substring(0, 30)}...`);
            
            const isUnixSocket = dbUrl.includes('/cloudsql/');
            const isCloudRun = !!(process.env.K_SERVICE || process.env.GOOGLE_CLOUD_PROJECT);
            
            console.log(`🔍 Connection analysis: isUnixSocket=${isUnixSocket}, isCloudRun=${isCloudRun}`);
            
            let connectionConfig = {
              connectionString: dbUrl,
              max: 20,
              idleTimeoutMillis: 30000,
              connectionTimeoutMillis: 15000,
            };
          
            if (isUnixSocket) {
              console.log('🔌 Using unix socket connection (Cloud Run native)');
              connectionMethod = 'unix-socket';
              connectionConfig.ssl = false;
            } else {
              console.log('🌐 Using public IP connection (universal)');
              connectionMethod = 'public-ip';
              connectionConfig.ssl = { rejectUnauthorized: false };
            }
          
            return new Pool(connectionConfig);
          }
          
          async function initDatabase() {
            try {
              console.log('🔍 DUAL-MODE: Initializing universal database connection...');
              
              dbPool = await createDualModeConnection();
              
              let retries = 3;
              let lastError = null;
              
              for (let i = 0; i < retries; i++) {
                try {
                  console.log(`🔍 Connection attempt ${i + 1}/${retries}...`);
                  
                  const client = await dbPool.connect();
                  const result = await client.query('SELECT NOW() as current_time');
                  
                  console.log(`✅ Database connected successfully via ${connectionMethod}!`);
                  console.log(`🕒 Time: ${result.rows[0].current_time}`);
                  
                  client.release();
                  dbStatus = 'connected';
                  return true;
                } catch (error) {
                  lastError = error;
                  console.log(`❌ Attempt ${i + 1} failed: ${error.message}`);
                  
                  if (i < retries - 1) {
                    const waitTime = (i + 1) * 2000;
                    console.log(`⏳ Waiting ${waitTime}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                  }
                }
              }
              
              throw lastError;
            } catch (error) {
              console.error('❌ All database connection attempts failed:', error.message);
              dbStatus = `error: ${error.message}`;
              return false;
            }
          }
          
          app.get('/health', async (req, res) => {
            let databaseHealth = dbStatus;
            
            if (dbPool && dbStatus === 'connected') {
              try {
                const client = await dbPool.connect();
                await client.query('SELECT 1');
                databaseHealth = 'healthy';
                client.release();
              } catch (error) {
                databaseHealth = `error: ${error.message}`;
              }
            }
          
            res.status(200).json({
              status: 'healthy',
              timestamp: new Date().toISOString(),
              message: 'Simple database server operational',
              database: {
                status: databaseHealth,
                connection_type: 'direct-postgresql'
              }
            });
          });
          
          app.get('/', (req, res) => {
            res.status(200).send(`
              <h1>SIMPLE DATABASE SUCCESS</h1>
              <p>Server: ${new Date().toISOString()}</p>
              <p>Database: ${dbStatus}</p>
            `);
          });
          
          app.get('/db-test', async (req, res) => {
            if (!dbPool) {
              return res.status(500).json({ error: 'Database not initialized' });
            }
          
            try {
              const client = await dbPool.connect();
              const result = await client.query('SELECT NOW() as time, current_database() as db');
              client.release();
              
              res.status(200).json({
                status: 'success',
                data: result.rows[0],
                timestamp: new Date().toISOString()
              });
            } catch (error) {
              res.status(500).json({
                error: error.message,
                timestamp: new Date().toISOString()
              });
            }
          });
          
          console.log('🚀 STARTING SERVER...');
          const server = app.listen(PORT, HOST, () => {
            console.log(`✅ Server bound to ${HOST}:${PORT}`);
            
            setTimeout(async () => {
              console.log('🔧 Initializing database...');
              await initDatabase();
            }, 1000);
          });
          
          process.on('SIGTERM', () => {
            server.close(() => {
              if (dbPool) dbPool.end();
            });
          });
          EOF
          
          # Create Dockerfile
          cat > Dockerfile << 'EOF'
          FROM node:20-slim
          
          RUN apt-get update && apt-get install -y \
              python3 \
              build-essential \
              curl \
              && rm -rf /var/lib/apt/lists/*
          
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci --only=production
          COPY server-database-simple.js ./
          
          EXPOSE 8080
          
          HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
            CMD curl -f http://localhost:8080/health || exit 1
          
          CMD ["node", "server-database-simple.js"]
          EOF
          
          # Build and push
          docker build -t ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} .
          docker push ${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }}

      - name: Deploy to Cloud Run (Simple Strategy)
        run: |
          echo "Deploying simple database server..."
          
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-validation.outputs.image-tag }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --memory=${{ env.MEMORY }} \
            --cpu=${{ env.CPU }} \
            --timeout=${{ env.TIMEOUT }} \
            --concurrency=${{ env.CONCURRENCY }} \
            --min-instances=${{ env.MIN_INSTANCES }} \
            --max-instances=${{ env.MAX_INSTANCES }} \
            --port=8080 \
            --execution-environment=gen2 \
            --cpu-boost \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="NODE_ENV=production"
          
          echo "✅ Simple deployment completed"

      - name: Verify deployment
        run: |
          echo "Verifying simple database server..."
          
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          
          echo "Service URL: $SERVICE_URL"
          
          # Test health endpoint
          if curl -f "${SERVICE_URL}/health"; then
            echo "✅ Health check passed"
          else
            echo "❌ Health check failed"
            exit 1
          fi
          
          # Test database endpoint
          if curl -f "${SERVICE_URL}/db-test"; then
            echo "✅ Database test passed"
          else
            echo "❌ Database test failed"
            exit 1
          fi
          
          echo "🎉 SIMPLE DATABASE SERVER DEPLOYMENT SUCCESSFUL!"