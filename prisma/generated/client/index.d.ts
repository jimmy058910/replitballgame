
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model PlayerEquipment
 * 
 */
export type PlayerEquipment = $Result.DefaultSelection<Prisma.$PlayerEquipmentPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model PlayerSkillLink
 * 
 */
export type PlayerSkillLink = $Result.DefaultSelection<Prisma.$PlayerSkillLinkPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model TeamFinances
 * 
 */
export type TeamFinances = $Result.DefaultSelection<Prisma.$TeamFinancesPayload>
/**
 * Model Stadium
 * 
 */
export type Stadium = $Result.DefaultSelection<Prisma.$StadiumPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model ActiveBoost
 * 
 */
export type ActiveBoost = $Result.DefaultSelection<Prisma.$ActiveBoostPayload>
/**
 * Model MarketplaceListing
 * 
 */
export type MarketplaceListing = $Result.DefaultSelection<Prisma.$MarketplaceListingPayload>
/**
 * Model Bid
 * 
 */
export type Bid = $Result.DefaultSelection<Prisma.$BidPayload>
/**
 * Model ListingHistory
 * 
 */
export type ListingHistory = $Result.DefaultSelection<Prisma.$ListingHistoryPayload>
/**
 * Model PlayerMarketValue
 * 
 */
export type PlayerMarketValue = $Result.DefaultSelection<Prisma.$PlayerMarketValuePayload>
/**
 * Model Strategy
 * 
 */
export type Strategy = $Result.DefaultSelection<Prisma.$StrategyPayload>
/**
 * Model League
 * 
 */
export type League = $Result.DefaultSelection<Prisma.$LeaguePayload>
/**
 * Model LeagueStanding
 * 
 */
export type LeagueStanding = $Result.DefaultSelection<Prisma.$LeagueStandingPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model TryoutPack
 * 
 */
export type TryoutPack = $Result.DefaultSelection<Prisma.$TryoutPackPayload>
/**
 * Model TryoutHistory
 * 
 */
export type TryoutHistory = $Result.DefaultSelection<Prisma.$TryoutHistoryPayload>
/**
 * Model GemPack
 * 
 */
export type GemPack = $Result.DefaultSelection<Prisma.$GemPackPayload>
/**
 * Model CreditExchangeRate
 * 
 */
export type CreditExchangeRate = $Result.DefaultSelection<Prisma.$CreditExchangeRatePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model RedeemCode
 * 
 */
export type RedeemCode = $Result.DefaultSelection<Prisma.$RedeemCodePayload>
/**
 * Model RedeemCodeRecord
 * 
 */
export type RedeemCodeRecord = $Result.DefaultSelection<Prisma.$RedeemCodeRecordPayload>
/**
 * Model AdRewardMilestone
 * 
 */
export type AdRewardMilestone = $Result.DefaultSelection<Prisma.$AdRewardMilestonePayload>
/**
 * Model PremiumBoxReward
 * 
 */
export type PremiumBoxReward = $Result.DefaultSelection<Prisma.$PremiumBoxRewardPayload>
/**
 * Model EquipmentReward
 * 
 */
export type EquipmentReward = $Result.DefaultSelection<Prisma.$EquipmentRewardPayload>
/**
 * Model Tournament
 * 
 */
export type Tournament = $Result.DefaultSelection<Prisma.$TournamentPayload>
/**
 * Model TournamentEntry
 * 
 */
export type TournamentEntry = $Result.DefaultSelection<Prisma.$TournamentEntryPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FieldSize: {
  STANDARD: 'STANDARD',
  LARGE: 'LARGE',
  SMALL: 'SMALL'
};

export type FieldSize = (typeof FieldSize)[keyof typeof FieldSize]


export const TacticalFocus: {
  BALANCED: 'BALANCED',
  ALL_OUT_ATTACK: 'ALL_OUT_ATTACK',
  DEFENSIVE_WALL: 'DEFENSIVE_WALL'
};

export type TacticalFocus = (typeof TacticalFocus)[keyof typeof TacticalFocus]


export const Race: {
  HUMAN: 'HUMAN',
  SYLVAN: 'SYLVAN',
  GRYLL: 'GRYLL',
  LUMINA: 'LUMINA',
  UMBRA: 'UMBRA'
};

export type Race = (typeof Race)[keyof typeof Race]


export const PlayerRole: {
  PASSER: 'PASSER',
  RUNNER: 'RUNNER',
  BLOCKER: 'BLOCKER'
};

export type PlayerRole = (typeof PlayerRole)[keyof typeof PlayerRole]


export const InjuryStatus: {
  HEALTHY: 'HEALTHY',
  MINOR_INJURY: 'MINOR_INJURY',
  MODERATE_INJURY: 'MODERATE_INJURY',
  SEVERE_INJURY: 'SEVERE_INJURY'
};

export type InjuryStatus = (typeof InjuryStatus)[keyof typeof InjuryStatus]


export const SkillType: {
  PASSIVE: 'PASSIVE',
  ACTIVE: 'ACTIVE'
};

export type SkillType = (typeof SkillType)[keyof typeof SkillType]


export const SkillCategory: {
  UNIVERSAL: 'UNIVERSAL',
  ROLE: 'ROLE',
  RACE: 'RACE'
};

export type SkillCategory = (typeof SkillCategory)[keyof typeof SkillCategory]


export const StaffType: {
  HEAD_COACH: 'HEAD_COACH',
  PASSER_TRAINER: 'PASSER_TRAINER',
  RUNNER_TRAINER: 'RUNNER_TRAINER',
  BLOCKER_TRAINER: 'BLOCKER_TRAINER',
  RECOVERY_SPECIALIST: 'RECOVERY_SPECIALIST',
  SCOUT: 'SCOUT'
};

export type StaffType = (typeof StaffType)[keyof typeof StaffType]


export const ItemType: {
  EQUIPMENT: 'EQUIPMENT',
  CONSUMABLE_RECOVERY: 'CONSUMABLE_RECOVERY',
  CONSUMABLE_BOOSTER: 'CONSUMABLE_BOOSTER',
  TROPHY: 'TROPHY',
  GAME_ENTRY: 'GAME_ENTRY',
  COSMETIC: 'COSMETIC'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const EquipmentSlot: {
  HELMET: 'HELMET',
  FOOTWEAR: 'FOOTWEAR',
  GLOVES: 'GLOVES',
  ARMOR: 'ARMOR'
};

export type EquipmentSlot = (typeof EquipmentSlot)[keyof typeof EquipmentSlot]


export const ItemRarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY',
  UNIQUE: 'UNIQUE'
};

export type ItemRarity = (typeof ItemRarity)[keyof typeof ItemRarity]


export const MatchType: {
  LEAGUE: 'LEAGUE',
  TOURNAMENT_DAILY: 'TOURNAMENT_DAILY',
  TOURNAMENT_MIDSEASON: 'TOURNAMENT_MIDSEASON',
  EXHIBITION: 'EXHIBITION',
  PLAYOFF: 'PLAYOFF'
};

export type MatchType = (typeof MatchType)[keyof typeof MatchType]


export const MarketplaceStatus: {
  ACTIVE: 'ACTIVE',
  SOLD: 'SOLD',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED',
  BUY_NOW_ONLY: 'BUY_NOW_ONLY'
};

export type MarketplaceStatus = (typeof MarketplaceStatus)[keyof typeof MarketplaceStatus]


export const ListingActionType: {
  LISTING_CREATED: 'LISTING_CREATED',
  BID_PLACED: 'BID_PLACED',
  BID_OUTBID: 'BID_OUTBID',
  AUCTION_EXTENDED: 'AUCTION_EXTENDED',
  BUY_NOW_PURCHASE: 'BUY_NOW_PURCHASE',
  AUCTION_WON: 'AUCTION_WON',
  AUCTION_EXPIRED: 'AUCTION_EXPIRED',
  LISTING_CANCELLED: 'LISTING_CANCELLED',
  OFF_SEASON_CONVERTED: 'OFF_SEASON_CONVERTED',
  AUTO_DELISTED: 'AUTO_DELISTED'
};

export type ListingActionType = (typeof ListingActionType)[keyof typeof ListingActionType]


export const GameStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  POSTPONED: 'POSTPONED',
  CANCELLED: 'CANCELLED'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]


export const SeasonPhase: {
  REGULAR_SEASON: 'REGULAR_SEASON',
  PLAYOFFS: 'PLAYOFFS',
  OFF_SEASON: 'OFF_SEASON',
  PRE_SEASON: 'PRE_SEASON'
};

export type SeasonPhase = (typeof SeasonPhase)[keyof typeof SeasonPhase]


export const NotificationType: {
  CONTRACT_ALERT: 'CONTRACT_ALERT',
  INJURY_UPDATE: 'INJURY_UPDATE',
  MARKETPLACE_BID: 'MARKETPLACE_BID',
  MARKETPLACE_SOLD: 'MARKETPLACE_SOLD',
  MARKETPLACE_EXPIRED: 'MARKETPLACE_EXPIRED',
  SCOUTING_REPORT: 'SCOUTING_REPORT',
  MATCH_RESULT: 'MATCH_RESULT',
  TOURNAMENT_UPDATE: 'TOURNAMENT_UPDATE',
  RECRUIT_SIGNED: 'RECRUIT_SIGNED',
  SYSTEM_MESSAGE: 'SYSTEM_MESSAGE',
  TRADE_OFFER: 'TRADE_OFFER',
  TRADE_ACCEPTED: 'TRADE_ACCEPTED',
  TRADE_REJECTED: 'TRADE_REJECTED',
  LEAGUE_PROMOTION: 'LEAGUE_PROMOTION',
  LEAGUE_DEMOTION: 'LEAGUE_DEMOTION',
  NEW_SEASON: 'NEW_SEASON',
  PLAYER_RETIRED: 'PLAYER_RETIRED',
  PLAYER_PROGRESSED: 'PLAYER_PROGRESSED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const RewardType: {
  GEMS: 'GEMS',
  CREDITS: 'CREDITS',
  ITEM: 'ITEM',
  PREMIUM_BOX: 'PREMIUM_BOX'
};

export type RewardType = (typeof RewardType)[keyof typeof RewardType]


export const TournamentType: {
  DAILY_DIVISIONAL: 'DAILY_DIVISIONAL',
  MID_SEASON_CLASSIC: 'MID_SEASON_CLASSIC',
  SPECIAL_EVENT: 'SPECIAL_EVENT'
};

export type TournamentType = (typeof TournamentType)[keyof typeof TournamentType]


export const TournamentStatus: {
  REGISTRATION_OPEN: 'REGISTRATION_OPEN',
  REGISTRATION_CLOSED: 'REGISTRATION_CLOSED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TournamentStatus = (typeof TournamentStatus)[keyof typeof TournamentStatus]

}

export type FieldSize = $Enums.FieldSize

export const FieldSize: typeof $Enums.FieldSize

export type TacticalFocus = $Enums.TacticalFocus

export const TacticalFocus: typeof $Enums.TacticalFocus

export type Race = $Enums.Race

export const Race: typeof $Enums.Race

export type PlayerRole = $Enums.PlayerRole

export const PlayerRole: typeof $Enums.PlayerRole

export type InjuryStatus = $Enums.InjuryStatus

export const InjuryStatus: typeof $Enums.InjuryStatus

export type SkillType = $Enums.SkillType

export const SkillType: typeof $Enums.SkillType

export type SkillCategory = $Enums.SkillCategory

export const SkillCategory: typeof $Enums.SkillCategory

export type StaffType = $Enums.StaffType

export const StaffType: typeof $Enums.StaffType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type EquipmentSlot = $Enums.EquipmentSlot

export const EquipmentSlot: typeof $Enums.EquipmentSlot

export type ItemRarity = $Enums.ItemRarity

export const ItemRarity: typeof $Enums.ItemRarity

export type MatchType = $Enums.MatchType

export const MatchType: typeof $Enums.MatchType

export type MarketplaceStatus = $Enums.MarketplaceStatus

export const MarketplaceStatus: typeof $Enums.MarketplaceStatus

export type ListingActionType = $Enums.ListingActionType

export const ListingActionType: typeof $Enums.ListingActionType

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

export type SeasonPhase = $Enums.SeasonPhase

export const SeasonPhase: typeof $Enums.SeasonPhase

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type RewardType = $Enums.RewardType

export const RewardType: typeof $Enums.RewardType

export type TournamentType = $Enums.TournamentType

export const TournamentType: typeof $Enums.TournamentType

export type TournamentStatus = $Enums.TournamentStatus

export const TournamentStatus: typeof $Enums.TournamentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserProfiles
 * const userProfiles = await prisma.userProfile.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserProfiles
   * const userProfiles = await prisma.userProfile.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerEquipment`: Exposes CRUD operations for the **PlayerEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerEquipments
    * const playerEquipments = await prisma.playerEquipment.findMany()
    * ```
    */
  get playerEquipment(): Prisma.PlayerEquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerSkillLink`: Exposes CRUD operations for the **PlayerSkillLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerSkillLinks
    * const playerSkillLinks = await prisma.playerSkillLink.findMany()
    * ```
    */
  get playerSkillLink(): Prisma.PlayerSkillLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamFinances`: Exposes CRUD operations for the **TeamFinances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamFinances
    * const teamFinances = await prisma.teamFinances.findMany()
    * ```
    */
  get teamFinances(): Prisma.TeamFinancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stadium`: Exposes CRUD operations for the **Stadium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stadiums
    * const stadiums = await prisma.stadium.findMany()
    * ```
    */
  get stadium(): Prisma.StadiumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activeBoost`: Exposes CRUD operations for the **ActiveBoost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiveBoosts
    * const activeBoosts = await prisma.activeBoost.findMany()
    * ```
    */
  get activeBoost(): Prisma.ActiveBoostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplaceListing`: Exposes CRUD operations for the **MarketplaceListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceListings
    * const marketplaceListings = await prisma.marketplaceListing.findMany()
    * ```
    */
  get marketplaceListing(): Prisma.MarketplaceListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bid`: Exposes CRUD operations for the **Bid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bids
    * const bids = await prisma.bid.findMany()
    * ```
    */
  get bid(): Prisma.BidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listingHistory`: Exposes CRUD operations for the **ListingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListingHistories
    * const listingHistories = await prisma.listingHistory.findMany()
    * ```
    */
  get listingHistory(): Prisma.ListingHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerMarketValue`: Exposes CRUD operations for the **PlayerMarketValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerMarketValues
    * const playerMarketValues = await prisma.playerMarketValue.findMany()
    * ```
    */
  get playerMarketValue(): Prisma.PlayerMarketValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strategy`: Exposes CRUD operations for the **Strategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strategies
    * const strategies = await prisma.strategy.findMany()
    * ```
    */
  get strategy(): Prisma.StrategyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.league`: Exposes CRUD operations for the **League** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.league.findMany()
    * ```
    */
  get league(): Prisma.LeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leagueStanding`: Exposes CRUD operations for the **LeagueStanding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeagueStandings
    * const leagueStandings = await prisma.leagueStanding.findMany()
    * ```
    */
  get leagueStanding(): Prisma.LeagueStandingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tryoutPack`: Exposes CRUD operations for the **TryoutPack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TryoutPacks
    * const tryoutPacks = await prisma.tryoutPack.findMany()
    * ```
    */
  get tryoutPack(): Prisma.TryoutPackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tryoutHistory`: Exposes CRUD operations for the **TryoutHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TryoutHistories
    * const tryoutHistories = await prisma.tryoutHistory.findMany()
    * ```
    */
  get tryoutHistory(): Prisma.TryoutHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gemPack`: Exposes CRUD operations for the **GemPack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GemPacks
    * const gemPacks = await prisma.gemPack.findMany()
    * ```
    */
  get gemPack(): Prisma.GemPackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditExchangeRate`: Exposes CRUD operations for the **CreditExchangeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditExchangeRates
    * const creditExchangeRates = await prisma.creditExchangeRate.findMany()
    * ```
    */
  get creditExchangeRate(): Prisma.CreditExchangeRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemCode`: Exposes CRUD operations for the **RedeemCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedeemCodes
    * const redeemCodes = await prisma.redeemCode.findMany()
    * ```
    */
  get redeemCode(): Prisma.RedeemCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemCodeRecord`: Exposes CRUD operations for the **RedeemCodeRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedeemCodeRecords
    * const redeemCodeRecords = await prisma.redeemCodeRecord.findMany()
    * ```
    */
  get redeemCodeRecord(): Prisma.RedeemCodeRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adRewardMilestone`: Exposes CRUD operations for the **AdRewardMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdRewardMilestones
    * const adRewardMilestones = await prisma.adRewardMilestone.findMany()
    * ```
    */
  get adRewardMilestone(): Prisma.AdRewardMilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.premiumBoxReward`: Exposes CRUD operations for the **PremiumBoxReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PremiumBoxRewards
    * const premiumBoxRewards = await prisma.premiumBoxReward.findMany()
    * ```
    */
  get premiumBoxReward(): Prisma.PremiumBoxRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentReward`: Exposes CRUD operations for the **EquipmentReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentRewards
    * const equipmentRewards = await prisma.equipmentReward.findMany()
    * ```
    */
  get equipmentReward(): Prisma.EquipmentRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentEntry`: Exposes CRUD operations for the **TournamentEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentEntries
    * const tournamentEntries = await prisma.tournamentEntry.findMany()
    * ```
    */
  get tournamentEntry(): Prisma.TournamentEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserProfile: 'UserProfile',
    Session: 'Session',
    Team: 'Team',
    Player: 'Player',
    PlayerEquipment: 'PlayerEquipment',
    Contract: 'Contract',
    Skill: 'Skill',
    PlayerSkillLink: 'PlayerSkillLink',
    Staff: 'Staff',
    TeamFinances: 'TeamFinances',
    Stadium: 'Stadium',
    Item: 'Item',
    InventoryItem: 'InventoryItem',
    ActiveBoost: 'ActiveBoost',
    MarketplaceListing: 'MarketplaceListing',
    Bid: 'Bid',
    ListingHistory: 'ListingHistory',
    PlayerMarketValue: 'PlayerMarketValue',
    Strategy: 'Strategy',
    League: 'League',
    LeagueStanding: 'LeagueStanding',
    Game: 'Game',
    Season: 'Season',
    Notification: 'Notification',
    TryoutPack: 'TryoutPack',
    TryoutHistory: 'TryoutHistory',
    GemPack: 'GemPack',
    CreditExchangeRate: 'CreditExchangeRate',
    Referral: 'Referral',
    RedeemCode: 'RedeemCode',
    RedeemCodeRecord: 'RedeemCodeRecord',
    AdRewardMilestone: 'AdRewardMilestone',
    PremiumBoxReward: 'PremiumBoxReward',
    EquipmentReward: 'EquipmentReward',
    Tournament: 'Tournament',
    TournamentEntry: 'TournamentEntry',
    PaymentTransaction: 'PaymentTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userProfile" | "session" | "team" | "player" | "playerEquipment" | "contract" | "skill" | "playerSkillLink" | "staff" | "teamFinances" | "stadium" | "item" | "inventoryItem" | "activeBoost" | "marketplaceListing" | "bid" | "listingHistory" | "playerMarketValue" | "strategy" | "league" | "leagueStanding" | "game" | "season" | "notification" | "tryoutPack" | "tryoutHistory" | "gemPack" | "creditExchangeRate" | "referral" | "redeemCode" | "redeemCodeRecord" | "adRewardMilestone" | "premiumBoxReward" | "equipmentReward" | "tournament" | "tournamentEntry" | "paymentTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      PlayerEquipment: {
        payload: Prisma.$PlayerEquipmentPayload<ExtArgs>
        fields: Prisma.PlayerEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          findFirst: {
            args: Prisma.PlayerEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          findMany: {
            args: Prisma.PlayerEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>[]
          }
          create: {
            args: Prisma.PlayerEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          createMany: {
            args: Prisma.PlayerEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>[]
          }
          delete: {
            args: Prisma.PlayerEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          update: {
            args: Prisma.PlayerEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.PlayerEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerEquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>[]
          }
          upsert: {
            args: Prisma.PlayerEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEquipmentPayload>
          }
          aggregate: {
            args: Prisma.PlayerEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerEquipment>
          }
          groupBy: {
            args: Prisma.PlayerEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerEquipmentCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      PlayerSkillLink: {
        payload: Prisma.$PlayerSkillLinkPayload<ExtArgs>
        fields: Prisma.PlayerSkillLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerSkillLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerSkillLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          findFirst: {
            args: Prisma.PlayerSkillLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerSkillLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          findMany: {
            args: Prisma.PlayerSkillLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>[]
          }
          create: {
            args: Prisma.PlayerSkillLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          createMany: {
            args: Prisma.PlayerSkillLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerSkillLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>[]
          }
          delete: {
            args: Prisma.PlayerSkillLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          update: {
            args: Prisma.PlayerSkillLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          deleteMany: {
            args: Prisma.PlayerSkillLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerSkillLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerSkillLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>[]
          }
          upsert: {
            args: Prisma.PlayerSkillLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillLinkPayload>
          }
          aggregate: {
            args: Prisma.PlayerSkillLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerSkillLink>
          }
          groupBy: {
            args: Prisma.PlayerSkillLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerSkillLinkCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillLinkCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      TeamFinances: {
        payload: Prisma.$TeamFinancesPayload<ExtArgs>
        fields: Prisma.TeamFinancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFinancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFinancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          findFirst: {
            args: Prisma.TeamFinancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFinancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          findMany: {
            args: Prisma.TeamFinancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>[]
          }
          create: {
            args: Prisma.TeamFinancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          createMany: {
            args: Prisma.TeamFinancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamFinancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>[]
          }
          delete: {
            args: Prisma.TeamFinancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          update: {
            args: Prisma.TeamFinancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          deleteMany: {
            args: Prisma.TeamFinancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamFinancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamFinancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>[]
          }
          upsert: {
            args: Prisma.TeamFinancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamFinancesPayload>
          }
          aggregate: {
            args: Prisma.TeamFinancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamFinances>
          }
          groupBy: {
            args: Prisma.TeamFinancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamFinancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamFinancesCountArgs<ExtArgs>
            result: $Utils.Optional<TeamFinancesCountAggregateOutputType> | number
          }
        }
      }
      Stadium: {
        payload: Prisma.$StadiumPayload<ExtArgs>
        fields: Prisma.StadiumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StadiumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StadiumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          findFirst: {
            args: Prisma.StadiumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StadiumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          findMany: {
            args: Prisma.StadiumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>[]
          }
          create: {
            args: Prisma.StadiumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          createMany: {
            args: Prisma.StadiumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StadiumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>[]
          }
          delete: {
            args: Prisma.StadiumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          update: {
            args: Prisma.StadiumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          deleteMany: {
            args: Prisma.StadiumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StadiumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StadiumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>[]
          }
          upsert: {
            args: Prisma.StadiumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StadiumPayload>
          }
          aggregate: {
            args: Prisma.StadiumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStadium>
          }
          groupBy: {
            args: Prisma.StadiumGroupByArgs<ExtArgs>
            result: $Utils.Optional<StadiumGroupByOutputType>[]
          }
          count: {
            args: Prisma.StadiumCountArgs<ExtArgs>
            result: $Utils.Optional<StadiumCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      ActiveBoost: {
        payload: Prisma.$ActiveBoostPayload<ExtArgs>
        fields: Prisma.ActiveBoostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiveBoostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiveBoostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          findFirst: {
            args: Prisma.ActiveBoostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiveBoostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          findMany: {
            args: Prisma.ActiveBoostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>[]
          }
          create: {
            args: Prisma.ActiveBoostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          createMany: {
            args: Prisma.ActiveBoostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActiveBoostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>[]
          }
          delete: {
            args: Prisma.ActiveBoostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          update: {
            args: Prisma.ActiveBoostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          deleteMany: {
            args: Prisma.ActiveBoostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiveBoostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActiveBoostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>[]
          }
          upsert: {
            args: Prisma.ActiveBoostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveBoostPayload>
          }
          aggregate: {
            args: Prisma.ActiveBoostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiveBoost>
          }
          groupBy: {
            args: Prisma.ActiveBoostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiveBoostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiveBoostCountArgs<ExtArgs>
            result: $Utils.Optional<ActiveBoostCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceListing: {
        payload: Prisma.$MarketplaceListingPayload<ExtArgs>
        fields: Prisma.MarketplaceListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findMany: {
            args: Prisma.MarketplaceListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          create: {
            args: Prisma.MarketplaceListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          createMany: {
            args: Prisma.MarketplaceListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          update: {
            args: Prisma.MarketplaceListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          upsert: {
            args: Prisma.MarketplaceListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceListing>
          }
          groupBy: {
            args: Prisma.MarketplaceListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceListingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingCountAggregateOutputType> | number
          }
        }
      }
      Bid: {
        payload: Prisma.$BidPayload<ExtArgs>
        fields: Prisma.BidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findFirst: {
            args: Prisma.BidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findMany: {
            args: Prisma.BidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          create: {
            args: Prisma.BidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          createMany: {
            args: Prisma.BidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          delete: {
            args: Prisma.BidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          update: {
            args: Prisma.BidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          deleteMany: {
            args: Prisma.BidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          upsert: {
            args: Prisma.BidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          aggregate: {
            args: Prisma.BidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBid>
          }
          groupBy: {
            args: Prisma.BidGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidCountArgs<ExtArgs>
            result: $Utils.Optional<BidCountAggregateOutputType> | number
          }
        }
      }
      ListingHistory: {
        payload: Prisma.$ListingHistoryPayload<ExtArgs>
        fields: Prisma.ListingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          findFirst: {
            args: Prisma.ListingHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          findMany: {
            args: Prisma.ListingHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>[]
          }
          create: {
            args: Prisma.ListingHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          createMany: {
            args: Prisma.ListingHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListingHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>[]
          }
          delete: {
            args: Prisma.ListingHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          update: {
            args: Prisma.ListingHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ListingHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListingHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListingHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ListingHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingHistoryPayload>
          }
          aggregate: {
            args: Prisma.ListingHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListingHistory>
          }
          groupBy: {
            args: Prisma.ListingHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListingHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ListingHistoryCountAggregateOutputType> | number
          }
        }
      }
      PlayerMarketValue: {
        payload: Prisma.$PlayerMarketValuePayload<ExtArgs>
        fields: Prisma.PlayerMarketValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerMarketValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerMarketValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          findFirst: {
            args: Prisma.PlayerMarketValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerMarketValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          findMany: {
            args: Prisma.PlayerMarketValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>[]
          }
          create: {
            args: Prisma.PlayerMarketValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          createMany: {
            args: Prisma.PlayerMarketValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerMarketValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>[]
          }
          delete: {
            args: Prisma.PlayerMarketValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          update: {
            args: Prisma.PlayerMarketValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          deleteMany: {
            args: Prisma.PlayerMarketValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerMarketValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerMarketValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>[]
          }
          upsert: {
            args: Prisma.PlayerMarketValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMarketValuePayload>
          }
          aggregate: {
            args: Prisma.PlayerMarketValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerMarketValue>
          }
          groupBy: {
            args: Prisma.PlayerMarketValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerMarketValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerMarketValueCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerMarketValueCountAggregateOutputType> | number
          }
        }
      }
      Strategy: {
        payload: Prisma.$StrategyPayload<ExtArgs>
        fields: Prisma.StrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          findFirst: {
            args: Prisma.StrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          findMany: {
            args: Prisma.StrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>[]
          }
          create: {
            args: Prisma.StrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          createMany: {
            args: Prisma.StrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>[]
          }
          delete: {
            args: Prisma.StrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          update: {
            args: Prisma.StrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          deleteMany: {
            args: Prisma.StrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StrategyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>[]
          }
          upsert: {
            args: Prisma.StrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyPayload>
          }
          aggregate: {
            args: Prisma.StrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategy>
          }
          groupBy: {
            args: Prisma.StrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyCountAggregateOutputType> | number
          }
        }
      }
      League: {
        payload: Prisma.$LeaguePayload<ExtArgs>
        fields: Prisma.LeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findFirst: {
            args: Prisma.LeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findMany: {
            args: Prisma.LeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          create: {
            args: Prisma.LeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          createMany: {
            args: Prisma.LeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          delete: {
            args: Prisma.LeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          update: {
            args: Prisma.LeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          deleteMany: {
            args: Prisma.LeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          upsert: {
            args: Prisma.LeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          aggregate: {
            args: Prisma.LeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeague>
          }
          groupBy: {
            args: Prisma.LeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueCountAggregateOutputType> | number
          }
        }
      }
      LeagueStanding: {
        payload: Prisma.$LeagueStandingPayload<ExtArgs>
        fields: Prisma.LeagueStandingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueStandingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueStandingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          findFirst: {
            args: Prisma.LeagueStandingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueStandingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          findMany: {
            args: Prisma.LeagueStandingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>[]
          }
          create: {
            args: Prisma.LeagueStandingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          createMany: {
            args: Prisma.LeagueStandingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueStandingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>[]
          }
          delete: {
            args: Prisma.LeagueStandingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          update: {
            args: Prisma.LeagueStandingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          deleteMany: {
            args: Prisma.LeagueStandingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueStandingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueStandingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>[]
          }
          upsert: {
            args: Prisma.LeagueStandingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueStandingPayload>
          }
          aggregate: {
            args: Prisma.LeagueStandingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeagueStanding>
          }
          groupBy: {
            args: Prisma.LeagueStandingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueStandingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueStandingCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueStandingCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      TryoutPack: {
        payload: Prisma.$TryoutPackPayload<ExtArgs>
        fields: Prisma.TryoutPackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TryoutPackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TryoutPackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          findFirst: {
            args: Prisma.TryoutPackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TryoutPackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          findMany: {
            args: Prisma.TryoutPackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>[]
          }
          create: {
            args: Prisma.TryoutPackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          createMany: {
            args: Prisma.TryoutPackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TryoutPackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>[]
          }
          delete: {
            args: Prisma.TryoutPackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          update: {
            args: Prisma.TryoutPackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          deleteMany: {
            args: Prisma.TryoutPackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TryoutPackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TryoutPackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>[]
          }
          upsert: {
            args: Prisma.TryoutPackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutPackPayload>
          }
          aggregate: {
            args: Prisma.TryoutPackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTryoutPack>
          }
          groupBy: {
            args: Prisma.TryoutPackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TryoutPackGroupByOutputType>[]
          }
          count: {
            args: Prisma.TryoutPackCountArgs<ExtArgs>
            result: $Utils.Optional<TryoutPackCountAggregateOutputType> | number
          }
        }
      }
      TryoutHistory: {
        payload: Prisma.$TryoutHistoryPayload<ExtArgs>
        fields: Prisma.TryoutHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TryoutHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TryoutHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          findFirst: {
            args: Prisma.TryoutHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TryoutHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          findMany: {
            args: Prisma.TryoutHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>[]
          }
          create: {
            args: Prisma.TryoutHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          createMany: {
            args: Prisma.TryoutHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TryoutHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>[]
          }
          delete: {
            args: Prisma.TryoutHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          update: {
            args: Prisma.TryoutHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TryoutHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TryoutHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TryoutHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>[]
          }
          upsert: {
            args: Prisma.TryoutHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TryoutHistoryPayload>
          }
          aggregate: {
            args: Prisma.TryoutHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTryoutHistory>
          }
          groupBy: {
            args: Prisma.TryoutHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TryoutHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TryoutHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TryoutHistoryCountAggregateOutputType> | number
          }
        }
      }
      GemPack: {
        payload: Prisma.$GemPackPayload<ExtArgs>
        fields: Prisma.GemPackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GemPackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GemPackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          findFirst: {
            args: Prisma.GemPackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GemPackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          findMany: {
            args: Prisma.GemPackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>[]
          }
          create: {
            args: Prisma.GemPackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          createMany: {
            args: Prisma.GemPackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GemPackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>[]
          }
          delete: {
            args: Prisma.GemPackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          update: {
            args: Prisma.GemPackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          deleteMany: {
            args: Prisma.GemPackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GemPackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GemPackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>[]
          }
          upsert: {
            args: Prisma.GemPackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GemPackPayload>
          }
          aggregate: {
            args: Prisma.GemPackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGemPack>
          }
          groupBy: {
            args: Prisma.GemPackGroupByArgs<ExtArgs>
            result: $Utils.Optional<GemPackGroupByOutputType>[]
          }
          count: {
            args: Prisma.GemPackCountArgs<ExtArgs>
            result: $Utils.Optional<GemPackCountAggregateOutputType> | number
          }
        }
      }
      CreditExchangeRate: {
        payload: Prisma.$CreditExchangeRatePayload<ExtArgs>
        fields: Prisma.CreditExchangeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditExchangeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditExchangeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          findFirst: {
            args: Prisma.CreditExchangeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditExchangeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          findMany: {
            args: Prisma.CreditExchangeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>[]
          }
          create: {
            args: Prisma.CreditExchangeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          createMany: {
            args: Prisma.CreditExchangeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditExchangeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>[]
          }
          delete: {
            args: Prisma.CreditExchangeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          update: {
            args: Prisma.CreditExchangeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          deleteMany: {
            args: Prisma.CreditExchangeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditExchangeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditExchangeRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>[]
          }
          upsert: {
            args: Prisma.CreditExchangeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditExchangeRatePayload>
          }
          aggregate: {
            args: Prisma.CreditExchangeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditExchangeRate>
          }
          groupBy: {
            args: Prisma.CreditExchangeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditExchangeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditExchangeRateCountArgs<ExtArgs>
            result: $Utils.Optional<CreditExchangeRateCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      RedeemCode: {
        payload: Prisma.$RedeemCodePayload<ExtArgs>
        fields: Prisma.RedeemCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedeemCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedeemCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findFirst: {
            args: Prisma.RedeemCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedeemCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findMany: {
            args: Prisma.RedeemCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          create: {
            args: Prisma.RedeemCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          createMany: {
            args: Prisma.RedeemCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedeemCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          delete: {
            args: Prisma.RedeemCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          update: {
            args: Prisma.RedeemCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          deleteMany: {
            args: Prisma.RedeemCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedeemCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedeemCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          upsert: {
            args: Prisma.RedeemCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          aggregate: {
            args: Prisma.RedeemCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemCode>
          }
          groupBy: {
            args: Prisma.RedeemCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedeemCodeCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeCountAggregateOutputType> | number
          }
        }
      }
      RedeemCodeRecord: {
        payload: Prisma.$RedeemCodeRecordPayload<ExtArgs>
        fields: Prisma.RedeemCodeRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedeemCodeRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedeemCodeRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          findFirst: {
            args: Prisma.RedeemCodeRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedeemCodeRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          findMany: {
            args: Prisma.RedeemCodeRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>[]
          }
          create: {
            args: Prisma.RedeemCodeRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          createMany: {
            args: Prisma.RedeemCodeRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedeemCodeRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>[]
          }
          delete: {
            args: Prisma.RedeemCodeRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          update: {
            args: Prisma.RedeemCodeRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          deleteMany: {
            args: Prisma.RedeemCodeRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedeemCodeRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedeemCodeRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>[]
          }
          upsert: {
            args: Prisma.RedeemCodeRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodeRecordPayload>
          }
          aggregate: {
            args: Prisma.RedeemCodeRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemCodeRecord>
          }
          groupBy: {
            args: Prisma.RedeemCodeRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedeemCodeRecordCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeRecordCountAggregateOutputType> | number
          }
        }
      }
      AdRewardMilestone: {
        payload: Prisma.$AdRewardMilestonePayload<ExtArgs>
        fields: Prisma.AdRewardMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdRewardMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdRewardMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          findFirst: {
            args: Prisma.AdRewardMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdRewardMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          findMany: {
            args: Prisma.AdRewardMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>[]
          }
          create: {
            args: Prisma.AdRewardMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          createMany: {
            args: Prisma.AdRewardMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdRewardMilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>[]
          }
          delete: {
            args: Prisma.AdRewardMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          update: {
            args: Prisma.AdRewardMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          deleteMany: {
            args: Prisma.AdRewardMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdRewardMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdRewardMilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>[]
          }
          upsert: {
            args: Prisma.AdRewardMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRewardMilestonePayload>
          }
          aggregate: {
            args: Prisma.AdRewardMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdRewardMilestone>
          }
          groupBy: {
            args: Prisma.AdRewardMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdRewardMilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdRewardMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<AdRewardMilestoneCountAggregateOutputType> | number
          }
        }
      }
      PremiumBoxReward: {
        payload: Prisma.$PremiumBoxRewardPayload<ExtArgs>
        fields: Prisma.PremiumBoxRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PremiumBoxRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PremiumBoxRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          findFirst: {
            args: Prisma.PremiumBoxRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PremiumBoxRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          findMany: {
            args: Prisma.PremiumBoxRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>[]
          }
          create: {
            args: Prisma.PremiumBoxRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          createMany: {
            args: Prisma.PremiumBoxRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PremiumBoxRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>[]
          }
          delete: {
            args: Prisma.PremiumBoxRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          update: {
            args: Prisma.PremiumBoxRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          deleteMany: {
            args: Prisma.PremiumBoxRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PremiumBoxRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PremiumBoxRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>[]
          }
          upsert: {
            args: Prisma.PremiumBoxRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremiumBoxRewardPayload>
          }
          aggregate: {
            args: Prisma.PremiumBoxRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePremiumBoxReward>
          }
          groupBy: {
            args: Prisma.PremiumBoxRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<PremiumBoxRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.PremiumBoxRewardCountArgs<ExtArgs>
            result: $Utils.Optional<PremiumBoxRewardCountAggregateOutputType> | number
          }
        }
      }
      EquipmentReward: {
        payload: Prisma.$EquipmentRewardPayload<ExtArgs>
        fields: Prisma.EquipmentRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          findFirst: {
            args: Prisma.EquipmentRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          findMany: {
            args: Prisma.EquipmentRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>[]
          }
          create: {
            args: Prisma.EquipmentRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          createMany: {
            args: Prisma.EquipmentRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>[]
          }
          delete: {
            args: Prisma.EquipmentRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          update: {
            args: Prisma.EquipmentRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRewardPayload>
          }
          aggregate: {
            args: Prisma.EquipmentRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentReward>
          }
          groupBy: {
            args: Prisma.EquipmentRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentRewardCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentRewardCountAggregateOutputType> | number
          }
        }
      }
      Tournament: {
        payload: Prisma.$TournamentPayload<ExtArgs>
        fields: Prisma.TournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findFirst: {
            args: Prisma.TournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findMany: {
            args: Prisma.TournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          create: {
            args: Prisma.TournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          createMany: {
            args: Prisma.TournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          delete: {
            args: Prisma.TournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          update: {
            args: Prisma.TournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          deleteMany: {
            args: Prisma.TournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          upsert: {
            args: Prisma.TournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.TournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      TournamentEntry: {
        payload: Prisma.$TournamentEntryPayload<ExtArgs>
        fields: Prisma.TournamentEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          findFirst: {
            args: Prisma.TournamentEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          findMany: {
            args: Prisma.TournamentEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>[]
          }
          create: {
            args: Prisma.TournamentEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          createMany: {
            args: Prisma.TournamentEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>[]
          }
          delete: {
            args: Prisma.TournamentEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          update: {
            args: Prisma.TournamentEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          deleteMany: {
            args: Prisma.TournamentEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>[]
          }
          upsert: {
            args: Prisma.TournamentEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentEntryPayload>
          }
          aggregate: {
            args: Prisma.TournamentEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentEntry>
          }
          groupBy: {
            args: Prisma.TournamentEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentEntryCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    userProfile?: UserProfileOmit
    session?: SessionOmit
    team?: TeamOmit
    player?: PlayerOmit
    playerEquipment?: PlayerEquipmentOmit
    contract?: ContractOmit
    skill?: SkillOmit
    playerSkillLink?: PlayerSkillLinkOmit
    staff?: StaffOmit
    teamFinances?: TeamFinancesOmit
    stadium?: StadiumOmit
    item?: ItemOmit
    inventoryItem?: InventoryItemOmit
    activeBoost?: ActiveBoostOmit
    marketplaceListing?: MarketplaceListingOmit
    bid?: BidOmit
    listingHistory?: ListingHistoryOmit
    playerMarketValue?: PlayerMarketValueOmit
    strategy?: StrategyOmit
    league?: LeagueOmit
    leagueStanding?: LeagueStandingOmit
    game?: GameOmit
    season?: SeasonOmit
    notification?: NotificationOmit
    tryoutPack?: TryoutPackOmit
    tryoutHistory?: TryoutHistoryOmit
    gemPack?: GemPackOmit
    creditExchangeRate?: CreditExchangeRateOmit
    referral?: ReferralOmit
    redeemCode?: RedeemCodeOmit
    redeemCodeRecord?: RedeemCodeRecordOmit
    adRewardMilestone?: AdRewardMilestoneOmit
    premiumBoxReward?: PremiumBoxRewardOmit
    equipmentReward?: EquipmentRewardOmit
    tournament?: TournamentOmit
    tournamentEntry?: TournamentEntryOmit
    paymentTransaction?: PaymentTransactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    redeemedCodes: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemedCodes?: boolean | UserProfileCountOutputTypeCountRedeemedCodesArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountRedeemedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeRecordWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    players: number
    staff: number
    inventoryItems: number
    activeBoosts: number
    marketplaceListings: number
    bids: number
    highBidderOnListings: number
    listingHistory: number
    notifications: number
    tournamentEntries: number
    tryoutHistory: number
    homeTeamGames: number
    awayTeamGames: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | TeamCountOutputTypeCountPlayersArgs
    staff?: boolean | TeamCountOutputTypeCountStaffArgs
    inventoryItems?: boolean | TeamCountOutputTypeCountInventoryItemsArgs
    activeBoosts?: boolean | TeamCountOutputTypeCountActiveBoostsArgs
    marketplaceListings?: boolean | TeamCountOutputTypeCountMarketplaceListingsArgs
    bids?: boolean | TeamCountOutputTypeCountBidsArgs
    highBidderOnListings?: boolean | TeamCountOutputTypeCountHighBidderOnListingsArgs
    listingHistory?: boolean | TeamCountOutputTypeCountListingHistoryArgs
    notifications?: boolean | TeamCountOutputTypeCountNotificationsArgs
    tournamentEntries?: boolean | TeamCountOutputTypeCountTournamentEntriesArgs
    tryoutHistory?: boolean | TeamCountOutputTypeCountTryoutHistoryArgs
    homeTeamGames?: boolean | TeamCountOutputTypeCountHomeTeamGamesArgs
    awayTeamGames?: boolean | TeamCountOutputTypeCountAwayTeamGamesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountActiveBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveBoostWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMarketplaceListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountHighBidderOnListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountListingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingHistoryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTournamentEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentEntryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TryoutHistoryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountHomeTeamGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAwayTeamGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    skills: number
    tryoutHistory: number
    activeBoosts: number
    currentEquipment: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | PlayerCountOutputTypeCountSkillsArgs
    tryoutHistory?: boolean | PlayerCountOutputTypeCountTryoutHistoryArgs
    activeBoosts?: boolean | PlayerCountOutputTypeCountActiveBoostsArgs
    currentEquipment?: boolean | PlayerCountOutputTypeCountCurrentEquipmentArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillLinkWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountTryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TryoutHistoryWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountActiveBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveBoostWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCurrentEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    playerLinks: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerLinks?: boolean | SkillCountOutputTypeCountPlayerLinksArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountPlayerLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillLinkWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    inventoryItems: number
    activeBoosts: number
    PlayerEquipment: number
    PremiumBoxRewards: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ItemCountOutputTypeCountInventoryItemsArgs
    activeBoosts?: boolean | ItemCountOutputTypeCountActiveBoostsArgs
    PlayerEquipment?: boolean | ItemCountOutputTypeCountPlayerEquipmentArgs
    PremiumBoxRewards?: boolean | ItemCountOutputTypeCountPremiumBoxRewardsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountActiveBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveBoostWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPlayerEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPremiumBoxRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentRewardWhereInput
  }


  /**
   * Count Type MarketplaceListingCountOutputType
   */

  export type MarketplaceListingCountOutputType = {
    bids: number
    history: number
  }

  export type MarketplaceListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | MarketplaceListingCountOutputTypeCountBidsArgs
    history?: boolean | MarketplaceListingCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * MarketplaceListingCountOutputType without action
   */
  export type MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListingCountOutputType
     */
    select?: MarketplaceListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketplaceListingCountOutputType without action
   */
  export type MarketplaceListingCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * MarketplaceListingCountOutputType without action
   */
  export type MarketplaceListingCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingHistoryWhereInput
  }


  /**
   * Count Type LeagueCountOutputType
   */

  export type LeagueCountOutputType = {
    teams: number
    schedule: number
    standings: number
  }

  export type LeagueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | LeagueCountOutputTypeCountTeamsArgs
    schedule?: boolean | LeagueCountOutputTypeCountScheduleArgs
    standings?: boolean | LeagueCountOutputTypeCountStandingsArgs
  }

  // Custom InputTypes
  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueCountOutputType
     */
    select?: LeagueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountStandingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueStandingWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    leagues: number
    tryoutHistory: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leagues?: boolean | SeasonCountOutputTypeCountLeaguesArgs
    tryoutHistory?: boolean | SeasonCountOutputTypeCountTryoutHistoryArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountLeaguesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountTryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TryoutHistoryWhereInput
  }


  /**
   * Count Type RedeemCodeCountOutputType
   */

  export type RedeemCodeCountOutputType = {
    redeemedBy: number
  }

  export type RedeemCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemedBy?: boolean | RedeemCodeCountOutputTypeCountRedeemedByArgs
  }

  // Custom InputTypes
  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeCountOutputType
     */
    select?: RedeemCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeCountRedeemedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeRecordWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    games: number
    entries: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | TournamentCountOutputTypeCountGamesArgs
    entries?: boolean | TournamentCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    id: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    id: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: number | null
    userId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredBy: string | null
    ndaAccepted: boolean | null
    ndaAcceptedAt: Date | null
    ndaVersion: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredBy: string | null
    ndaAccepted: boolean | null
    ndaAcceptedAt: Date | null
    ndaVersion: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    firstName: number
    lastName: number
    profileImageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    referralCode: number
    referredBy: number
    ndaAccepted: number
    ndaAcceptedAt: number
    ndaVersion: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    id?: true
  }

  export type UserProfileSumAggregateInputType = {
    id?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredBy?: true
    ndaAccepted?: true
    ndaAcceptedAt?: true
    ndaVersion?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredBy?: true
    ndaAccepted?: true
    ndaAcceptedAt?: true
    ndaVersion?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredBy?: true
    ndaAccepted?: true
    ndaAcceptedAt?: true
    ndaVersion?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: number
    userId: string
    email: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    referralCode: string | null
    referredBy: string | null
    ndaAccepted: boolean
    ndaAcceptedAt: Date | null
    ndaVersion: string | null
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredBy?: boolean
    ndaAccepted?: boolean
    ndaAcceptedAt?: boolean
    ndaVersion?: boolean
    Team?: boolean | UserProfile$TeamArgs<ExtArgs>
    redeemedCodes?: boolean | UserProfile$redeemedCodesArgs<ExtArgs>
    adRewardMilestone?: boolean | UserProfile$adRewardMilestoneArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredBy?: boolean
    ndaAccepted?: boolean
    ndaAcceptedAt?: boolean
    ndaVersion?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredBy?: boolean
    ndaAccepted?: boolean
    ndaAcceptedAt?: boolean
    ndaVersion?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredBy?: boolean
    ndaAccepted?: boolean
    ndaAcceptedAt?: boolean
    ndaVersion?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "firstName" | "lastName" | "profileImageUrl" | "bio" | "createdAt" | "updatedAt" | "referralCode" | "referredBy" | "ndaAccepted" | "ndaAcceptedAt" | "ndaVersion", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Team?: boolean | UserProfile$TeamArgs<ExtArgs>
    redeemedCodes?: boolean | UserProfile$redeemedCodesArgs<ExtArgs>
    adRewardMilestone?: boolean | UserProfile$adRewardMilestoneArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      Team: Prisma.$TeamPayload<ExtArgs> | null
      redeemedCodes: Prisma.$RedeemCodeRecordPayload<ExtArgs>[]
      adRewardMilestone: Prisma.$AdRewardMilestonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      email: string | null
      firstName: string | null
      lastName: string | null
      profileImageUrl: string | null
      bio: string | null
      createdAt: Date
      updatedAt: Date
      referralCode: string | null
      referredBy: string | null
      ndaAccepted: boolean
      ndaAcceptedAt: Date | null
      ndaVersion: string | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Team<T extends UserProfile$TeamArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$TeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    redeemedCodes<T extends UserProfile$redeemedCodesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$redeemedCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adRewardMilestone<T extends UserProfile$adRewardMilestoneArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$adRewardMilestoneArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'Int'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly email: FieldRef<"UserProfile", 'String'>
    readonly firstName: FieldRef<"UserProfile", 'String'>
    readonly lastName: FieldRef<"UserProfile", 'String'>
    readonly profileImageUrl: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly referralCode: FieldRef<"UserProfile", 'String'>
    readonly referredBy: FieldRef<"UserProfile", 'String'>
    readonly ndaAccepted: FieldRef<"UserProfile", 'Boolean'>
    readonly ndaAcceptedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly ndaVersion: FieldRef<"UserProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile.Team
   */
  export type UserProfile$TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * UserProfile.redeemedCodes
   */
  export type UserProfile$redeemedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    where?: RedeemCodeRecordWhereInput
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    cursor?: RedeemCodeRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemCodeRecordScalarFieldEnum | RedeemCodeRecordScalarFieldEnum[]
  }

  /**
   * UserProfile.adRewardMilestone
   */
  export type UserProfile$adRewardMilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    where?: AdRewardMilestoneWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sid: string | null
    expire: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    sid: string | null
    expire: Date | null
  }

  export type SessionCountAggregateOutputType = {
    sid: number
    sess: number
    expire: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sid?: true
    expire?: true
  }

  export type SessionMaxAggregateInputType = {
    sid?: true
    expire?: true
  }

  export type SessionCountAggregateInputType = {
    sid?: true
    sess?: true
    expire?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sid: string
    sess: JsonValue
    expire: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sid" | "sess" | "expire", ExtArgs["result"]["session"]>

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sid: string
      sess: Prisma.JsonValue
      expire: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const sessionWithSidOnly = await prisma.session.findMany({ select: { sid: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sid`
     * const sessionWithSidOnly = await prisma.session.createManyAndReturn({
     *   select: { sid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `sid`
     * const sessionWithSidOnly = await prisma.session.updateManyAndReturn({
     *   select: { sid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly sid: FieldRef<"Session", 'String'>
    readonly sess: FieldRef<"Session", 'Json'>
    readonly expire: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    camaraderie: number | null
    fanLoyalty: number | null
    leagueId: number | null
    division: number | null
    wins: number | null
    losses: number | null
    points: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    camaraderie: number | null
    fanLoyalty: number | null
    leagueId: number | null
    division: number | null
    wins: number | null
    losses: number | null
    points: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    name: string | null
    logoUrl: string | null
    isAI: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    camaraderie: number | null
    fanLoyalty: number | null
    homeField: $Enums.FieldSize | null
    tacticalFocus: $Enums.TacticalFocus | null
    leagueId: number | null
    division: number | null
    subdivision: string | null
    wins: number | null
    losses: number | null
    points: number | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    name: string | null
    logoUrl: string | null
    isAI: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    camaraderie: number | null
    fanLoyalty: number | null
    homeField: $Enums.FieldSize | null
    tacticalFocus: $Enums.TacticalFocus | null
    leagueId: number | null
    division: number | null
    subdivision: string | null
    wins: number | null
    losses: number | null
    points: number | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    userProfileId: number
    name: number
    logoUrl: number
    isAI: number
    createdAt: number
    updatedAt: number
    camaraderie: number
    fanLoyalty: number
    homeField: number
    tacticalFocus: number
    leagueId: number
    division: number
    subdivision: number
    wins: number
    losses: number
    points: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    userProfileId?: true
    camaraderie?: true
    fanLoyalty?: true
    leagueId?: true
    division?: true
    wins?: true
    losses?: true
    points?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    userProfileId?: true
    camaraderie?: true
    fanLoyalty?: true
    leagueId?: true
    division?: true
    wins?: true
    losses?: true
    points?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    userProfileId?: true
    name?: true
    logoUrl?: true
    isAI?: true
    createdAt?: true
    updatedAt?: true
    camaraderie?: true
    fanLoyalty?: true
    homeField?: true
    tacticalFocus?: true
    leagueId?: true
    division?: true
    subdivision?: true
    wins?: true
    losses?: true
    points?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    name?: true
    logoUrl?: true
    isAI?: true
    createdAt?: true
    updatedAt?: true
    camaraderie?: true
    fanLoyalty?: true
    homeField?: true
    tacticalFocus?: true
    leagueId?: true
    division?: true
    subdivision?: true
    wins?: true
    losses?: true
    points?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    userProfileId?: true
    name?: true
    logoUrl?: true
    isAI?: true
    createdAt?: true
    updatedAt?: true
    camaraderie?: true
    fanLoyalty?: true
    homeField?: true
    tacticalFocus?: true
    leagueId?: true
    division?: true
    subdivision?: true
    wins?: true
    losses?: true
    points?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    userProfileId: number
    name: string
    logoUrl: string | null
    isAI: boolean
    createdAt: Date
    updatedAt: Date
    camaraderie: number
    fanLoyalty: number
    homeField: $Enums.FieldSize
    tacticalFocus: $Enums.TacticalFocus
    leagueId: number | null
    division: number | null
    subdivision: string | null
    wins: number
    losses: number
    points: number
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    name?: boolean
    logoUrl?: boolean
    isAI?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    camaraderie?: boolean
    fanLoyalty?: boolean
    homeField?: boolean
    tacticalFocus?: boolean
    leagueId?: boolean
    division?: boolean
    subdivision?: boolean
    wins?: boolean
    losses?: boolean
    points?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    players?: boolean | Team$playersArgs<ExtArgs>
    staff?: boolean | Team$staffArgs<ExtArgs>
    finances?: boolean | Team$financesArgs<ExtArgs>
    stadium?: boolean | Team$stadiumArgs<ExtArgs>
    inventoryItems?: boolean | Team$inventoryItemsArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
    activeBoosts?: boolean | Team$activeBoostsArgs<ExtArgs>
    strategy?: boolean | Team$strategyArgs<ExtArgs>
    marketplaceListings?: boolean | Team$marketplaceListingsArgs<ExtArgs>
    bids?: boolean | Team$bidsArgs<ExtArgs>
    highBidderOnListings?: boolean | Team$highBidderOnListingsArgs<ExtArgs>
    listingHistory?: boolean | Team$listingHistoryArgs<ExtArgs>
    notifications?: boolean | Team$notificationsArgs<ExtArgs>
    tournamentEntries?: boolean | Team$tournamentEntriesArgs<ExtArgs>
    tryoutHistory?: boolean | Team$tryoutHistoryArgs<ExtArgs>
    homeTeamGames?: boolean | Team$homeTeamGamesArgs<ExtArgs>
    awayTeamGames?: boolean | Team$awayTeamGamesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    name?: boolean
    logoUrl?: boolean
    isAI?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    camaraderie?: boolean
    fanLoyalty?: boolean
    homeField?: boolean
    tacticalFocus?: boolean
    leagueId?: boolean
    division?: boolean
    subdivision?: boolean
    wins?: boolean
    losses?: boolean
    points?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    name?: boolean
    logoUrl?: boolean
    isAI?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    camaraderie?: boolean
    fanLoyalty?: boolean
    homeField?: boolean
    tacticalFocus?: boolean
    leagueId?: boolean
    division?: boolean
    subdivision?: boolean
    wins?: boolean
    losses?: boolean
    points?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    name?: boolean
    logoUrl?: boolean
    isAI?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    camaraderie?: boolean
    fanLoyalty?: boolean
    homeField?: boolean
    tacticalFocus?: boolean
    leagueId?: boolean
    division?: boolean
    subdivision?: boolean
    wins?: boolean
    losses?: boolean
    points?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "name" | "logoUrl" | "isAI" | "createdAt" | "updatedAt" | "camaraderie" | "fanLoyalty" | "homeField" | "tacticalFocus" | "leagueId" | "division" | "subdivision" | "wins" | "losses" | "points", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    players?: boolean | Team$playersArgs<ExtArgs>
    staff?: boolean | Team$staffArgs<ExtArgs>
    finances?: boolean | Team$financesArgs<ExtArgs>
    stadium?: boolean | Team$stadiumArgs<ExtArgs>
    inventoryItems?: boolean | Team$inventoryItemsArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
    activeBoosts?: boolean | Team$activeBoostsArgs<ExtArgs>
    strategy?: boolean | Team$strategyArgs<ExtArgs>
    marketplaceListings?: boolean | Team$marketplaceListingsArgs<ExtArgs>
    bids?: boolean | Team$bidsArgs<ExtArgs>
    highBidderOnListings?: boolean | Team$highBidderOnListingsArgs<ExtArgs>
    listingHistory?: boolean | Team$listingHistoryArgs<ExtArgs>
    notifications?: boolean | Team$notificationsArgs<ExtArgs>
    tournamentEntries?: boolean | Team$tournamentEntriesArgs<ExtArgs>
    tryoutHistory?: boolean | Team$tryoutHistoryArgs<ExtArgs>
    homeTeamGames?: boolean | Team$homeTeamGamesArgs<ExtArgs>
    awayTeamGames?: boolean | Team$awayTeamGamesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    league?: boolean | Team$leagueArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      players: Prisma.$PlayerPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs>[]
      finances: Prisma.$TeamFinancesPayload<ExtArgs> | null
      stadium: Prisma.$StadiumPayload<ExtArgs> | null
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      league: Prisma.$LeaguePayload<ExtArgs> | null
      activeBoosts: Prisma.$ActiveBoostPayload<ExtArgs>[]
      strategy: Prisma.$StrategyPayload<ExtArgs> | null
      marketplaceListings: Prisma.$MarketplaceListingPayload<ExtArgs>[]
      bids: Prisma.$BidPayload<ExtArgs>[]
      highBidderOnListings: Prisma.$MarketplaceListingPayload<ExtArgs>[]
      listingHistory: Prisma.$ListingHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      tournamentEntries: Prisma.$TournamentEntryPayload<ExtArgs>[]
      tryoutHistory: Prisma.$TryoutHistoryPayload<ExtArgs>[]
      homeTeamGames: Prisma.$GamePayload<ExtArgs>[]
      awayTeamGames: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userProfileId: number
      name: string
      logoUrl: string | null
      isAI: boolean
      createdAt: Date
      updatedAt: Date
      camaraderie: number
      fanLoyalty: number
      homeField: $Enums.FieldSize
      tacticalFocus: $Enums.TacticalFocus
      leagueId: number | null
      division: number | null
      subdivision: string | null
      wins: number
      losses: number
      points: number
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    players<T extends Team$playersArgs<ExtArgs> = {}>(args?: Subset<T, Team$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Team$staffArgs<ExtArgs> = {}>(args?: Subset<T, Team$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finances<T extends Team$financesArgs<ExtArgs> = {}>(args?: Subset<T, Team$financesArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stadium<T extends Team$stadiumArgs<ExtArgs> = {}>(args?: Subset<T, Team$stadiumArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventoryItems<T extends Team$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Team$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    league<T extends Team$leagueArgs<ExtArgs> = {}>(args?: Subset<T, Team$leagueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activeBoosts<T extends Team$activeBoostsArgs<ExtArgs> = {}>(args?: Subset<T, Team$activeBoostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    strategy<T extends Team$strategyArgs<ExtArgs> = {}>(args?: Subset<T, Team$strategyArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    marketplaceListings<T extends Team$marketplaceListingsArgs<ExtArgs> = {}>(args?: Subset<T, Team$marketplaceListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bids<T extends Team$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Team$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    highBidderOnListings<T extends Team$highBidderOnListingsArgs<ExtArgs> = {}>(args?: Subset<T, Team$highBidderOnListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listingHistory<T extends Team$listingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Team$listingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Team$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentEntries<T extends Team$tournamentEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Team$tournamentEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tryoutHistory<T extends Team$tryoutHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Team$tryoutHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeTeamGames<T extends Team$homeTeamGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$homeTeamGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awayTeamGames<T extends Team$awayTeamGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$awayTeamGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly userProfileId: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly isAI: FieldRef<"Team", 'Boolean'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly camaraderie: FieldRef<"Team", 'Float'>
    readonly fanLoyalty: FieldRef<"Team", 'Float'>
    readonly homeField: FieldRef<"Team", 'FieldSize'>
    readonly tacticalFocus: FieldRef<"Team", 'TacticalFocus'>
    readonly leagueId: FieldRef<"Team", 'Int'>
    readonly division: FieldRef<"Team", 'Int'>
    readonly subdivision: FieldRef<"Team", 'String'>
    readonly wins: FieldRef<"Team", 'Int'>
    readonly losses: FieldRef<"Team", 'Int'>
    readonly points: FieldRef<"Team", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.players
   */
  export type Team$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team.staff
   */
  export type Team$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Team.finances
   */
  export type Team$financesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    where?: TeamFinancesWhereInput
  }

  /**
   * Team.stadium
   */
  export type Team$stadiumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    where?: StadiumWhereInput
  }

  /**
   * Team.inventoryItems
   */
  export type Team$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Team.league
   */
  export type Team$leagueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
  }

  /**
   * Team.activeBoosts
   */
  export type Team$activeBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    where?: ActiveBoostWhereInput
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    cursor?: ActiveBoostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * Team.strategy
   */
  export type Team$strategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    where?: StrategyWhereInput
  }

  /**
   * Team.marketplaceListings
   */
  export type Team$marketplaceListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    cursor?: MarketplaceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * Team.bids
   */
  export type Team$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Team.highBidderOnListings
   */
  export type Team$highBidderOnListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    cursor?: MarketplaceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * Team.listingHistory
   */
  export type Team$listingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    where?: ListingHistoryWhereInput
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    cursor?: ListingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingHistoryScalarFieldEnum | ListingHistoryScalarFieldEnum[]
  }

  /**
   * Team.notifications
   */
  export type Team$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Team.tournamentEntries
   */
  export type Team$tournamentEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    where?: TournamentEntryWhereInput
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    cursor?: TournamentEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentEntryScalarFieldEnum | TournamentEntryScalarFieldEnum[]
  }

  /**
   * Team.tryoutHistory
   */
  export type Team$tryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    where?: TryoutHistoryWhereInput
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    cursor?: TryoutHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * Team.homeTeamGames
   */
  export type Team$homeTeamGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team.awayTeamGames
   */
  export type Team$awayTeamGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    age: number | null
    speed: number | null
    power: number | null
    throwing: number | null
    catching: number | null
    kicking: number | null
    staminaAttribute: number | null
    leadership: number | null
    agility: number | null
    potentialRating: number | null
    dailyStaminaLevel: number | null
    injuryRecoveryPointsNeeded: number | null
    injuryRecoveryPointsCurrent: number | null
    dailyItemsUsed: number | null
    careerInjuries: number | null
    gamesPlayedLastSeason: number | null
    seasonMinutesLeague: number | null
    seasonMinutesTournament: number | null
    seasonMinutesExhibition: number | null
    seasonMinutesTotal: number | null
    camaraderieScore: number | null
  }

  export type PlayerSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    age: number | null
    speed: number | null
    power: number | null
    throwing: number | null
    catching: number | null
    kicking: number | null
    staminaAttribute: number | null
    leadership: number | null
    agility: number | null
    potentialRating: number | null
    dailyStaminaLevel: number | null
    injuryRecoveryPointsNeeded: number | null
    injuryRecoveryPointsCurrent: number | null
    dailyItemsUsed: number | null
    careerInjuries: number | null
    gamesPlayedLastSeason: number | null
    seasonMinutesLeague: number | null
    seasonMinutesTournament: number | null
    seasonMinutesExhibition: number | null
    seasonMinutesTotal: number | null
    camaraderieScore: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    firstName: string | null
    lastName: string | null
    race: $Enums.Race | null
    age: number | null
    role: $Enums.PlayerRole | null
    speed: number | null
    power: number | null
    throwing: number | null
    catching: number | null
    kicking: number | null
    staminaAttribute: number | null
    leadership: number | null
    agility: number | null
    potentialRating: number | null
    dailyStaminaLevel: number | null
    injuryStatus: $Enums.InjuryStatus | null
    injuryRecoveryPointsNeeded: number | null
    injuryRecoveryPointsCurrent: number | null
    dailyItemsUsed: number | null
    careerInjuries: number | null
    gamesPlayedLastSeason: number | null
    seasonMinutesLeague: number | null
    seasonMinutesTournament: number | null
    seasonMinutesExhibition: number | null
    seasonMinutesTotal: number | null
    isOnMarket: boolean | null
    isRetired: boolean | null
    camaraderieScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    firstName: string | null
    lastName: string | null
    race: $Enums.Race | null
    age: number | null
    role: $Enums.PlayerRole | null
    speed: number | null
    power: number | null
    throwing: number | null
    catching: number | null
    kicking: number | null
    staminaAttribute: number | null
    leadership: number | null
    agility: number | null
    potentialRating: number | null
    dailyStaminaLevel: number | null
    injuryStatus: $Enums.InjuryStatus | null
    injuryRecoveryPointsNeeded: number | null
    injuryRecoveryPointsCurrent: number | null
    dailyItemsUsed: number | null
    careerInjuries: number | null
    gamesPlayedLastSeason: number | null
    seasonMinutesLeague: number | null
    seasonMinutesTournament: number | null
    seasonMinutesExhibition: number | null
    seasonMinutesTotal: number | null
    isOnMarket: boolean | null
    isRetired: boolean | null
    camaraderieScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    teamId: number
    firstName: number
    lastName: number
    race: number
    age: number
    role: number
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel: number
    injuryStatus: number
    injuryRecoveryPointsNeeded: number
    injuryRecoveryPointsCurrent: number
    dailyItemsUsed: number
    careerInjuries: number
    gamesPlayedLastSeason: number
    seasonMinutesLeague: number
    seasonMinutesTournament: number
    seasonMinutesExhibition: number
    seasonMinutesTotal: number
    isOnMarket: number
    isRetired: number
    camaraderieScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    id?: true
    teamId?: true
    age?: true
    speed?: true
    power?: true
    throwing?: true
    catching?: true
    kicking?: true
    staminaAttribute?: true
    leadership?: true
    agility?: true
    potentialRating?: true
    dailyStaminaLevel?: true
    injuryRecoveryPointsNeeded?: true
    injuryRecoveryPointsCurrent?: true
    dailyItemsUsed?: true
    careerInjuries?: true
    gamesPlayedLastSeason?: true
    seasonMinutesLeague?: true
    seasonMinutesTournament?: true
    seasonMinutesExhibition?: true
    seasonMinutesTotal?: true
    camaraderieScore?: true
  }

  export type PlayerSumAggregateInputType = {
    id?: true
    teamId?: true
    age?: true
    speed?: true
    power?: true
    throwing?: true
    catching?: true
    kicking?: true
    staminaAttribute?: true
    leadership?: true
    agility?: true
    potentialRating?: true
    dailyStaminaLevel?: true
    injuryRecoveryPointsNeeded?: true
    injuryRecoveryPointsCurrent?: true
    dailyItemsUsed?: true
    careerInjuries?: true
    gamesPlayedLastSeason?: true
    seasonMinutesLeague?: true
    seasonMinutesTournament?: true
    seasonMinutesExhibition?: true
    seasonMinutesTotal?: true
    camaraderieScore?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    teamId?: true
    firstName?: true
    lastName?: true
    race?: true
    age?: true
    role?: true
    speed?: true
    power?: true
    throwing?: true
    catching?: true
    kicking?: true
    staminaAttribute?: true
    leadership?: true
    agility?: true
    potentialRating?: true
    dailyStaminaLevel?: true
    injuryStatus?: true
    injuryRecoveryPointsNeeded?: true
    injuryRecoveryPointsCurrent?: true
    dailyItemsUsed?: true
    careerInjuries?: true
    gamesPlayedLastSeason?: true
    seasonMinutesLeague?: true
    seasonMinutesTournament?: true
    seasonMinutesExhibition?: true
    seasonMinutesTotal?: true
    isOnMarket?: true
    isRetired?: true
    camaraderieScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    teamId?: true
    firstName?: true
    lastName?: true
    race?: true
    age?: true
    role?: true
    speed?: true
    power?: true
    throwing?: true
    catching?: true
    kicking?: true
    staminaAttribute?: true
    leadership?: true
    agility?: true
    potentialRating?: true
    dailyStaminaLevel?: true
    injuryStatus?: true
    injuryRecoveryPointsNeeded?: true
    injuryRecoveryPointsCurrent?: true
    dailyItemsUsed?: true
    careerInjuries?: true
    gamesPlayedLastSeason?: true
    seasonMinutesLeague?: true
    seasonMinutesTournament?: true
    seasonMinutesExhibition?: true
    seasonMinutesTotal?: true
    isOnMarket?: true
    isRetired?: true
    camaraderieScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    teamId?: true
    firstName?: true
    lastName?: true
    race?: true
    age?: true
    role?: true
    speed?: true
    power?: true
    throwing?: true
    catching?: true
    kicking?: true
    staminaAttribute?: true
    leadership?: true
    agility?: true
    potentialRating?: true
    dailyStaminaLevel?: true
    injuryStatus?: true
    injuryRecoveryPointsNeeded?: true
    injuryRecoveryPointsCurrent?: true
    dailyItemsUsed?: true
    careerInjuries?: true
    gamesPlayedLastSeason?: true
    seasonMinutesLeague?: true
    seasonMinutesTournament?: true
    seasonMinutesExhibition?: true
    seasonMinutesTotal?: true
    isOnMarket?: true
    isRetired?: true
    camaraderieScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel: number
    injuryStatus: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded: number
    injuryRecoveryPointsCurrent: number
    dailyItemsUsed: number
    careerInjuries: number
    gamesPlayedLastSeason: number
    seasonMinutesLeague: number
    seasonMinutesTournament: number
    seasonMinutesExhibition: number
    seasonMinutesTotal: number
    isOnMarket: boolean
    isRetired: boolean
    camaraderieScore: number
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    firstName?: boolean
    lastName?: boolean
    race?: boolean
    age?: boolean
    role?: boolean
    speed?: boolean
    power?: boolean
    throwing?: boolean
    catching?: boolean
    kicking?: boolean
    staminaAttribute?: boolean
    leadership?: boolean
    agility?: boolean
    potentialRating?: boolean
    dailyStaminaLevel?: boolean
    injuryStatus?: boolean
    injuryRecoveryPointsNeeded?: boolean
    injuryRecoveryPointsCurrent?: boolean
    dailyItemsUsed?: boolean
    careerInjuries?: boolean
    gamesPlayedLastSeason?: boolean
    seasonMinutesLeague?: boolean
    seasonMinutesTournament?: boolean
    seasonMinutesExhibition?: boolean
    seasonMinutesTotal?: boolean
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contract?: boolean | Player$contractArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    MarketplaceListing?: boolean | Player$MarketplaceListingArgs<ExtArgs>
    marketValue?: boolean | Player$marketValueArgs<ExtArgs>
    tryoutHistory?: boolean | Player$tryoutHistoryArgs<ExtArgs>
    activeBoosts?: boolean | Player$activeBoostsArgs<ExtArgs>
    currentEquipment?: boolean | Player$currentEquipmentArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    firstName?: boolean
    lastName?: boolean
    race?: boolean
    age?: boolean
    role?: boolean
    speed?: boolean
    power?: boolean
    throwing?: boolean
    catching?: boolean
    kicking?: boolean
    staminaAttribute?: boolean
    leadership?: boolean
    agility?: boolean
    potentialRating?: boolean
    dailyStaminaLevel?: boolean
    injuryStatus?: boolean
    injuryRecoveryPointsNeeded?: boolean
    injuryRecoveryPointsCurrent?: boolean
    dailyItemsUsed?: boolean
    careerInjuries?: boolean
    gamesPlayedLastSeason?: boolean
    seasonMinutesLeague?: boolean
    seasonMinutesTournament?: boolean
    seasonMinutesExhibition?: boolean
    seasonMinutesTotal?: boolean
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    firstName?: boolean
    lastName?: boolean
    race?: boolean
    age?: boolean
    role?: boolean
    speed?: boolean
    power?: boolean
    throwing?: boolean
    catching?: boolean
    kicking?: boolean
    staminaAttribute?: boolean
    leadership?: boolean
    agility?: boolean
    potentialRating?: boolean
    dailyStaminaLevel?: boolean
    injuryStatus?: boolean
    injuryRecoveryPointsNeeded?: boolean
    injuryRecoveryPointsCurrent?: boolean
    dailyItemsUsed?: boolean
    careerInjuries?: boolean
    gamesPlayedLastSeason?: boolean
    seasonMinutesLeague?: boolean
    seasonMinutesTournament?: boolean
    seasonMinutesExhibition?: boolean
    seasonMinutesTotal?: boolean
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    teamId?: boolean
    firstName?: boolean
    lastName?: boolean
    race?: boolean
    age?: boolean
    role?: boolean
    speed?: boolean
    power?: boolean
    throwing?: boolean
    catching?: boolean
    kicking?: boolean
    staminaAttribute?: boolean
    leadership?: boolean
    agility?: boolean
    potentialRating?: boolean
    dailyStaminaLevel?: boolean
    injuryStatus?: boolean
    injuryRecoveryPointsNeeded?: boolean
    injuryRecoveryPointsCurrent?: boolean
    dailyItemsUsed?: boolean
    careerInjuries?: boolean
    gamesPlayedLastSeason?: boolean
    seasonMinutesLeague?: boolean
    seasonMinutesTournament?: boolean
    seasonMinutesExhibition?: boolean
    seasonMinutesTotal?: boolean
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "firstName" | "lastName" | "race" | "age" | "role" | "speed" | "power" | "throwing" | "catching" | "kicking" | "staminaAttribute" | "leadership" | "agility" | "potentialRating" | "dailyStaminaLevel" | "injuryStatus" | "injuryRecoveryPointsNeeded" | "injuryRecoveryPointsCurrent" | "dailyItemsUsed" | "careerInjuries" | "gamesPlayedLastSeason" | "seasonMinutesLeague" | "seasonMinutesTournament" | "seasonMinutesExhibition" | "seasonMinutesTotal" | "isOnMarket" | "isRetired" | "camaraderieScore" | "createdAt" | "updatedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contract?: boolean | Player$contractArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    MarketplaceListing?: boolean | Player$MarketplaceListingArgs<ExtArgs>
    marketValue?: boolean | Player$marketValueArgs<ExtArgs>
    tryoutHistory?: boolean | Player$tryoutHistoryArgs<ExtArgs>
    activeBoosts?: boolean | Player$activeBoostsArgs<ExtArgs>
    currentEquipment?: boolean | Player$currentEquipmentArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs> | null
      skills: Prisma.$PlayerSkillLinkPayload<ExtArgs>[]
      MarketplaceListing: Prisma.$MarketplaceListingPayload<ExtArgs> | null
      marketValue: Prisma.$PlayerMarketValuePayload<ExtArgs> | null
      tryoutHistory: Prisma.$TryoutHistoryPayload<ExtArgs>[]
      activeBoosts: Prisma.$ActiveBoostPayload<ExtArgs>[]
      currentEquipment: Prisma.$PlayerEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      firstName: string
      lastName: string
      race: $Enums.Race
      age: number
      role: $Enums.PlayerRole
      speed: number
      power: number
      throwing: number
      catching: number
      kicking: number
      staminaAttribute: number
      leadership: number
      agility: number
      potentialRating: number
      dailyStaminaLevel: number
      injuryStatus: $Enums.InjuryStatus
      injuryRecoveryPointsNeeded: number
      injuryRecoveryPointsCurrent: number
      dailyItemsUsed: number
      careerInjuries: number
      gamesPlayedLastSeason: number
      seasonMinutesLeague: number
      seasonMinutesTournament: number
      seasonMinutesExhibition: number
      seasonMinutesTotal: number
      isOnMarket: boolean
      isRetired: boolean
      camaraderieScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contract<T extends Player$contractArgs<ExtArgs> = {}>(args?: Subset<T, Player$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    skills<T extends Player$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Player$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MarketplaceListing<T extends Player$MarketplaceListingArgs<ExtArgs> = {}>(args?: Subset<T, Player$MarketplaceListingArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    marketValue<T extends Player$marketValueArgs<ExtArgs> = {}>(args?: Subset<T, Player$marketValueArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tryoutHistory<T extends Player$tryoutHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$tryoutHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activeBoosts<T extends Player$activeBoostsArgs<ExtArgs> = {}>(args?: Subset<T, Player$activeBoostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentEquipment<T extends Player$currentEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Player$currentEquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'Int'>
    readonly teamId: FieldRef<"Player", 'Int'>
    readonly firstName: FieldRef<"Player", 'String'>
    readonly lastName: FieldRef<"Player", 'String'>
    readonly race: FieldRef<"Player", 'Race'>
    readonly age: FieldRef<"Player", 'Int'>
    readonly role: FieldRef<"Player", 'PlayerRole'>
    readonly speed: FieldRef<"Player", 'Int'>
    readonly power: FieldRef<"Player", 'Int'>
    readonly throwing: FieldRef<"Player", 'Int'>
    readonly catching: FieldRef<"Player", 'Int'>
    readonly kicking: FieldRef<"Player", 'Int'>
    readonly staminaAttribute: FieldRef<"Player", 'Int'>
    readonly leadership: FieldRef<"Player", 'Int'>
    readonly agility: FieldRef<"Player", 'Int'>
    readonly potentialRating: FieldRef<"Player", 'Float'>
    readonly dailyStaminaLevel: FieldRef<"Player", 'Int'>
    readonly injuryStatus: FieldRef<"Player", 'InjuryStatus'>
    readonly injuryRecoveryPointsNeeded: FieldRef<"Player", 'Int'>
    readonly injuryRecoveryPointsCurrent: FieldRef<"Player", 'Int'>
    readonly dailyItemsUsed: FieldRef<"Player", 'Int'>
    readonly careerInjuries: FieldRef<"Player", 'Int'>
    readonly gamesPlayedLastSeason: FieldRef<"Player", 'Int'>
    readonly seasonMinutesLeague: FieldRef<"Player", 'Float'>
    readonly seasonMinutesTournament: FieldRef<"Player", 'Float'>
    readonly seasonMinutesExhibition: FieldRef<"Player", 'Float'>
    readonly seasonMinutesTotal: FieldRef<"Player", 'Float'>
    readonly isOnMarket: FieldRef<"Player", 'Boolean'>
    readonly isRetired: FieldRef<"Player", 'Boolean'>
    readonly camaraderieScore: FieldRef<"Player", 'Float'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.contract
   */
  export type Player$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Player.skills
   */
  export type Player$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    where?: PlayerSkillLinkWhereInput
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    cursor?: PlayerSkillLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerSkillLinkScalarFieldEnum | PlayerSkillLinkScalarFieldEnum[]
  }

  /**
   * Player.MarketplaceListing
   */
  export type Player$MarketplaceListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
  }

  /**
   * Player.marketValue
   */
  export type Player$marketValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    where?: PlayerMarketValueWhereInput
  }

  /**
   * Player.tryoutHistory
   */
  export type Player$tryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    where?: TryoutHistoryWhereInput
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    cursor?: TryoutHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * Player.activeBoosts
   */
  export type Player$activeBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    where?: ActiveBoostWhereInput
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    cursor?: ActiveBoostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * Player.currentEquipment
   */
  export type Player$currentEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    cursor?: PlayerEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model PlayerEquipment
   */

  export type AggregatePlayerEquipment = {
    _count: PlayerEquipmentCountAggregateOutputType | null
    _avg: PlayerEquipmentAvgAggregateOutputType | null
    _sum: PlayerEquipmentSumAggregateOutputType | null
    _min: PlayerEquipmentMinAggregateOutputType | null
    _max: PlayerEquipmentMaxAggregateOutputType | null
  }

  export type PlayerEquipmentAvgAggregateOutputType = {
    id: number | null
    playerId: number | null
    itemId: number | null
  }

  export type PlayerEquipmentSumAggregateOutputType = {
    id: number | null
    playerId: number | null
    itemId: number | null
  }

  export type PlayerEquipmentMinAggregateOutputType = {
    id: number | null
    playerId: number | null
    itemId: number | null
    equippedAt: Date | null
  }

  export type PlayerEquipmentMaxAggregateOutputType = {
    id: number | null
    playerId: number | null
    itemId: number | null
    equippedAt: Date | null
  }

  export type PlayerEquipmentCountAggregateOutputType = {
    id: number
    playerId: number
    itemId: number
    equippedAt: number
    _all: number
  }


  export type PlayerEquipmentAvgAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
  }

  export type PlayerEquipmentSumAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
  }

  export type PlayerEquipmentMinAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    equippedAt?: true
  }

  export type PlayerEquipmentMaxAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    equippedAt?: true
  }

  export type PlayerEquipmentCountAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    equippedAt?: true
    _all?: true
  }

  export type PlayerEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEquipment to aggregate.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerEquipments
    **/
    _count?: true | PlayerEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerEquipmentMaxAggregateInputType
  }

  export type GetPlayerEquipmentAggregateType<T extends PlayerEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerEquipment[P]>
      : GetScalarType<T[P], AggregatePlayerEquipment[P]>
  }




  export type PlayerEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithAggregationInput | PlayerEquipmentOrderByWithAggregationInput[]
    by: PlayerEquipmentScalarFieldEnum[] | PlayerEquipmentScalarFieldEnum
    having?: PlayerEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerEquipmentCountAggregateInputType | true
    _avg?: PlayerEquipmentAvgAggregateInputType
    _sum?: PlayerEquipmentSumAggregateInputType
    _min?: PlayerEquipmentMinAggregateInputType
    _max?: PlayerEquipmentMaxAggregateInputType
  }

  export type PlayerEquipmentGroupByOutputType = {
    id: number
    playerId: number
    itemId: number
    equippedAt: Date
    _count: PlayerEquipmentCountAggregateOutputType | null
    _avg: PlayerEquipmentAvgAggregateOutputType | null
    _sum: PlayerEquipmentSumAggregateOutputType | null
    _min: PlayerEquipmentMinAggregateOutputType | null
    _max: PlayerEquipmentMaxAggregateOutputType | null
  }

  type GetPlayerEquipmentGroupByPayload<T extends PlayerEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type PlayerEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    equippedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEquipment"]>

  export type PlayerEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    equippedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEquipment"]>

  export type PlayerEquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    equippedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEquipment"]>

  export type PlayerEquipmentSelectScalar = {
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    equippedAt?: boolean
  }

  export type PlayerEquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "itemId" | "equippedAt", ExtArgs["result"]["playerEquipment"]>
  export type PlayerEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PlayerEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PlayerEquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PlayerEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerEquipment"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      playerId: number
      itemId: number
      equippedAt: Date
    }, ExtArgs["result"]["playerEquipment"]>
    composites: {}
  }

  type PlayerEquipmentGetPayload<S extends boolean | null | undefined | PlayerEquipmentDefaultArgs> = $Result.GetResult<Prisma.$PlayerEquipmentPayload, S>

  type PlayerEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerEquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerEquipmentCountAggregateInputType | true
    }

  export interface PlayerEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerEquipment'], meta: { name: 'PlayerEquipment' } }
    /**
     * Find zero or one PlayerEquipment that matches the filter.
     * @param {PlayerEquipmentFindUniqueArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerEquipmentFindUniqueArgs>(args: SelectSubset<T, PlayerEquipmentFindUniqueArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerEquipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerEquipmentFindUniqueOrThrowArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindFirstArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerEquipmentFindFirstArgs>(args?: SelectSubset<T, PlayerEquipmentFindFirstArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindFirstOrThrowArgs} args - Arguments to find a PlayerEquipment
     * @example
     * // Get one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerEquipments
     * const playerEquipments = await prisma.playerEquipment.findMany()
     * 
     * // Get first 10 PlayerEquipments
     * const playerEquipments = await prisma.playerEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerEquipmentWithIdOnly = await prisma.playerEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerEquipmentFindManyArgs>(args?: SelectSubset<T, PlayerEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerEquipment.
     * @param {PlayerEquipmentCreateArgs} args - Arguments to create a PlayerEquipment.
     * @example
     * // Create one PlayerEquipment
     * const PlayerEquipment = await prisma.playerEquipment.create({
     *   data: {
     *     // ... data to create a PlayerEquipment
     *   }
     * })
     * 
     */
    create<T extends PlayerEquipmentCreateArgs>(args: SelectSubset<T, PlayerEquipmentCreateArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerEquipments.
     * @param {PlayerEquipmentCreateManyArgs} args - Arguments to create many PlayerEquipments.
     * @example
     * // Create many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerEquipmentCreateManyArgs>(args?: SelectSubset<T, PlayerEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerEquipments and returns the data saved in the database.
     * @param {PlayerEquipmentCreateManyAndReturnArgs} args - Arguments to create many PlayerEquipments.
     * @example
     * // Create many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerEquipments and only return the `id`
     * const playerEquipmentWithIdOnly = await prisma.playerEquipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerEquipment.
     * @param {PlayerEquipmentDeleteArgs} args - Arguments to delete one PlayerEquipment.
     * @example
     * // Delete one PlayerEquipment
     * const PlayerEquipment = await prisma.playerEquipment.delete({
     *   where: {
     *     // ... filter to delete one PlayerEquipment
     *   }
     * })
     * 
     */
    delete<T extends PlayerEquipmentDeleteArgs>(args: SelectSubset<T, PlayerEquipmentDeleteArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerEquipment.
     * @param {PlayerEquipmentUpdateArgs} args - Arguments to update one PlayerEquipment.
     * @example
     * // Update one PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerEquipmentUpdateArgs>(args: SelectSubset<T, PlayerEquipmentUpdateArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerEquipments.
     * @param {PlayerEquipmentDeleteManyArgs} args - Arguments to filter PlayerEquipments to delete.
     * @example
     * // Delete a few PlayerEquipments
     * const { count } = await prisma.playerEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerEquipmentDeleteManyArgs>(args?: SelectSubset<T, PlayerEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerEquipmentUpdateManyArgs>(args: SelectSubset<T, PlayerEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerEquipments and returns the data updated in the database.
     * @param {PlayerEquipmentUpdateManyAndReturnArgs} args - Arguments to update many PlayerEquipments.
     * @example
     * // Update many PlayerEquipments
     * const playerEquipment = await prisma.playerEquipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerEquipments and only return the `id`
     * const playerEquipmentWithIdOnly = await prisma.playerEquipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerEquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerEquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerEquipment.
     * @param {PlayerEquipmentUpsertArgs} args - Arguments to update or create a PlayerEquipment.
     * @example
     * // Update or create a PlayerEquipment
     * const playerEquipment = await prisma.playerEquipment.upsert({
     *   create: {
     *     // ... data to create a PlayerEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerEquipment we want to update
     *   }
     * })
     */
    upsert<T extends PlayerEquipmentUpsertArgs>(args: SelectSubset<T, PlayerEquipmentUpsertArgs<ExtArgs>>): Prisma__PlayerEquipmentClient<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentCountArgs} args - Arguments to filter PlayerEquipments to count.
     * @example
     * // Count the number of PlayerEquipments
     * const count = await prisma.playerEquipment.count({
     *   where: {
     *     // ... the filter for the PlayerEquipments we want to count
     *   }
     * })
    **/
    count<T extends PlayerEquipmentCountArgs>(
      args?: Subset<T, PlayerEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerEquipmentAggregateArgs>(args: Subset<T, PlayerEquipmentAggregateArgs>): Prisma.PrismaPromise<GetPlayerEquipmentAggregateType<T>>

    /**
     * Group by PlayerEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: PlayerEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerEquipment model
   */
  readonly fields: PlayerEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerEquipment model
   */
  interface PlayerEquipmentFieldRefs {
    readonly id: FieldRef<"PlayerEquipment", 'Int'>
    readonly playerId: FieldRef<"PlayerEquipment", 'Int'>
    readonly itemId: FieldRef<"PlayerEquipment", 'Int'>
    readonly equippedAt: FieldRef<"PlayerEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerEquipment findUnique
   */
  export type PlayerEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment findUniqueOrThrow
   */
  export type PlayerEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment findFirst
   */
  export type PlayerEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEquipments.
     */
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment findFirstOrThrow
   */
  export type PlayerEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipment to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEquipments.
     */
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment findMany
   */
  export type PlayerEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEquipments to fetch.
     */
    where?: PlayerEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEquipments to fetch.
     */
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerEquipments.
     */
    cursor?: PlayerEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEquipments.
     */
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * PlayerEquipment create
   */
  export type PlayerEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerEquipment.
     */
    data: XOR<PlayerEquipmentCreateInput, PlayerEquipmentUncheckedCreateInput>
  }

  /**
   * PlayerEquipment createMany
   */
  export type PlayerEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerEquipments.
     */
    data: PlayerEquipmentCreateManyInput | PlayerEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerEquipment createManyAndReturn
   */
  export type PlayerEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerEquipments.
     */
    data: PlayerEquipmentCreateManyInput | PlayerEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerEquipment update
   */
  export type PlayerEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerEquipment.
     */
    data: XOR<PlayerEquipmentUpdateInput, PlayerEquipmentUncheckedUpdateInput>
    /**
     * Choose, which PlayerEquipment to update.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment updateMany
   */
  export type PlayerEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerEquipments.
     */
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which PlayerEquipments to update
     */
    where?: PlayerEquipmentWhereInput
    /**
     * Limit how many PlayerEquipments to update.
     */
    limit?: number
  }

  /**
   * PlayerEquipment updateManyAndReturn
   */
  export type PlayerEquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * The data used to update PlayerEquipments.
     */
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which PlayerEquipments to update
     */
    where?: PlayerEquipmentWhereInput
    /**
     * Limit how many PlayerEquipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerEquipment upsert
   */
  export type PlayerEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerEquipment to update in case it exists.
     */
    where: PlayerEquipmentWhereUniqueInput
    /**
     * In case the PlayerEquipment found by the `where` argument doesn't exist, create a new PlayerEquipment with this data.
     */
    create: XOR<PlayerEquipmentCreateInput, PlayerEquipmentUncheckedCreateInput>
    /**
     * In case the PlayerEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerEquipmentUpdateInput, PlayerEquipmentUncheckedUpdateInput>
  }

  /**
   * PlayerEquipment delete
   */
  export type PlayerEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    /**
     * Filter which PlayerEquipment to delete.
     */
    where: PlayerEquipmentWhereUniqueInput
  }

  /**
   * PlayerEquipment deleteMany
   */
  export type PlayerEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEquipments to delete
     */
    where?: PlayerEquipmentWhereInput
    /**
     * Limit how many PlayerEquipments to delete.
     */
    limit?: number
  }

  /**
   * PlayerEquipment without action
   */
  export type PlayerEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    playerId: number | null
    staffId: number | null
    salary: number | null
    length: number | null
    signingBonus: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    playerId: number | null
    staffId: number | null
    salary: number | null
    length: number | null
    signingBonus: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    playerId: number | null
    staffId: number | null
    salary: number | null
    length: number | null
    signingBonus: number | null
    startDate: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    playerId: number | null
    staffId: number | null
    salary: number | null
    length: number | null
    signingBonus: number | null
    startDate: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    playerId: number
    staffId: number
    salary: number
    length: number
    signingBonus: number
    startDate: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    playerId?: true
    staffId?: true
    salary?: true
    length?: true
    signingBonus?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    playerId?: true
    staffId?: true
    salary?: true
    length?: true
    signingBonus?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    playerId?: true
    staffId?: true
    salary?: true
    length?: true
    signingBonus?: true
    startDate?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    playerId?: true
    staffId?: true
    salary?: true
    length?: true
    signingBonus?: true
    startDate?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    playerId?: true
    staffId?: true
    salary?: true
    length?: true
    signingBonus?: true
    startDate?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    playerId: number | null
    staffId: number | null
    salary: number
    length: number
    signingBonus: number
    startDate: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    staffId?: boolean
    salary?: boolean
    length?: boolean
    signingBonus?: boolean
    startDate?: boolean
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    staffId?: boolean
    salary?: boolean
    length?: boolean
    signingBonus?: boolean
    startDate?: boolean
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    staffId?: boolean
    salary?: boolean
    length?: boolean
    signingBonus?: boolean
    startDate?: boolean
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    playerId?: boolean
    staffId?: boolean
    salary?: boolean
    length?: boolean
    signingBonus?: boolean
    startDate?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "staffId" | "salary" | "length" | "signingBonus" | "startDate", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | Contract$playerArgs<ExtArgs>
    staff?: boolean | Contract$staffArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      playerId: number | null
      staffId: number | null
      salary: number
      length: number
      signingBonus: number
      startDate: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends Contract$playerArgs<ExtArgs> = {}>(args?: Subset<T, Contract$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends Contract$staffArgs<ExtArgs> = {}>(args?: Subset<T, Contract$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly playerId: FieldRef<"Contract", 'Int'>
    readonly staffId: FieldRef<"Contract", 'Int'>
    readonly salary: FieldRef<"Contract", 'Int'>
    readonly length: FieldRef<"Contract", 'Int'>
    readonly signingBonus: FieldRef<"Contract", 'Int'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract.player
   */
  export type Contract$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * Contract.staff
   */
  export type Contract$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.SkillType | null
    category: $Enums.SkillCategory | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.SkillType | null
    category: $Enums.SkillCategory | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    category: number
    tiers: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    tiers?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonValue
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    tiers?: boolean
    playerLinks?: boolean | Skill$playerLinksArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    tiers?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    tiers?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    tiers?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "category" | "tiers", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerLinks?: boolean | Skill$playerLinksArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      playerLinks: Prisma.$PlayerSkillLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      type: $Enums.SkillType
      category: $Enums.SkillCategory
      tiers: Prisma.JsonValue
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerLinks<T extends Skill$playerLinksArgs<ExtArgs> = {}>(args?: Subset<T, Skill$playerLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly type: FieldRef<"Skill", 'SkillType'>
    readonly category: FieldRef<"Skill", 'SkillCategory'>
    readonly tiers: FieldRef<"Skill", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.playerLinks
   */
  export type Skill$playerLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    where?: PlayerSkillLinkWhereInput
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    cursor?: PlayerSkillLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerSkillLinkScalarFieldEnum | PlayerSkillLinkScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model PlayerSkillLink
   */

  export type AggregatePlayerSkillLink = {
    _count: PlayerSkillLinkCountAggregateOutputType | null
    _avg: PlayerSkillLinkAvgAggregateOutputType | null
    _sum: PlayerSkillLinkSumAggregateOutputType | null
    _min: PlayerSkillLinkMinAggregateOutputType | null
    _max: PlayerSkillLinkMaxAggregateOutputType | null
  }

  export type PlayerSkillLinkAvgAggregateOutputType = {
    id: number | null
    playerId: number | null
    skillId: number | null
    currentTier: number | null
  }

  export type PlayerSkillLinkSumAggregateOutputType = {
    id: number | null
    playerId: number | null
    skillId: number | null
    currentTier: number | null
  }

  export type PlayerSkillLinkMinAggregateOutputType = {
    id: number | null
    playerId: number | null
    skillId: number | null
    currentTier: number | null
    acquiredAt: Date | null
  }

  export type PlayerSkillLinkMaxAggregateOutputType = {
    id: number | null
    playerId: number | null
    skillId: number | null
    currentTier: number | null
    acquiredAt: Date | null
  }

  export type PlayerSkillLinkCountAggregateOutputType = {
    id: number
    playerId: number
    skillId: number
    currentTier: number
    acquiredAt: number
    _all: number
  }


  export type PlayerSkillLinkAvgAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    currentTier?: true
  }

  export type PlayerSkillLinkSumAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    currentTier?: true
  }

  export type PlayerSkillLinkMinAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    currentTier?: true
    acquiredAt?: true
  }

  export type PlayerSkillLinkMaxAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    currentTier?: true
    acquiredAt?: true
  }

  export type PlayerSkillLinkCountAggregateInputType = {
    id?: true
    playerId?: true
    skillId?: true
    currentTier?: true
    acquiredAt?: true
    _all?: true
  }

  export type PlayerSkillLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkillLink to aggregate.
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLinks to fetch.
     */
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerSkillLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerSkillLinks
    **/
    _count?: true | PlayerSkillLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerSkillLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSkillLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerSkillLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerSkillLinkMaxAggregateInputType
  }

  export type GetPlayerSkillLinkAggregateType<T extends PlayerSkillLinkAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerSkillLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerSkillLink[P]>
      : GetScalarType<T[P], AggregatePlayerSkillLink[P]>
  }




  export type PlayerSkillLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillLinkWhereInput
    orderBy?: PlayerSkillLinkOrderByWithAggregationInput | PlayerSkillLinkOrderByWithAggregationInput[]
    by: PlayerSkillLinkScalarFieldEnum[] | PlayerSkillLinkScalarFieldEnum
    having?: PlayerSkillLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerSkillLinkCountAggregateInputType | true
    _avg?: PlayerSkillLinkAvgAggregateInputType
    _sum?: PlayerSkillLinkSumAggregateInputType
    _min?: PlayerSkillLinkMinAggregateInputType
    _max?: PlayerSkillLinkMaxAggregateInputType
  }

  export type PlayerSkillLinkGroupByOutputType = {
    id: number
    playerId: number
    skillId: number
    currentTier: number
    acquiredAt: Date
    _count: PlayerSkillLinkCountAggregateOutputType | null
    _avg: PlayerSkillLinkAvgAggregateOutputType | null
    _sum: PlayerSkillLinkSumAggregateOutputType | null
    _min: PlayerSkillLinkMinAggregateOutputType | null
    _max: PlayerSkillLinkMaxAggregateOutputType | null
  }

  type GetPlayerSkillLinkGroupByPayload<T extends PlayerSkillLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerSkillLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerSkillLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerSkillLinkGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerSkillLinkGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSkillLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    currentTier?: boolean
    acquiredAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkillLink"]>

  export type PlayerSkillLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    currentTier?: boolean
    acquiredAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkillLink"]>

  export type PlayerSkillLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    currentTier?: boolean
    acquiredAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkillLink"]>

  export type PlayerSkillLinkSelectScalar = {
    id?: boolean
    playerId?: boolean
    skillId?: boolean
    currentTier?: boolean
    acquiredAt?: boolean
  }

  export type PlayerSkillLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "skillId" | "currentTier" | "acquiredAt", ExtArgs["result"]["playerSkillLink"]>
  export type PlayerSkillLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type PlayerSkillLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type PlayerSkillLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $PlayerSkillLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerSkillLink"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      playerId: number
      skillId: number
      currentTier: number
      acquiredAt: Date
    }, ExtArgs["result"]["playerSkillLink"]>
    composites: {}
  }

  type PlayerSkillLinkGetPayload<S extends boolean | null | undefined | PlayerSkillLinkDefaultArgs> = $Result.GetResult<Prisma.$PlayerSkillLinkPayload, S>

  type PlayerSkillLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerSkillLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerSkillLinkCountAggregateInputType | true
    }

  export interface PlayerSkillLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerSkillLink'], meta: { name: 'PlayerSkillLink' } }
    /**
     * Find zero or one PlayerSkillLink that matches the filter.
     * @param {PlayerSkillLinkFindUniqueArgs} args - Arguments to find a PlayerSkillLink
     * @example
     * // Get one PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerSkillLinkFindUniqueArgs>(args: SelectSubset<T, PlayerSkillLinkFindUniqueArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerSkillLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerSkillLinkFindUniqueOrThrowArgs} args - Arguments to find a PlayerSkillLink
     * @example
     * // Get one PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerSkillLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerSkillLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerSkillLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkFindFirstArgs} args - Arguments to find a PlayerSkillLink
     * @example
     * // Get one PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerSkillLinkFindFirstArgs>(args?: SelectSubset<T, PlayerSkillLinkFindFirstArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerSkillLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkFindFirstOrThrowArgs} args - Arguments to find a PlayerSkillLink
     * @example
     * // Get one PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerSkillLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerSkillLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerSkillLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerSkillLinks
     * const playerSkillLinks = await prisma.playerSkillLink.findMany()
     * 
     * // Get first 10 PlayerSkillLinks
     * const playerSkillLinks = await prisma.playerSkillLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerSkillLinkWithIdOnly = await prisma.playerSkillLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerSkillLinkFindManyArgs>(args?: SelectSubset<T, PlayerSkillLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerSkillLink.
     * @param {PlayerSkillLinkCreateArgs} args - Arguments to create a PlayerSkillLink.
     * @example
     * // Create one PlayerSkillLink
     * const PlayerSkillLink = await prisma.playerSkillLink.create({
     *   data: {
     *     // ... data to create a PlayerSkillLink
     *   }
     * })
     * 
     */
    create<T extends PlayerSkillLinkCreateArgs>(args: SelectSubset<T, PlayerSkillLinkCreateArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerSkillLinks.
     * @param {PlayerSkillLinkCreateManyArgs} args - Arguments to create many PlayerSkillLinks.
     * @example
     * // Create many PlayerSkillLinks
     * const playerSkillLink = await prisma.playerSkillLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerSkillLinkCreateManyArgs>(args?: SelectSubset<T, PlayerSkillLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerSkillLinks and returns the data saved in the database.
     * @param {PlayerSkillLinkCreateManyAndReturnArgs} args - Arguments to create many PlayerSkillLinks.
     * @example
     * // Create many PlayerSkillLinks
     * const playerSkillLink = await prisma.playerSkillLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerSkillLinks and only return the `id`
     * const playerSkillLinkWithIdOnly = await prisma.playerSkillLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerSkillLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerSkillLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerSkillLink.
     * @param {PlayerSkillLinkDeleteArgs} args - Arguments to delete one PlayerSkillLink.
     * @example
     * // Delete one PlayerSkillLink
     * const PlayerSkillLink = await prisma.playerSkillLink.delete({
     *   where: {
     *     // ... filter to delete one PlayerSkillLink
     *   }
     * })
     * 
     */
    delete<T extends PlayerSkillLinkDeleteArgs>(args: SelectSubset<T, PlayerSkillLinkDeleteArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerSkillLink.
     * @param {PlayerSkillLinkUpdateArgs} args - Arguments to update one PlayerSkillLink.
     * @example
     * // Update one PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerSkillLinkUpdateArgs>(args: SelectSubset<T, PlayerSkillLinkUpdateArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerSkillLinks.
     * @param {PlayerSkillLinkDeleteManyArgs} args - Arguments to filter PlayerSkillLinks to delete.
     * @example
     * // Delete a few PlayerSkillLinks
     * const { count } = await prisma.playerSkillLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerSkillLinkDeleteManyArgs>(args?: SelectSubset<T, PlayerSkillLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkillLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerSkillLinks
     * const playerSkillLink = await prisma.playerSkillLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerSkillLinkUpdateManyArgs>(args: SelectSubset<T, PlayerSkillLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkillLinks and returns the data updated in the database.
     * @param {PlayerSkillLinkUpdateManyAndReturnArgs} args - Arguments to update many PlayerSkillLinks.
     * @example
     * // Update many PlayerSkillLinks
     * const playerSkillLink = await prisma.playerSkillLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerSkillLinks and only return the `id`
     * const playerSkillLinkWithIdOnly = await prisma.playerSkillLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerSkillLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerSkillLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerSkillLink.
     * @param {PlayerSkillLinkUpsertArgs} args - Arguments to update or create a PlayerSkillLink.
     * @example
     * // Update or create a PlayerSkillLink
     * const playerSkillLink = await prisma.playerSkillLink.upsert({
     *   create: {
     *     // ... data to create a PlayerSkillLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerSkillLink we want to update
     *   }
     * })
     */
    upsert<T extends PlayerSkillLinkUpsertArgs>(args: SelectSubset<T, PlayerSkillLinkUpsertArgs<ExtArgs>>): Prisma__PlayerSkillLinkClient<$Result.GetResult<Prisma.$PlayerSkillLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerSkillLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkCountArgs} args - Arguments to filter PlayerSkillLinks to count.
     * @example
     * // Count the number of PlayerSkillLinks
     * const count = await prisma.playerSkillLink.count({
     *   where: {
     *     // ... the filter for the PlayerSkillLinks we want to count
     *   }
     * })
    **/
    count<T extends PlayerSkillLinkCountArgs>(
      args?: Subset<T, PlayerSkillLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerSkillLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerSkillLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerSkillLinkAggregateArgs>(args: Subset<T, PlayerSkillLinkAggregateArgs>): Prisma.PrismaPromise<GetPlayerSkillLinkAggregateType<T>>

    /**
     * Group by PlayerSkillLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerSkillLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerSkillLinkGroupByArgs['orderBy'] }
        : { orderBy?: PlayerSkillLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerSkillLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerSkillLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerSkillLink model
   */
  readonly fields: PlayerSkillLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerSkillLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerSkillLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerSkillLink model
   */
  interface PlayerSkillLinkFieldRefs {
    readonly id: FieldRef<"PlayerSkillLink", 'Int'>
    readonly playerId: FieldRef<"PlayerSkillLink", 'Int'>
    readonly skillId: FieldRef<"PlayerSkillLink", 'Int'>
    readonly currentTier: FieldRef<"PlayerSkillLink", 'Int'>
    readonly acquiredAt: FieldRef<"PlayerSkillLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerSkillLink findUnique
   */
  export type PlayerSkillLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkillLink to fetch.
     */
    where: PlayerSkillLinkWhereUniqueInput
  }

  /**
   * PlayerSkillLink findUniqueOrThrow
   */
  export type PlayerSkillLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkillLink to fetch.
     */
    where: PlayerSkillLinkWhereUniqueInput
  }

  /**
   * PlayerSkillLink findFirst
   */
  export type PlayerSkillLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkillLink to fetch.
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLinks to fetch.
     */
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkillLinks.
     */
    cursor?: PlayerSkillLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkillLinks.
     */
    distinct?: PlayerSkillLinkScalarFieldEnum | PlayerSkillLinkScalarFieldEnum[]
  }

  /**
   * PlayerSkillLink findFirstOrThrow
   */
  export type PlayerSkillLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkillLink to fetch.
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLinks to fetch.
     */
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkillLinks.
     */
    cursor?: PlayerSkillLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkillLinks.
     */
    distinct?: PlayerSkillLinkScalarFieldEnum | PlayerSkillLinkScalarFieldEnum[]
  }

  /**
   * PlayerSkillLink findMany
   */
  export type PlayerSkillLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkillLinks to fetch.
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLinks to fetch.
     */
    orderBy?: PlayerSkillLinkOrderByWithRelationInput | PlayerSkillLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerSkillLinks.
     */
    cursor?: PlayerSkillLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLinks.
     */
    skip?: number
    distinct?: PlayerSkillLinkScalarFieldEnum | PlayerSkillLinkScalarFieldEnum[]
  }

  /**
   * PlayerSkillLink create
   */
  export type PlayerSkillLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerSkillLink.
     */
    data: XOR<PlayerSkillLinkCreateInput, PlayerSkillLinkUncheckedCreateInput>
  }

  /**
   * PlayerSkillLink createMany
   */
  export type PlayerSkillLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerSkillLinks.
     */
    data: PlayerSkillLinkCreateManyInput | PlayerSkillLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerSkillLink createManyAndReturn
   */
  export type PlayerSkillLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerSkillLinks.
     */
    data: PlayerSkillLinkCreateManyInput | PlayerSkillLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerSkillLink update
   */
  export type PlayerSkillLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerSkillLink.
     */
    data: XOR<PlayerSkillLinkUpdateInput, PlayerSkillLinkUncheckedUpdateInput>
    /**
     * Choose, which PlayerSkillLink to update.
     */
    where: PlayerSkillLinkWhereUniqueInput
  }

  /**
   * PlayerSkillLink updateMany
   */
  export type PlayerSkillLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerSkillLinks.
     */
    data: XOR<PlayerSkillLinkUpdateManyMutationInput, PlayerSkillLinkUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkillLinks to update
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * Limit how many PlayerSkillLinks to update.
     */
    limit?: number
  }

  /**
   * PlayerSkillLink updateManyAndReturn
   */
  export type PlayerSkillLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * The data used to update PlayerSkillLinks.
     */
    data: XOR<PlayerSkillLinkUpdateManyMutationInput, PlayerSkillLinkUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkillLinks to update
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * Limit how many PlayerSkillLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerSkillLink upsert
   */
  export type PlayerSkillLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerSkillLink to update in case it exists.
     */
    where: PlayerSkillLinkWhereUniqueInput
    /**
     * In case the PlayerSkillLink found by the `where` argument doesn't exist, create a new PlayerSkillLink with this data.
     */
    create: XOR<PlayerSkillLinkCreateInput, PlayerSkillLinkUncheckedCreateInput>
    /**
     * In case the PlayerSkillLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerSkillLinkUpdateInput, PlayerSkillLinkUncheckedUpdateInput>
  }

  /**
   * PlayerSkillLink delete
   */
  export type PlayerSkillLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
    /**
     * Filter which PlayerSkillLink to delete.
     */
    where: PlayerSkillLinkWhereUniqueInput
  }

  /**
   * PlayerSkillLink deleteMany
   */
  export type PlayerSkillLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkillLinks to delete
     */
    where?: PlayerSkillLinkWhereInput
    /**
     * Limit how many PlayerSkillLinks to delete.
     */
    limit?: number
  }

  /**
   * PlayerSkillLink without action
   */
  export type PlayerSkillLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkillLink
     */
    select?: PlayerSkillLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkillLink
     */
    omit?: PlayerSkillLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillLinkInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    level: number | null
    motivation: number | null
    development: number | null
    teaching: number | null
    physiology: number | null
    talentIdentification: number | null
    potentialAssessment: number | null
    tactics: number | null
    age: number | null
  }

  export type StaffSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    level: number | null
    motivation: number | null
    development: number | null
    teaching: number | null
    physiology: number | null
    talentIdentification: number | null
    potentialAssessment: number | null
    tactics: number | null
    age: number | null
  }

  export type StaffMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    type: $Enums.StaffType | null
    name: string | null
    level: number | null
    motivation: number | null
    development: number | null
    teaching: number | null
    physiology: number | null
    talentIdentification: number | null
    potentialAssessment: number | null
    tactics: number | null
    age: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    type: $Enums.StaffType | null
    name: string | null
    level: number | null
    motivation: number | null
    development: number | null
    teaching: number | null
    physiology: number | null
    talentIdentification: number | null
    potentialAssessment: number | null
    tactics: number | null
    age: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    teamId: number
    type: number
    name: number
    level: number
    motivation: number
    development: number
    teaching: number
    physiology: number
    talentIdentification: number
    potentialAssessment: number
    tactics: number
    age: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    id?: true
    teamId?: true
    level?: true
    motivation?: true
    development?: true
    teaching?: true
    physiology?: true
    talentIdentification?: true
    potentialAssessment?: true
    tactics?: true
    age?: true
  }

  export type StaffSumAggregateInputType = {
    id?: true
    teamId?: true
    level?: true
    motivation?: true
    development?: true
    teaching?: true
    physiology?: true
    talentIdentification?: true
    potentialAssessment?: true
    tactics?: true
    age?: true
  }

  export type StaffMinAggregateInputType = {
    id?: true
    teamId?: true
    type?: true
    name?: true
    level?: true
    motivation?: true
    development?: true
    teaching?: true
    physiology?: true
    talentIdentification?: true
    potentialAssessment?: true
    tactics?: true
    age?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    teamId?: true
    type?: true
    name?: true
    level?: true
    motivation?: true
    development?: true
    teaching?: true
    physiology?: true
    talentIdentification?: true
    potentialAssessment?: true
    tactics?: true
    age?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    teamId?: true
    type?: true
    name?: true
    level?: true
    motivation?: true
    development?: true
    teaching?: true
    physiology?: true
    talentIdentification?: true
    potentialAssessment?: true
    tactics?: true
    age?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: number
    teamId: number
    type: $Enums.StaffType
    name: string
    level: number
    motivation: number
    development: number
    teaching: number
    physiology: number
    talentIdentification: number
    potentialAssessment: number
    tactics: number
    age: number
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    type?: boolean
    name?: boolean
    level?: boolean
    motivation?: boolean
    development?: boolean
    teaching?: boolean
    physiology?: boolean
    talentIdentification?: boolean
    potentialAssessment?: boolean
    tactics?: boolean
    age?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contract?: boolean | Staff$contractArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    type?: boolean
    name?: boolean
    level?: boolean
    motivation?: boolean
    development?: boolean
    teaching?: boolean
    physiology?: boolean
    talentIdentification?: boolean
    potentialAssessment?: boolean
    tactics?: boolean
    age?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    type?: boolean
    name?: boolean
    level?: boolean
    motivation?: boolean
    development?: boolean
    teaching?: boolean
    physiology?: boolean
    talentIdentification?: boolean
    potentialAssessment?: boolean
    tactics?: boolean
    age?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    teamId?: boolean
    type?: boolean
    name?: boolean
    level?: boolean
    motivation?: boolean
    development?: boolean
    teaching?: boolean
    physiology?: boolean
    talentIdentification?: boolean
    potentialAssessment?: boolean
    tactics?: boolean
    age?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "type" | "name" | "level" | "motivation" | "development" | "teaching" | "physiology" | "talentIdentification" | "potentialAssessment" | "tactics" | "age" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contract?: boolean | Staff$contractArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      type: $Enums.StaffType
      name: string
      level: number
      motivation: number
      development: number
      teaching: number
      physiology: number
      talentIdentification: number
      potentialAssessment: number
      tactics: number
      age: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contract<T extends Staff$contractArgs<ExtArgs> = {}>(args?: Subset<T, Staff$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'Int'>
    readonly teamId: FieldRef<"Staff", 'Int'>
    readonly type: FieldRef<"Staff", 'StaffType'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly level: FieldRef<"Staff", 'Int'>
    readonly motivation: FieldRef<"Staff", 'Int'>
    readonly development: FieldRef<"Staff", 'Int'>
    readonly teaching: FieldRef<"Staff", 'Int'>
    readonly physiology: FieldRef<"Staff", 'Int'>
    readonly talentIdentification: FieldRef<"Staff", 'Int'>
    readonly potentialAssessment: FieldRef<"Staff", 'Int'>
    readonly tactics: FieldRef<"Staff", 'Int'>
    readonly age: FieldRef<"Staff", 'Int'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.contract
   */
  export type Staff$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model TeamFinances
   */

  export type AggregateTeamFinances = {
    _count: TeamFinancesCountAggregateOutputType | null
    _avg: TeamFinancesAvgAggregateOutputType | null
    _sum: TeamFinancesSumAggregateOutputType | null
    _min: TeamFinancesMinAggregateOutputType | null
    _max: TeamFinancesMaxAggregateOutputType | null
  }

  export type TeamFinancesAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    credits: number | null
    gems: number | null
    escrowCredits: number | null
    escrowGems: number | null
    projectedIncome: number | null
    projectedExpenses: number | null
    lastSeasonRevenue: number | null
    lastSeasonExpenses: number | null
    facilitiesMaintenanceCost: number | null
  }

  export type TeamFinancesSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    credits: bigint | null
    gems: number | null
    escrowCredits: bigint | null
    escrowGems: number | null
    projectedIncome: bigint | null
    projectedExpenses: bigint | null
    lastSeasonRevenue: bigint | null
    lastSeasonExpenses: bigint | null
    facilitiesMaintenanceCost: bigint | null
  }

  export type TeamFinancesMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    credits: bigint | null
    gems: number | null
    escrowCredits: bigint | null
    escrowGems: number | null
    projectedIncome: bigint | null
    projectedExpenses: bigint | null
    lastSeasonRevenue: bigint | null
    lastSeasonExpenses: bigint | null
    facilitiesMaintenanceCost: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamFinancesMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    credits: bigint | null
    gems: number | null
    escrowCredits: bigint | null
    escrowGems: number | null
    projectedIncome: bigint | null
    projectedExpenses: bigint | null
    lastSeasonRevenue: bigint | null
    lastSeasonExpenses: bigint | null
    facilitiesMaintenanceCost: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamFinancesCountAggregateOutputType = {
    id: number
    teamId: number
    credits: number
    gems: number
    escrowCredits: number
    escrowGems: number
    projectedIncome: number
    projectedExpenses: number
    lastSeasonRevenue: number
    lastSeasonExpenses: number
    facilitiesMaintenanceCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamFinancesAvgAggregateInputType = {
    id?: true
    teamId?: true
    credits?: true
    gems?: true
    escrowCredits?: true
    escrowGems?: true
    projectedIncome?: true
    projectedExpenses?: true
    lastSeasonRevenue?: true
    lastSeasonExpenses?: true
    facilitiesMaintenanceCost?: true
  }

  export type TeamFinancesSumAggregateInputType = {
    id?: true
    teamId?: true
    credits?: true
    gems?: true
    escrowCredits?: true
    escrowGems?: true
    projectedIncome?: true
    projectedExpenses?: true
    lastSeasonRevenue?: true
    lastSeasonExpenses?: true
    facilitiesMaintenanceCost?: true
  }

  export type TeamFinancesMinAggregateInputType = {
    id?: true
    teamId?: true
    credits?: true
    gems?: true
    escrowCredits?: true
    escrowGems?: true
    projectedIncome?: true
    projectedExpenses?: true
    lastSeasonRevenue?: true
    lastSeasonExpenses?: true
    facilitiesMaintenanceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamFinancesMaxAggregateInputType = {
    id?: true
    teamId?: true
    credits?: true
    gems?: true
    escrowCredits?: true
    escrowGems?: true
    projectedIncome?: true
    projectedExpenses?: true
    lastSeasonRevenue?: true
    lastSeasonExpenses?: true
    facilitiesMaintenanceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamFinancesCountAggregateInputType = {
    id?: true
    teamId?: true
    credits?: true
    gems?: true
    escrowCredits?: true
    escrowGems?: true
    projectedIncome?: true
    projectedExpenses?: true
    lastSeasonRevenue?: true
    lastSeasonExpenses?: true
    facilitiesMaintenanceCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamFinancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamFinances to aggregate.
     */
    where?: TeamFinancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFinances to fetch.
     */
    orderBy?: TeamFinancesOrderByWithRelationInput | TeamFinancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamFinancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFinances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFinances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamFinances
    **/
    _count?: true | TeamFinancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamFinancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamFinancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamFinancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamFinancesMaxAggregateInputType
  }

  export type GetTeamFinancesAggregateType<T extends TeamFinancesAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamFinances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamFinances[P]>
      : GetScalarType<T[P], AggregateTeamFinances[P]>
  }




  export type TeamFinancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamFinancesWhereInput
    orderBy?: TeamFinancesOrderByWithAggregationInput | TeamFinancesOrderByWithAggregationInput[]
    by: TeamFinancesScalarFieldEnum[] | TeamFinancesScalarFieldEnum
    having?: TeamFinancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamFinancesCountAggregateInputType | true
    _avg?: TeamFinancesAvgAggregateInputType
    _sum?: TeamFinancesSumAggregateInputType
    _min?: TeamFinancesMinAggregateInputType
    _max?: TeamFinancesMaxAggregateInputType
  }

  export type TeamFinancesGroupByOutputType = {
    id: number
    teamId: number
    credits: bigint
    gems: number
    escrowCredits: bigint
    escrowGems: number
    projectedIncome: bigint
    projectedExpenses: bigint
    lastSeasonRevenue: bigint
    lastSeasonExpenses: bigint
    facilitiesMaintenanceCost: bigint
    createdAt: Date
    updatedAt: Date
    _count: TeamFinancesCountAggregateOutputType | null
    _avg: TeamFinancesAvgAggregateOutputType | null
    _sum: TeamFinancesSumAggregateOutputType | null
    _min: TeamFinancesMinAggregateOutputType | null
    _max: TeamFinancesMaxAggregateOutputType | null
  }

  type GetTeamFinancesGroupByPayload<T extends TeamFinancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamFinancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamFinancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamFinancesGroupByOutputType[P]>
            : GetScalarType<T[P], TeamFinancesGroupByOutputType[P]>
        }
      >
    >


  export type TeamFinancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    credits?: boolean
    gems?: boolean
    escrowCredits?: boolean
    escrowGems?: boolean
    projectedIncome?: boolean
    projectedExpenses?: boolean
    lastSeasonRevenue?: boolean
    lastSeasonExpenses?: boolean
    facilitiesMaintenanceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamFinances"]>

  export type TeamFinancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    credits?: boolean
    gems?: boolean
    escrowCredits?: boolean
    escrowGems?: boolean
    projectedIncome?: boolean
    projectedExpenses?: boolean
    lastSeasonRevenue?: boolean
    lastSeasonExpenses?: boolean
    facilitiesMaintenanceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamFinances"]>

  export type TeamFinancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    credits?: boolean
    gems?: boolean
    escrowCredits?: boolean
    escrowGems?: boolean
    projectedIncome?: boolean
    projectedExpenses?: boolean
    lastSeasonRevenue?: boolean
    lastSeasonExpenses?: boolean
    facilitiesMaintenanceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamFinances"]>

  export type TeamFinancesSelectScalar = {
    id?: boolean
    teamId?: boolean
    credits?: boolean
    gems?: boolean
    escrowCredits?: boolean
    escrowGems?: boolean
    projectedIncome?: boolean
    projectedExpenses?: boolean
    lastSeasonRevenue?: boolean
    lastSeasonExpenses?: boolean
    facilitiesMaintenanceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamFinancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "credits" | "gems" | "escrowCredits" | "escrowGems" | "projectedIncome" | "projectedExpenses" | "lastSeasonRevenue" | "lastSeasonExpenses" | "facilitiesMaintenanceCost" | "createdAt" | "updatedAt", ExtArgs["result"]["teamFinances"]>
  export type TeamFinancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamFinancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamFinancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamFinancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamFinances"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      credits: bigint
      gems: number
      escrowCredits: bigint
      escrowGems: number
      projectedIncome: bigint
      projectedExpenses: bigint
      lastSeasonRevenue: bigint
      lastSeasonExpenses: bigint
      facilitiesMaintenanceCost: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamFinances"]>
    composites: {}
  }

  type TeamFinancesGetPayload<S extends boolean | null | undefined | TeamFinancesDefaultArgs> = $Result.GetResult<Prisma.$TeamFinancesPayload, S>

  type TeamFinancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFinancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamFinancesCountAggregateInputType | true
    }

  export interface TeamFinancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamFinances'], meta: { name: 'TeamFinances' } }
    /**
     * Find zero or one TeamFinances that matches the filter.
     * @param {TeamFinancesFindUniqueArgs} args - Arguments to find a TeamFinances
     * @example
     * // Get one TeamFinances
     * const teamFinances = await prisma.teamFinances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFinancesFindUniqueArgs>(args: SelectSubset<T, TeamFinancesFindUniqueArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamFinances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFinancesFindUniqueOrThrowArgs} args - Arguments to find a TeamFinances
     * @example
     * // Get one TeamFinances
     * const teamFinances = await prisma.teamFinances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFinancesFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFinancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamFinances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesFindFirstArgs} args - Arguments to find a TeamFinances
     * @example
     * // Get one TeamFinances
     * const teamFinances = await prisma.teamFinances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFinancesFindFirstArgs>(args?: SelectSubset<T, TeamFinancesFindFirstArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamFinances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesFindFirstOrThrowArgs} args - Arguments to find a TeamFinances
     * @example
     * // Get one TeamFinances
     * const teamFinances = await prisma.teamFinances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFinancesFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFinancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamFinances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamFinances
     * const teamFinances = await prisma.teamFinances.findMany()
     * 
     * // Get first 10 TeamFinances
     * const teamFinances = await prisma.teamFinances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamFinancesWithIdOnly = await prisma.teamFinances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFinancesFindManyArgs>(args?: SelectSubset<T, TeamFinancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamFinances.
     * @param {TeamFinancesCreateArgs} args - Arguments to create a TeamFinances.
     * @example
     * // Create one TeamFinances
     * const TeamFinances = await prisma.teamFinances.create({
     *   data: {
     *     // ... data to create a TeamFinances
     *   }
     * })
     * 
     */
    create<T extends TeamFinancesCreateArgs>(args: SelectSubset<T, TeamFinancesCreateArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamFinances.
     * @param {TeamFinancesCreateManyArgs} args - Arguments to create many TeamFinances.
     * @example
     * // Create many TeamFinances
     * const teamFinances = await prisma.teamFinances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamFinancesCreateManyArgs>(args?: SelectSubset<T, TeamFinancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamFinances and returns the data saved in the database.
     * @param {TeamFinancesCreateManyAndReturnArgs} args - Arguments to create many TeamFinances.
     * @example
     * // Create many TeamFinances
     * const teamFinances = await prisma.teamFinances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamFinances and only return the `id`
     * const teamFinancesWithIdOnly = await prisma.teamFinances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamFinancesCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamFinancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamFinances.
     * @param {TeamFinancesDeleteArgs} args - Arguments to delete one TeamFinances.
     * @example
     * // Delete one TeamFinances
     * const TeamFinances = await prisma.teamFinances.delete({
     *   where: {
     *     // ... filter to delete one TeamFinances
     *   }
     * })
     * 
     */
    delete<T extends TeamFinancesDeleteArgs>(args: SelectSubset<T, TeamFinancesDeleteArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamFinances.
     * @param {TeamFinancesUpdateArgs} args - Arguments to update one TeamFinances.
     * @example
     * // Update one TeamFinances
     * const teamFinances = await prisma.teamFinances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamFinancesUpdateArgs>(args: SelectSubset<T, TeamFinancesUpdateArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamFinances.
     * @param {TeamFinancesDeleteManyArgs} args - Arguments to filter TeamFinances to delete.
     * @example
     * // Delete a few TeamFinances
     * const { count } = await prisma.teamFinances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamFinancesDeleteManyArgs>(args?: SelectSubset<T, TeamFinancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamFinances
     * const teamFinances = await prisma.teamFinances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamFinancesUpdateManyArgs>(args: SelectSubset<T, TeamFinancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamFinances and returns the data updated in the database.
     * @param {TeamFinancesUpdateManyAndReturnArgs} args - Arguments to update many TeamFinances.
     * @example
     * // Update many TeamFinances
     * const teamFinances = await prisma.teamFinances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamFinances and only return the `id`
     * const teamFinancesWithIdOnly = await prisma.teamFinances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamFinancesUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamFinancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamFinances.
     * @param {TeamFinancesUpsertArgs} args - Arguments to update or create a TeamFinances.
     * @example
     * // Update or create a TeamFinances
     * const teamFinances = await prisma.teamFinances.upsert({
     *   create: {
     *     // ... data to create a TeamFinances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamFinances we want to update
     *   }
     * })
     */
    upsert<T extends TeamFinancesUpsertArgs>(args: SelectSubset<T, TeamFinancesUpsertArgs<ExtArgs>>): Prisma__TeamFinancesClient<$Result.GetResult<Prisma.$TeamFinancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesCountArgs} args - Arguments to filter TeamFinances to count.
     * @example
     * // Count the number of TeamFinances
     * const count = await prisma.teamFinances.count({
     *   where: {
     *     // ... the filter for the TeamFinances we want to count
     *   }
     * })
    **/
    count<T extends TeamFinancesCountArgs>(
      args?: Subset<T, TeamFinancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamFinancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamFinancesAggregateArgs>(args: Subset<T, TeamFinancesAggregateArgs>): Prisma.PrismaPromise<GetTeamFinancesAggregateType<T>>

    /**
     * Group by TeamFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFinancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamFinancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamFinancesGroupByArgs['orderBy'] }
        : { orderBy?: TeamFinancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamFinancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamFinancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamFinances model
   */
  readonly fields: TeamFinancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamFinances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamFinancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamFinances model
   */
  interface TeamFinancesFieldRefs {
    readonly id: FieldRef<"TeamFinances", 'Int'>
    readonly teamId: FieldRef<"TeamFinances", 'Int'>
    readonly credits: FieldRef<"TeamFinances", 'BigInt'>
    readonly gems: FieldRef<"TeamFinances", 'Int'>
    readonly escrowCredits: FieldRef<"TeamFinances", 'BigInt'>
    readonly escrowGems: FieldRef<"TeamFinances", 'Int'>
    readonly projectedIncome: FieldRef<"TeamFinances", 'BigInt'>
    readonly projectedExpenses: FieldRef<"TeamFinances", 'BigInt'>
    readonly lastSeasonRevenue: FieldRef<"TeamFinances", 'BigInt'>
    readonly lastSeasonExpenses: FieldRef<"TeamFinances", 'BigInt'>
    readonly facilitiesMaintenanceCost: FieldRef<"TeamFinances", 'BigInt'>
    readonly createdAt: FieldRef<"TeamFinances", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamFinances", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamFinances findUnique
   */
  export type TeamFinancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter, which TeamFinances to fetch.
     */
    where: TeamFinancesWhereUniqueInput
  }

  /**
   * TeamFinances findUniqueOrThrow
   */
  export type TeamFinancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter, which TeamFinances to fetch.
     */
    where: TeamFinancesWhereUniqueInput
  }

  /**
   * TeamFinances findFirst
   */
  export type TeamFinancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter, which TeamFinances to fetch.
     */
    where?: TeamFinancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFinances to fetch.
     */
    orderBy?: TeamFinancesOrderByWithRelationInput | TeamFinancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamFinances.
     */
    cursor?: TeamFinancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFinances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFinances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamFinances.
     */
    distinct?: TeamFinancesScalarFieldEnum | TeamFinancesScalarFieldEnum[]
  }

  /**
   * TeamFinances findFirstOrThrow
   */
  export type TeamFinancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter, which TeamFinances to fetch.
     */
    where?: TeamFinancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFinances to fetch.
     */
    orderBy?: TeamFinancesOrderByWithRelationInput | TeamFinancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamFinances.
     */
    cursor?: TeamFinancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFinances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFinances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamFinances.
     */
    distinct?: TeamFinancesScalarFieldEnum | TeamFinancesScalarFieldEnum[]
  }

  /**
   * TeamFinances findMany
   */
  export type TeamFinancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter, which TeamFinances to fetch.
     */
    where?: TeamFinancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFinances to fetch.
     */
    orderBy?: TeamFinancesOrderByWithRelationInput | TeamFinancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamFinances.
     */
    cursor?: TeamFinancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFinances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFinances.
     */
    skip?: number
    distinct?: TeamFinancesScalarFieldEnum | TeamFinancesScalarFieldEnum[]
  }

  /**
   * TeamFinances create
   */
  export type TeamFinancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamFinances.
     */
    data: XOR<TeamFinancesCreateInput, TeamFinancesUncheckedCreateInput>
  }

  /**
   * TeamFinances createMany
   */
  export type TeamFinancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamFinances.
     */
    data: TeamFinancesCreateManyInput | TeamFinancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamFinances createManyAndReturn
   */
  export type TeamFinancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * The data used to create many TeamFinances.
     */
    data: TeamFinancesCreateManyInput | TeamFinancesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamFinances update
   */
  export type TeamFinancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamFinances.
     */
    data: XOR<TeamFinancesUpdateInput, TeamFinancesUncheckedUpdateInput>
    /**
     * Choose, which TeamFinances to update.
     */
    where: TeamFinancesWhereUniqueInput
  }

  /**
   * TeamFinances updateMany
   */
  export type TeamFinancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamFinances.
     */
    data: XOR<TeamFinancesUpdateManyMutationInput, TeamFinancesUncheckedUpdateManyInput>
    /**
     * Filter which TeamFinances to update
     */
    where?: TeamFinancesWhereInput
    /**
     * Limit how many TeamFinances to update.
     */
    limit?: number
  }

  /**
   * TeamFinances updateManyAndReturn
   */
  export type TeamFinancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * The data used to update TeamFinances.
     */
    data: XOR<TeamFinancesUpdateManyMutationInput, TeamFinancesUncheckedUpdateManyInput>
    /**
     * Filter which TeamFinances to update
     */
    where?: TeamFinancesWhereInput
    /**
     * Limit how many TeamFinances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamFinances upsert
   */
  export type TeamFinancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamFinances to update in case it exists.
     */
    where: TeamFinancesWhereUniqueInput
    /**
     * In case the TeamFinances found by the `where` argument doesn't exist, create a new TeamFinances with this data.
     */
    create: XOR<TeamFinancesCreateInput, TeamFinancesUncheckedCreateInput>
    /**
     * In case the TeamFinances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamFinancesUpdateInput, TeamFinancesUncheckedUpdateInput>
  }

  /**
   * TeamFinances delete
   */
  export type TeamFinancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
    /**
     * Filter which TeamFinances to delete.
     */
    where: TeamFinancesWhereUniqueInput
  }

  /**
   * TeamFinances deleteMany
   */
  export type TeamFinancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamFinances to delete
     */
    where?: TeamFinancesWhereInput
    /**
     * Limit how many TeamFinances to delete.
     */
    limit?: number
  }

  /**
   * TeamFinances without action
   */
  export type TeamFinancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamFinances
     */
    select?: TeamFinancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamFinances
     */
    omit?: TeamFinancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamFinancesInclude<ExtArgs> | null
  }


  /**
   * Model Stadium
   */

  export type AggregateStadium = {
    _count: StadiumCountAggregateOutputType | null
    _avg: StadiumAvgAggregateOutputType | null
    _sum: StadiumSumAggregateOutputType | null
    _min: StadiumMinAggregateOutputType | null
    _max: StadiumMaxAggregateOutputType | null
  }

  export type StadiumAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    capacity: number | null
    concessionsLevel: number | null
    parkingLevel: number | null
    vipSuitesLevel: number | null
    merchandisingLevel: number | null
    lightingScreensLevel: number | null
  }

  export type StadiumSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    capacity: number | null
    concessionsLevel: number | null
    parkingLevel: number | null
    vipSuitesLevel: number | null
    merchandisingLevel: number | null
    lightingScreensLevel: number | null
  }

  export type StadiumMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    capacity: number | null
    concessionsLevel: number | null
    parkingLevel: number | null
    vipSuitesLevel: number | null
    merchandisingLevel: number | null
    lightingScreensLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StadiumMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    capacity: number | null
    concessionsLevel: number | null
    parkingLevel: number | null
    vipSuitesLevel: number | null
    merchandisingLevel: number | null
    lightingScreensLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StadiumCountAggregateOutputType = {
    id: number
    teamId: number
    capacity: number
    concessionsLevel: number
    parkingLevel: number
    vipSuitesLevel: number
    merchandisingLevel: number
    lightingScreensLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StadiumAvgAggregateInputType = {
    id?: true
    teamId?: true
    capacity?: true
    concessionsLevel?: true
    parkingLevel?: true
    vipSuitesLevel?: true
    merchandisingLevel?: true
    lightingScreensLevel?: true
  }

  export type StadiumSumAggregateInputType = {
    id?: true
    teamId?: true
    capacity?: true
    concessionsLevel?: true
    parkingLevel?: true
    vipSuitesLevel?: true
    merchandisingLevel?: true
    lightingScreensLevel?: true
  }

  export type StadiumMinAggregateInputType = {
    id?: true
    teamId?: true
    capacity?: true
    concessionsLevel?: true
    parkingLevel?: true
    vipSuitesLevel?: true
    merchandisingLevel?: true
    lightingScreensLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StadiumMaxAggregateInputType = {
    id?: true
    teamId?: true
    capacity?: true
    concessionsLevel?: true
    parkingLevel?: true
    vipSuitesLevel?: true
    merchandisingLevel?: true
    lightingScreensLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StadiumCountAggregateInputType = {
    id?: true
    teamId?: true
    capacity?: true
    concessionsLevel?: true
    parkingLevel?: true
    vipSuitesLevel?: true
    merchandisingLevel?: true
    lightingScreensLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StadiumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stadium to aggregate.
     */
    where?: StadiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stadiums to fetch.
     */
    orderBy?: StadiumOrderByWithRelationInput | StadiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StadiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stadiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stadiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stadiums
    **/
    _count?: true | StadiumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StadiumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StadiumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StadiumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StadiumMaxAggregateInputType
  }

  export type GetStadiumAggregateType<T extends StadiumAggregateArgs> = {
        [P in keyof T & keyof AggregateStadium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStadium[P]>
      : GetScalarType<T[P], AggregateStadium[P]>
  }




  export type StadiumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StadiumWhereInput
    orderBy?: StadiumOrderByWithAggregationInput | StadiumOrderByWithAggregationInput[]
    by: StadiumScalarFieldEnum[] | StadiumScalarFieldEnum
    having?: StadiumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StadiumCountAggregateInputType | true
    _avg?: StadiumAvgAggregateInputType
    _sum?: StadiumSumAggregateInputType
    _min?: StadiumMinAggregateInputType
    _max?: StadiumMaxAggregateInputType
  }

  export type StadiumGroupByOutputType = {
    id: number
    teamId: number
    capacity: number
    concessionsLevel: number
    parkingLevel: number
    vipSuitesLevel: number
    merchandisingLevel: number
    lightingScreensLevel: number
    createdAt: Date
    updatedAt: Date
    _count: StadiumCountAggregateOutputType | null
    _avg: StadiumAvgAggregateOutputType | null
    _sum: StadiumSumAggregateOutputType | null
    _min: StadiumMinAggregateOutputType | null
    _max: StadiumMaxAggregateOutputType | null
  }

  type GetStadiumGroupByPayload<T extends StadiumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StadiumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StadiumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StadiumGroupByOutputType[P]>
            : GetScalarType<T[P], StadiumGroupByOutputType[P]>
        }
      >
    >


  export type StadiumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    capacity?: boolean
    concessionsLevel?: boolean
    parkingLevel?: boolean
    vipSuitesLevel?: boolean
    merchandisingLevel?: boolean
    lightingScreensLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stadium"]>

  export type StadiumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    capacity?: boolean
    concessionsLevel?: boolean
    parkingLevel?: boolean
    vipSuitesLevel?: boolean
    merchandisingLevel?: boolean
    lightingScreensLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stadium"]>

  export type StadiumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    capacity?: boolean
    concessionsLevel?: boolean
    parkingLevel?: boolean
    vipSuitesLevel?: boolean
    merchandisingLevel?: boolean
    lightingScreensLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stadium"]>

  export type StadiumSelectScalar = {
    id?: boolean
    teamId?: boolean
    capacity?: boolean
    concessionsLevel?: boolean
    parkingLevel?: boolean
    vipSuitesLevel?: boolean
    merchandisingLevel?: boolean
    lightingScreensLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StadiumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "capacity" | "concessionsLevel" | "parkingLevel" | "vipSuitesLevel" | "merchandisingLevel" | "lightingScreensLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["stadium"]>
  export type StadiumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type StadiumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type StadiumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $StadiumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stadium"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      capacity: number
      concessionsLevel: number
      parkingLevel: number
      vipSuitesLevel: number
      merchandisingLevel: number
      lightingScreensLevel: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stadium"]>
    composites: {}
  }

  type StadiumGetPayload<S extends boolean | null | undefined | StadiumDefaultArgs> = $Result.GetResult<Prisma.$StadiumPayload, S>

  type StadiumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StadiumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StadiumCountAggregateInputType | true
    }

  export interface StadiumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stadium'], meta: { name: 'Stadium' } }
    /**
     * Find zero or one Stadium that matches the filter.
     * @param {StadiumFindUniqueArgs} args - Arguments to find a Stadium
     * @example
     * // Get one Stadium
     * const stadium = await prisma.stadium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StadiumFindUniqueArgs>(args: SelectSubset<T, StadiumFindUniqueArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stadium that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StadiumFindUniqueOrThrowArgs} args - Arguments to find a Stadium
     * @example
     * // Get one Stadium
     * const stadium = await prisma.stadium.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StadiumFindUniqueOrThrowArgs>(args: SelectSubset<T, StadiumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stadium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumFindFirstArgs} args - Arguments to find a Stadium
     * @example
     * // Get one Stadium
     * const stadium = await prisma.stadium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StadiumFindFirstArgs>(args?: SelectSubset<T, StadiumFindFirstArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stadium that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumFindFirstOrThrowArgs} args - Arguments to find a Stadium
     * @example
     * // Get one Stadium
     * const stadium = await prisma.stadium.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StadiumFindFirstOrThrowArgs>(args?: SelectSubset<T, StadiumFindFirstOrThrowArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stadiums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stadiums
     * const stadiums = await prisma.stadium.findMany()
     * 
     * // Get first 10 Stadiums
     * const stadiums = await prisma.stadium.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stadiumWithIdOnly = await prisma.stadium.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StadiumFindManyArgs>(args?: SelectSubset<T, StadiumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stadium.
     * @param {StadiumCreateArgs} args - Arguments to create a Stadium.
     * @example
     * // Create one Stadium
     * const Stadium = await prisma.stadium.create({
     *   data: {
     *     // ... data to create a Stadium
     *   }
     * })
     * 
     */
    create<T extends StadiumCreateArgs>(args: SelectSubset<T, StadiumCreateArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stadiums.
     * @param {StadiumCreateManyArgs} args - Arguments to create many Stadiums.
     * @example
     * // Create many Stadiums
     * const stadium = await prisma.stadium.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StadiumCreateManyArgs>(args?: SelectSubset<T, StadiumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stadiums and returns the data saved in the database.
     * @param {StadiumCreateManyAndReturnArgs} args - Arguments to create many Stadiums.
     * @example
     * // Create many Stadiums
     * const stadium = await prisma.stadium.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stadiums and only return the `id`
     * const stadiumWithIdOnly = await prisma.stadium.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StadiumCreateManyAndReturnArgs>(args?: SelectSubset<T, StadiumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stadium.
     * @param {StadiumDeleteArgs} args - Arguments to delete one Stadium.
     * @example
     * // Delete one Stadium
     * const Stadium = await prisma.stadium.delete({
     *   where: {
     *     // ... filter to delete one Stadium
     *   }
     * })
     * 
     */
    delete<T extends StadiumDeleteArgs>(args: SelectSubset<T, StadiumDeleteArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stadium.
     * @param {StadiumUpdateArgs} args - Arguments to update one Stadium.
     * @example
     * // Update one Stadium
     * const stadium = await prisma.stadium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StadiumUpdateArgs>(args: SelectSubset<T, StadiumUpdateArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stadiums.
     * @param {StadiumDeleteManyArgs} args - Arguments to filter Stadiums to delete.
     * @example
     * // Delete a few Stadiums
     * const { count } = await prisma.stadium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StadiumDeleteManyArgs>(args?: SelectSubset<T, StadiumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stadiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stadiums
     * const stadium = await prisma.stadium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StadiumUpdateManyArgs>(args: SelectSubset<T, StadiumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stadiums and returns the data updated in the database.
     * @param {StadiumUpdateManyAndReturnArgs} args - Arguments to update many Stadiums.
     * @example
     * // Update many Stadiums
     * const stadium = await prisma.stadium.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stadiums and only return the `id`
     * const stadiumWithIdOnly = await prisma.stadium.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StadiumUpdateManyAndReturnArgs>(args: SelectSubset<T, StadiumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stadium.
     * @param {StadiumUpsertArgs} args - Arguments to update or create a Stadium.
     * @example
     * // Update or create a Stadium
     * const stadium = await prisma.stadium.upsert({
     *   create: {
     *     // ... data to create a Stadium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stadium we want to update
     *   }
     * })
     */
    upsert<T extends StadiumUpsertArgs>(args: SelectSubset<T, StadiumUpsertArgs<ExtArgs>>): Prisma__StadiumClient<$Result.GetResult<Prisma.$StadiumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stadiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumCountArgs} args - Arguments to filter Stadiums to count.
     * @example
     * // Count the number of Stadiums
     * const count = await prisma.stadium.count({
     *   where: {
     *     // ... the filter for the Stadiums we want to count
     *   }
     * })
    **/
    count<T extends StadiumCountArgs>(
      args?: Subset<T, StadiumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StadiumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stadium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StadiumAggregateArgs>(args: Subset<T, StadiumAggregateArgs>): Prisma.PrismaPromise<GetStadiumAggregateType<T>>

    /**
     * Group by Stadium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StadiumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StadiumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StadiumGroupByArgs['orderBy'] }
        : { orderBy?: StadiumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StadiumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStadiumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stadium model
   */
  readonly fields: StadiumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stadium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StadiumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stadium model
   */
  interface StadiumFieldRefs {
    readonly id: FieldRef<"Stadium", 'Int'>
    readonly teamId: FieldRef<"Stadium", 'Int'>
    readonly capacity: FieldRef<"Stadium", 'Int'>
    readonly concessionsLevel: FieldRef<"Stadium", 'Int'>
    readonly parkingLevel: FieldRef<"Stadium", 'Int'>
    readonly vipSuitesLevel: FieldRef<"Stadium", 'Int'>
    readonly merchandisingLevel: FieldRef<"Stadium", 'Int'>
    readonly lightingScreensLevel: FieldRef<"Stadium", 'Int'>
    readonly createdAt: FieldRef<"Stadium", 'DateTime'>
    readonly updatedAt: FieldRef<"Stadium", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stadium findUnique
   */
  export type StadiumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter, which Stadium to fetch.
     */
    where: StadiumWhereUniqueInput
  }

  /**
   * Stadium findUniqueOrThrow
   */
  export type StadiumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter, which Stadium to fetch.
     */
    where: StadiumWhereUniqueInput
  }

  /**
   * Stadium findFirst
   */
  export type StadiumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter, which Stadium to fetch.
     */
    where?: StadiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stadiums to fetch.
     */
    orderBy?: StadiumOrderByWithRelationInput | StadiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stadiums.
     */
    cursor?: StadiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stadiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stadiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stadiums.
     */
    distinct?: StadiumScalarFieldEnum | StadiumScalarFieldEnum[]
  }

  /**
   * Stadium findFirstOrThrow
   */
  export type StadiumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter, which Stadium to fetch.
     */
    where?: StadiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stadiums to fetch.
     */
    orderBy?: StadiumOrderByWithRelationInput | StadiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stadiums.
     */
    cursor?: StadiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stadiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stadiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stadiums.
     */
    distinct?: StadiumScalarFieldEnum | StadiumScalarFieldEnum[]
  }

  /**
   * Stadium findMany
   */
  export type StadiumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter, which Stadiums to fetch.
     */
    where?: StadiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stadiums to fetch.
     */
    orderBy?: StadiumOrderByWithRelationInput | StadiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stadiums.
     */
    cursor?: StadiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stadiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stadiums.
     */
    skip?: number
    distinct?: StadiumScalarFieldEnum | StadiumScalarFieldEnum[]
  }

  /**
   * Stadium create
   */
  export type StadiumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * The data needed to create a Stadium.
     */
    data: XOR<StadiumCreateInput, StadiumUncheckedCreateInput>
  }

  /**
   * Stadium createMany
   */
  export type StadiumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stadiums.
     */
    data: StadiumCreateManyInput | StadiumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stadium createManyAndReturn
   */
  export type StadiumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * The data used to create many Stadiums.
     */
    data: StadiumCreateManyInput | StadiumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stadium update
   */
  export type StadiumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * The data needed to update a Stadium.
     */
    data: XOR<StadiumUpdateInput, StadiumUncheckedUpdateInput>
    /**
     * Choose, which Stadium to update.
     */
    where: StadiumWhereUniqueInput
  }

  /**
   * Stadium updateMany
   */
  export type StadiumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stadiums.
     */
    data: XOR<StadiumUpdateManyMutationInput, StadiumUncheckedUpdateManyInput>
    /**
     * Filter which Stadiums to update
     */
    where?: StadiumWhereInput
    /**
     * Limit how many Stadiums to update.
     */
    limit?: number
  }

  /**
   * Stadium updateManyAndReturn
   */
  export type StadiumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * The data used to update Stadiums.
     */
    data: XOR<StadiumUpdateManyMutationInput, StadiumUncheckedUpdateManyInput>
    /**
     * Filter which Stadiums to update
     */
    where?: StadiumWhereInput
    /**
     * Limit how many Stadiums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stadium upsert
   */
  export type StadiumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * The filter to search for the Stadium to update in case it exists.
     */
    where: StadiumWhereUniqueInput
    /**
     * In case the Stadium found by the `where` argument doesn't exist, create a new Stadium with this data.
     */
    create: XOR<StadiumCreateInput, StadiumUncheckedCreateInput>
    /**
     * In case the Stadium was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StadiumUpdateInput, StadiumUncheckedUpdateInput>
  }

  /**
   * Stadium delete
   */
  export type StadiumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
    /**
     * Filter which Stadium to delete.
     */
    where: StadiumWhereUniqueInput
  }

  /**
   * Stadium deleteMany
   */
  export type StadiumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stadiums to delete
     */
    where?: StadiumWhereInput
    /**
     * Limit how many Stadiums to delete.
     */
    limit?: number
  }

  /**
   * Stadium without action
   */
  export type StadiumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stadium
     */
    select?: StadiumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stadium
     */
    omit?: StadiumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StadiumInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    creditPrice: number | null
    gemPrice: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    creditPrice: bigint | null
    gemPrice: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    slot: $Enums.EquipmentSlot | null
    raceRestriction: $Enums.Race | null
    rarity: $Enums.ItemRarity | null
    creditPrice: bigint | null
    gemPrice: number | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    slot: $Enums.EquipmentSlot | null
    raceRestriction: $Enums.Race | null
    rarity: $Enums.ItemRarity | null
    creditPrice: bigint | null
    gemPrice: number | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    slot: number
    raceRestriction: number
    statEffects: number
    rarity: number
    creditPrice: number
    gemPrice: number
    effectValue: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    creditPrice?: true
    gemPrice?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    creditPrice?: true
    gemPrice?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    slot?: true
    raceRestriction?: true
    rarity?: true
    creditPrice?: true
    gemPrice?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    slot?: true
    raceRestriction?: true
    rarity?: true
    creditPrice?: true
    gemPrice?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    slot?: true
    raceRestriction?: true
    statEffects?: true
    rarity?: true
    creditPrice?: true
    gemPrice?: true
    effectValue?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    name: string
    description: string
    type: $Enums.ItemType
    slot: $Enums.EquipmentSlot | null
    raceRestriction: $Enums.Race | null
    statEffects: JsonValue | null
    rarity: $Enums.ItemRarity
    creditPrice: bigint | null
    gemPrice: number | null
    effectValue: JsonValue | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    slot?: boolean
    raceRestriction?: boolean
    statEffects?: boolean
    rarity?: boolean
    creditPrice?: boolean
    gemPrice?: boolean
    effectValue?: boolean
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    activeBoosts?: boolean | Item$activeBoostsArgs<ExtArgs>
    PlayerEquipment?: boolean | Item$PlayerEquipmentArgs<ExtArgs>
    PremiumBoxRewards?: boolean | Item$PremiumBoxRewardsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    slot?: boolean
    raceRestriction?: boolean
    statEffects?: boolean
    rarity?: boolean
    creditPrice?: boolean
    gemPrice?: boolean
    effectValue?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    slot?: boolean
    raceRestriction?: boolean
    statEffects?: boolean
    rarity?: boolean
    creditPrice?: boolean
    gemPrice?: boolean
    effectValue?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    slot?: boolean
    raceRestriction?: boolean
    statEffects?: boolean
    rarity?: boolean
    creditPrice?: boolean
    gemPrice?: boolean
    effectValue?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "slot" | "raceRestriction" | "statEffects" | "rarity" | "creditPrice" | "gemPrice" | "effectValue", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    activeBoosts?: boolean | Item$activeBoostsArgs<ExtArgs>
    PlayerEquipment?: boolean | Item$PlayerEquipmentArgs<ExtArgs>
    PremiumBoxRewards?: boolean | Item$PremiumBoxRewardsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      activeBoosts: Prisma.$ActiveBoostPayload<ExtArgs>[]
      PlayerEquipment: Prisma.$PlayerEquipmentPayload<ExtArgs>[]
      PremiumBoxRewards: Prisma.$EquipmentRewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      type: $Enums.ItemType
      slot: $Enums.EquipmentSlot | null
      raceRestriction: $Enums.Race | null
      statEffects: Prisma.JsonValue | null
      rarity: $Enums.ItemRarity
      creditPrice: bigint | null
      gemPrice: number | null
      effectValue: Prisma.JsonValue | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Item$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activeBoosts<T extends Item$activeBoostsArgs<ExtArgs> = {}>(args?: Subset<T, Item$activeBoostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PlayerEquipment<T extends Item$PlayerEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Item$PlayerEquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PremiumBoxRewards<T extends Item$PremiumBoxRewardsArgs<ExtArgs> = {}>(args?: Subset<T, Item$PremiumBoxRewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly slot: FieldRef<"Item", 'EquipmentSlot'>
    readonly raceRestriction: FieldRef<"Item", 'Race'>
    readonly statEffects: FieldRef<"Item", 'Json'>
    readonly rarity: FieldRef<"Item", 'ItemRarity'>
    readonly creditPrice: FieldRef<"Item", 'BigInt'>
    readonly gemPrice: FieldRef<"Item", 'Int'>
    readonly effectValue: FieldRef<"Item", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.inventoryItems
   */
  export type Item$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Item.activeBoosts
   */
  export type Item$activeBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    where?: ActiveBoostWhereInput
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    cursor?: ActiveBoostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * Item.PlayerEquipment
   */
  export type Item$PlayerEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEquipment
     */
    select?: PlayerEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerEquipment
     */
    omit?: PlayerEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEquipmentInclude<ExtArgs> | null
    where?: PlayerEquipmentWhereInput
    orderBy?: PlayerEquipmentOrderByWithRelationInput | PlayerEquipmentOrderByWithRelationInput[]
    cursor?: PlayerEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEquipmentScalarFieldEnum | PlayerEquipmentScalarFieldEnum[]
  }

  /**
   * Item.PremiumBoxRewards
   */
  export type Item$PremiumBoxRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    where?: EquipmentRewardWhereInput
    orderBy?: EquipmentRewardOrderByWithRelationInput | EquipmentRewardOrderByWithRelationInput[]
    cursor?: EquipmentRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentRewardScalarFieldEnum | EquipmentRewardScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    itemId: number | null
    quantity: number | null
    acquiredAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    itemId: number | null
    quantity: number | null
    acquiredAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    teamId: number
    itemId: number
    quantity: number
    acquiredAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    id?: true
    teamId?: true
    itemId?: true
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    id?: true
    teamId?: true
    itemId?: true
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    teamId?: true
    itemId?: true
    quantity?: true
    acquiredAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    teamId?: true
    itemId?: true
    quantity?: true
    acquiredAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    teamId?: true
    itemId?: true
    quantity?: true
    acquiredAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: number
    teamId: number
    itemId: number
    quantity: number
    acquiredAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    itemId?: boolean
    quantity?: boolean
    acquiredAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    itemId?: boolean
    quantity?: boolean
    acquiredAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    itemId?: boolean
    quantity?: boolean
    acquiredAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    teamId?: boolean
    itemId?: boolean
    quantity?: boolean
    acquiredAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "itemId" | "quantity" | "acquiredAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      itemId: number
      quantity: number
      acquiredAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'Int'>
    readonly teamId: FieldRef<"InventoryItem", 'Int'>
    readonly itemId: FieldRef<"InventoryItem", 'Int'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly acquiredAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model ActiveBoost
   */

  export type AggregateActiveBoost = {
    _count: ActiveBoostCountAggregateOutputType | null
    _avg: ActiveBoostAvgAggregateOutputType | null
    _sum: ActiveBoostSumAggregateOutputType | null
    _min: ActiveBoostMinAggregateOutputType | null
    _max: ActiveBoostMaxAggregateOutputType | null
  }

  export type ActiveBoostAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    itemId: number | null
  }

  export type ActiveBoostSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    itemId: number | null
  }

  export type ActiveBoostMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    itemId: number | null
    matchType: $Enums.MatchType | null
    isActive: boolean | null
    appliedAt: Date | null
  }

  export type ActiveBoostMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    playerId: number | null
    itemId: number | null
    matchType: $Enums.MatchType | null
    isActive: boolean | null
    appliedAt: Date | null
  }

  export type ActiveBoostCountAggregateOutputType = {
    id: number
    teamId: number
    playerId: number
    itemId: number
    matchType: number
    isActive: number
    appliedAt: number
    _all: number
  }


  export type ActiveBoostAvgAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    itemId?: true
  }

  export type ActiveBoostSumAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    itemId?: true
  }

  export type ActiveBoostMinAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    itemId?: true
    matchType?: true
    isActive?: true
    appliedAt?: true
  }

  export type ActiveBoostMaxAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    itemId?: true
    matchType?: true
    isActive?: true
    appliedAt?: true
  }

  export type ActiveBoostCountAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    itemId?: true
    matchType?: true
    isActive?: true
    appliedAt?: true
    _all?: true
  }

  export type ActiveBoostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveBoost to aggregate.
     */
    where?: ActiveBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveBoosts to fetch.
     */
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiveBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiveBoosts
    **/
    _count?: true | ActiveBoostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActiveBoostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActiveBoostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiveBoostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiveBoostMaxAggregateInputType
  }

  export type GetActiveBoostAggregateType<T extends ActiveBoostAggregateArgs> = {
        [P in keyof T & keyof AggregateActiveBoost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiveBoost[P]>
      : GetScalarType<T[P], AggregateActiveBoost[P]>
  }




  export type ActiveBoostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveBoostWhereInput
    orderBy?: ActiveBoostOrderByWithAggregationInput | ActiveBoostOrderByWithAggregationInput[]
    by: ActiveBoostScalarFieldEnum[] | ActiveBoostScalarFieldEnum
    having?: ActiveBoostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiveBoostCountAggregateInputType | true
    _avg?: ActiveBoostAvgAggregateInputType
    _sum?: ActiveBoostSumAggregateInputType
    _min?: ActiveBoostMinAggregateInputType
    _max?: ActiveBoostMaxAggregateInputType
  }

  export type ActiveBoostGroupByOutputType = {
    id: number
    teamId: number
    playerId: number | null
    itemId: number
    matchType: $Enums.MatchType
    isActive: boolean
    appliedAt: Date
    _count: ActiveBoostCountAggregateOutputType | null
    _avg: ActiveBoostAvgAggregateOutputType | null
    _sum: ActiveBoostSumAggregateOutputType | null
    _min: ActiveBoostMinAggregateOutputType | null
    _max: ActiveBoostMaxAggregateOutputType | null
  }

  type GetActiveBoostGroupByPayload<T extends ActiveBoostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiveBoostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiveBoostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiveBoostGroupByOutputType[P]>
            : GetScalarType<T[P], ActiveBoostGroupByOutputType[P]>
        }
      >
    >


  export type ActiveBoostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    itemId?: boolean
    matchType?: boolean
    isActive?: boolean
    appliedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeBoost"]>

  export type ActiveBoostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    itemId?: boolean
    matchType?: boolean
    isActive?: boolean
    appliedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeBoost"]>

  export type ActiveBoostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    itemId?: boolean
    matchType?: boolean
    isActive?: boolean
    appliedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeBoost"]>

  export type ActiveBoostSelectScalar = {
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    itemId?: boolean
    matchType?: boolean
    isActive?: boolean
    appliedAt?: boolean
  }

  export type ActiveBoostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "playerId" | "itemId" | "matchType" | "isActive" | "appliedAt", ExtArgs["result"]["activeBoost"]>
  export type ActiveBoostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ActiveBoostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ActiveBoostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | ActiveBoost$playerArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ActiveBoostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiveBoost"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs> | null
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      playerId: number | null
      itemId: number
      matchType: $Enums.MatchType
      isActive: boolean
      appliedAt: Date
    }, ExtArgs["result"]["activeBoost"]>
    composites: {}
  }

  type ActiveBoostGetPayload<S extends boolean | null | undefined | ActiveBoostDefaultArgs> = $Result.GetResult<Prisma.$ActiveBoostPayload, S>

  type ActiveBoostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActiveBoostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActiveBoostCountAggregateInputType | true
    }

  export interface ActiveBoostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiveBoost'], meta: { name: 'ActiveBoost' } }
    /**
     * Find zero or one ActiveBoost that matches the filter.
     * @param {ActiveBoostFindUniqueArgs} args - Arguments to find a ActiveBoost
     * @example
     * // Get one ActiveBoost
     * const activeBoost = await prisma.activeBoost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiveBoostFindUniqueArgs>(args: SelectSubset<T, ActiveBoostFindUniqueArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActiveBoost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActiveBoostFindUniqueOrThrowArgs} args - Arguments to find a ActiveBoost
     * @example
     * // Get one ActiveBoost
     * const activeBoost = await prisma.activeBoost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiveBoostFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiveBoostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveBoost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostFindFirstArgs} args - Arguments to find a ActiveBoost
     * @example
     * // Get one ActiveBoost
     * const activeBoost = await prisma.activeBoost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiveBoostFindFirstArgs>(args?: SelectSubset<T, ActiveBoostFindFirstArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveBoost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostFindFirstOrThrowArgs} args - Arguments to find a ActiveBoost
     * @example
     * // Get one ActiveBoost
     * const activeBoost = await prisma.activeBoost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiveBoostFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiveBoostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActiveBoosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiveBoosts
     * const activeBoosts = await prisma.activeBoost.findMany()
     * 
     * // Get first 10 ActiveBoosts
     * const activeBoosts = await prisma.activeBoost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activeBoostWithIdOnly = await prisma.activeBoost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActiveBoostFindManyArgs>(args?: SelectSubset<T, ActiveBoostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActiveBoost.
     * @param {ActiveBoostCreateArgs} args - Arguments to create a ActiveBoost.
     * @example
     * // Create one ActiveBoost
     * const ActiveBoost = await prisma.activeBoost.create({
     *   data: {
     *     // ... data to create a ActiveBoost
     *   }
     * })
     * 
     */
    create<T extends ActiveBoostCreateArgs>(args: SelectSubset<T, ActiveBoostCreateArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActiveBoosts.
     * @param {ActiveBoostCreateManyArgs} args - Arguments to create many ActiveBoosts.
     * @example
     * // Create many ActiveBoosts
     * const activeBoost = await prisma.activeBoost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiveBoostCreateManyArgs>(args?: SelectSubset<T, ActiveBoostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActiveBoosts and returns the data saved in the database.
     * @param {ActiveBoostCreateManyAndReturnArgs} args - Arguments to create many ActiveBoosts.
     * @example
     * // Create many ActiveBoosts
     * const activeBoost = await prisma.activeBoost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActiveBoosts and only return the `id`
     * const activeBoostWithIdOnly = await prisma.activeBoost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActiveBoostCreateManyAndReturnArgs>(args?: SelectSubset<T, ActiveBoostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActiveBoost.
     * @param {ActiveBoostDeleteArgs} args - Arguments to delete one ActiveBoost.
     * @example
     * // Delete one ActiveBoost
     * const ActiveBoost = await prisma.activeBoost.delete({
     *   where: {
     *     // ... filter to delete one ActiveBoost
     *   }
     * })
     * 
     */
    delete<T extends ActiveBoostDeleteArgs>(args: SelectSubset<T, ActiveBoostDeleteArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActiveBoost.
     * @param {ActiveBoostUpdateArgs} args - Arguments to update one ActiveBoost.
     * @example
     * // Update one ActiveBoost
     * const activeBoost = await prisma.activeBoost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiveBoostUpdateArgs>(args: SelectSubset<T, ActiveBoostUpdateArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActiveBoosts.
     * @param {ActiveBoostDeleteManyArgs} args - Arguments to filter ActiveBoosts to delete.
     * @example
     * // Delete a few ActiveBoosts
     * const { count } = await prisma.activeBoost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiveBoostDeleteManyArgs>(args?: SelectSubset<T, ActiveBoostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveBoosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiveBoosts
     * const activeBoost = await prisma.activeBoost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiveBoostUpdateManyArgs>(args: SelectSubset<T, ActiveBoostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveBoosts and returns the data updated in the database.
     * @param {ActiveBoostUpdateManyAndReturnArgs} args - Arguments to update many ActiveBoosts.
     * @example
     * // Update many ActiveBoosts
     * const activeBoost = await prisma.activeBoost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActiveBoosts and only return the `id`
     * const activeBoostWithIdOnly = await prisma.activeBoost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActiveBoostUpdateManyAndReturnArgs>(args: SelectSubset<T, ActiveBoostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActiveBoost.
     * @param {ActiveBoostUpsertArgs} args - Arguments to update or create a ActiveBoost.
     * @example
     * // Update or create a ActiveBoost
     * const activeBoost = await prisma.activeBoost.upsert({
     *   create: {
     *     // ... data to create a ActiveBoost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiveBoost we want to update
     *   }
     * })
     */
    upsert<T extends ActiveBoostUpsertArgs>(args: SelectSubset<T, ActiveBoostUpsertArgs<ExtArgs>>): Prisma__ActiveBoostClient<$Result.GetResult<Prisma.$ActiveBoostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActiveBoosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostCountArgs} args - Arguments to filter ActiveBoosts to count.
     * @example
     * // Count the number of ActiveBoosts
     * const count = await prisma.activeBoost.count({
     *   where: {
     *     // ... the filter for the ActiveBoosts we want to count
     *   }
     * })
    **/
    count<T extends ActiveBoostCountArgs>(
      args?: Subset<T, ActiveBoostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiveBoostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiveBoost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiveBoostAggregateArgs>(args: Subset<T, ActiveBoostAggregateArgs>): Prisma.PrismaPromise<GetActiveBoostAggregateType<T>>

    /**
     * Group by ActiveBoost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveBoostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiveBoostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiveBoostGroupByArgs['orderBy'] }
        : { orderBy?: ActiveBoostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiveBoostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiveBoostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiveBoost model
   */
  readonly fields: ActiveBoostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiveBoost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiveBoostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends ActiveBoost$playerArgs<ExtArgs> = {}>(args?: Subset<T, ActiveBoost$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiveBoost model
   */
  interface ActiveBoostFieldRefs {
    readonly id: FieldRef<"ActiveBoost", 'Int'>
    readonly teamId: FieldRef<"ActiveBoost", 'Int'>
    readonly playerId: FieldRef<"ActiveBoost", 'Int'>
    readonly itemId: FieldRef<"ActiveBoost", 'Int'>
    readonly matchType: FieldRef<"ActiveBoost", 'MatchType'>
    readonly isActive: FieldRef<"ActiveBoost", 'Boolean'>
    readonly appliedAt: FieldRef<"ActiveBoost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActiveBoost findUnique
   */
  export type ActiveBoostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter, which ActiveBoost to fetch.
     */
    where: ActiveBoostWhereUniqueInput
  }

  /**
   * ActiveBoost findUniqueOrThrow
   */
  export type ActiveBoostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter, which ActiveBoost to fetch.
     */
    where: ActiveBoostWhereUniqueInput
  }

  /**
   * ActiveBoost findFirst
   */
  export type ActiveBoostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter, which ActiveBoost to fetch.
     */
    where?: ActiveBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveBoosts to fetch.
     */
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveBoosts.
     */
    cursor?: ActiveBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveBoosts.
     */
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * ActiveBoost findFirstOrThrow
   */
  export type ActiveBoostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter, which ActiveBoost to fetch.
     */
    where?: ActiveBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveBoosts to fetch.
     */
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveBoosts.
     */
    cursor?: ActiveBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveBoosts.
     */
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * ActiveBoost findMany
   */
  export type ActiveBoostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter, which ActiveBoosts to fetch.
     */
    where?: ActiveBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveBoosts to fetch.
     */
    orderBy?: ActiveBoostOrderByWithRelationInput | ActiveBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiveBoosts.
     */
    cursor?: ActiveBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveBoosts.
     */
    skip?: number
    distinct?: ActiveBoostScalarFieldEnum | ActiveBoostScalarFieldEnum[]
  }

  /**
   * ActiveBoost create
   */
  export type ActiveBoostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * The data needed to create a ActiveBoost.
     */
    data: XOR<ActiveBoostCreateInput, ActiveBoostUncheckedCreateInput>
  }

  /**
   * ActiveBoost createMany
   */
  export type ActiveBoostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiveBoosts.
     */
    data: ActiveBoostCreateManyInput | ActiveBoostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiveBoost createManyAndReturn
   */
  export type ActiveBoostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * The data used to create many ActiveBoosts.
     */
    data: ActiveBoostCreateManyInput | ActiveBoostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActiveBoost update
   */
  export type ActiveBoostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * The data needed to update a ActiveBoost.
     */
    data: XOR<ActiveBoostUpdateInput, ActiveBoostUncheckedUpdateInput>
    /**
     * Choose, which ActiveBoost to update.
     */
    where: ActiveBoostWhereUniqueInput
  }

  /**
   * ActiveBoost updateMany
   */
  export type ActiveBoostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiveBoosts.
     */
    data: XOR<ActiveBoostUpdateManyMutationInput, ActiveBoostUncheckedUpdateManyInput>
    /**
     * Filter which ActiveBoosts to update
     */
    where?: ActiveBoostWhereInput
    /**
     * Limit how many ActiveBoosts to update.
     */
    limit?: number
  }

  /**
   * ActiveBoost updateManyAndReturn
   */
  export type ActiveBoostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * The data used to update ActiveBoosts.
     */
    data: XOR<ActiveBoostUpdateManyMutationInput, ActiveBoostUncheckedUpdateManyInput>
    /**
     * Filter which ActiveBoosts to update
     */
    where?: ActiveBoostWhereInput
    /**
     * Limit how many ActiveBoosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActiveBoost upsert
   */
  export type ActiveBoostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * The filter to search for the ActiveBoost to update in case it exists.
     */
    where: ActiveBoostWhereUniqueInput
    /**
     * In case the ActiveBoost found by the `where` argument doesn't exist, create a new ActiveBoost with this data.
     */
    create: XOR<ActiveBoostCreateInput, ActiveBoostUncheckedCreateInput>
    /**
     * In case the ActiveBoost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiveBoostUpdateInput, ActiveBoostUncheckedUpdateInput>
  }

  /**
   * ActiveBoost delete
   */
  export type ActiveBoostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
    /**
     * Filter which ActiveBoost to delete.
     */
    where: ActiveBoostWhereUniqueInput
  }

  /**
   * ActiveBoost deleteMany
   */
  export type ActiveBoostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveBoosts to delete
     */
    where?: ActiveBoostWhereInput
    /**
     * Limit how many ActiveBoosts to delete.
     */
    limit?: number
  }

  /**
   * ActiveBoost.player
   */
  export type ActiveBoost$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * ActiveBoost without action
   */
  export type ActiveBoostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveBoost
     */
    select?: ActiveBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveBoost
     */
    omit?: ActiveBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveBoostInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceListing
   */

  export type AggregateMarketplaceListing = {
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  export type MarketplaceListingAvgAggregateOutputType = {
    id: number | null
    playerId: number | null
    sellerTeamId: number | null
    startBid: number | null
    buyNowPrice: number | null
    minBuyNowPrice: number | null
    currentBid: number | null
    currentHighBidderTeamId: number | null
    auctionExtensions: number | null
    listingFee: number | null
    marketTaxRate: number | null
    escrowAmount: number | null
  }

  export type MarketplaceListingSumAggregateOutputType = {
    id: number | null
    playerId: number | null
    sellerTeamId: number | null
    startBid: bigint | null
    buyNowPrice: bigint | null
    minBuyNowPrice: bigint | null
    currentBid: bigint | null
    currentHighBidderTeamId: number | null
    auctionExtensions: number | null
    listingFee: bigint | null
    marketTaxRate: number | null
    escrowAmount: bigint | null
  }

  export type MarketplaceListingMinAggregateOutputType = {
    id: number | null
    playerId: number | null
    sellerTeamId: number | null
    startBid: bigint | null
    buyNowPrice: bigint | null
    minBuyNowPrice: bigint | null
    currentBid: bigint | null
    currentHighBidderTeamId: number | null
    expiryTimestamp: Date | null
    originalExpiryTimestamp: Date | null
    auctionExtensions: number | null
    listingFee: bigint | null
    marketTaxRate: number | null
    escrowAmount: bigint | null
    listingStatus: $Enums.MarketplaceStatus | null
    isOffSeasonConverted: boolean | null
    autoDelistAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingMaxAggregateOutputType = {
    id: number | null
    playerId: number | null
    sellerTeamId: number | null
    startBid: bigint | null
    buyNowPrice: bigint | null
    minBuyNowPrice: bigint | null
    currentBid: bigint | null
    currentHighBidderTeamId: number | null
    expiryTimestamp: Date | null
    originalExpiryTimestamp: Date | null
    auctionExtensions: number | null
    listingFee: bigint | null
    marketTaxRate: number | null
    escrowAmount: bigint | null
    listingStatus: $Enums.MarketplaceStatus | null
    isOffSeasonConverted: boolean | null
    autoDelistAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingCountAggregateOutputType = {
    id: number
    playerId: number
    sellerTeamId: number
    startBid: number
    buyNowPrice: number
    minBuyNowPrice: number
    currentBid: number
    currentHighBidderTeamId: number
    expiryTimestamp: number
    originalExpiryTimestamp: number
    auctionExtensions: number
    listingFee: number
    marketTaxRate: number
    escrowAmount: number
    listingStatus: number
    isOffSeasonConverted: number
    autoDelistAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceListingAvgAggregateInputType = {
    id?: true
    playerId?: true
    sellerTeamId?: true
    startBid?: true
    buyNowPrice?: true
    minBuyNowPrice?: true
    currentBid?: true
    currentHighBidderTeamId?: true
    auctionExtensions?: true
    listingFee?: true
    marketTaxRate?: true
    escrowAmount?: true
  }

  export type MarketplaceListingSumAggregateInputType = {
    id?: true
    playerId?: true
    sellerTeamId?: true
    startBid?: true
    buyNowPrice?: true
    minBuyNowPrice?: true
    currentBid?: true
    currentHighBidderTeamId?: true
    auctionExtensions?: true
    listingFee?: true
    marketTaxRate?: true
    escrowAmount?: true
  }

  export type MarketplaceListingMinAggregateInputType = {
    id?: true
    playerId?: true
    sellerTeamId?: true
    startBid?: true
    buyNowPrice?: true
    minBuyNowPrice?: true
    currentBid?: true
    currentHighBidderTeamId?: true
    expiryTimestamp?: true
    originalExpiryTimestamp?: true
    auctionExtensions?: true
    listingFee?: true
    marketTaxRate?: true
    escrowAmount?: true
    listingStatus?: true
    isOffSeasonConverted?: true
    autoDelistAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingMaxAggregateInputType = {
    id?: true
    playerId?: true
    sellerTeamId?: true
    startBid?: true
    buyNowPrice?: true
    minBuyNowPrice?: true
    currentBid?: true
    currentHighBidderTeamId?: true
    expiryTimestamp?: true
    originalExpiryTimestamp?: true
    auctionExtensions?: true
    listingFee?: true
    marketTaxRate?: true
    escrowAmount?: true
    listingStatus?: true
    isOffSeasonConverted?: true
    autoDelistAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingCountAggregateInputType = {
    id?: true
    playerId?: true
    sellerTeamId?: true
    startBid?: true
    buyNowPrice?: true
    minBuyNowPrice?: true
    currentBid?: true
    currentHighBidderTeamId?: true
    expiryTimestamp?: true
    originalExpiryTimestamp?: true
    auctionExtensions?: true
    listingFee?: true
    marketTaxRate?: true
    escrowAmount?: true
    listingStatus?: true
    isOffSeasonConverted?: true
    autoDelistAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListing to aggregate.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceListings
    **/
    _count?: true | MarketplaceListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type GetMarketplaceListingAggregateType<T extends MarketplaceListingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceListing[P]>
      : GetScalarType<T[P], AggregateMarketplaceListing[P]>
  }




  export type MarketplaceListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithAggregationInput | MarketplaceListingOrderByWithAggregationInput[]
    by: MarketplaceListingScalarFieldEnum[] | MarketplaceListingScalarFieldEnum
    having?: MarketplaceListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceListingCountAggregateInputType | true
    _avg?: MarketplaceListingAvgAggregateInputType
    _sum?: MarketplaceListingSumAggregateInputType
    _min?: MarketplaceListingMinAggregateInputType
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type MarketplaceListingGroupByOutputType = {
    id: number
    playerId: number
    sellerTeamId: number
    startBid: bigint
    buyNowPrice: bigint | null
    minBuyNowPrice: bigint
    currentBid: bigint | null
    currentHighBidderTeamId: number | null
    expiryTimestamp: Date
    originalExpiryTimestamp: Date
    auctionExtensions: number
    listingFee: bigint
    marketTaxRate: number
    escrowAmount: bigint
    listingStatus: $Enums.MarketplaceStatus
    isOffSeasonConverted: boolean
    autoDelistAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  type GetMarketplaceListingGroupByPayload<T extends MarketplaceListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    sellerTeamId?: boolean
    startBid?: boolean
    buyNowPrice?: boolean
    minBuyNowPrice?: boolean
    currentBid?: boolean
    currentHighBidderTeamId?: boolean
    expiryTimestamp?: boolean
    originalExpiryTimestamp?: boolean
    auctionExtensions?: boolean
    listingFee?: boolean
    marketTaxRate?: boolean
    escrowAmount?: boolean
    listingStatus?: boolean
    isOffSeasonConverted?: boolean
    autoDelistAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
    bids?: boolean | MarketplaceListing$bidsArgs<ExtArgs>
    history?: boolean | MarketplaceListing$historyArgs<ExtArgs>
    _count?: boolean | MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    sellerTeamId?: boolean
    startBid?: boolean
    buyNowPrice?: boolean
    minBuyNowPrice?: boolean
    currentBid?: boolean
    currentHighBidderTeamId?: boolean
    expiryTimestamp?: boolean
    originalExpiryTimestamp?: boolean
    auctionExtensions?: boolean
    listingFee?: boolean
    marketTaxRate?: boolean
    escrowAmount?: boolean
    listingStatus?: boolean
    isOffSeasonConverted?: boolean
    autoDelistAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    sellerTeamId?: boolean
    startBid?: boolean
    buyNowPrice?: boolean
    minBuyNowPrice?: boolean
    currentBid?: boolean
    currentHighBidderTeamId?: boolean
    expiryTimestamp?: boolean
    originalExpiryTimestamp?: boolean
    auctionExtensions?: boolean
    listingFee?: boolean
    marketTaxRate?: boolean
    escrowAmount?: boolean
    listingStatus?: boolean
    isOffSeasonConverted?: boolean
    autoDelistAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectScalar = {
    id?: boolean
    playerId?: boolean
    sellerTeamId?: boolean
    startBid?: boolean
    buyNowPrice?: boolean
    minBuyNowPrice?: boolean
    currentBid?: boolean
    currentHighBidderTeamId?: boolean
    expiryTimestamp?: boolean
    originalExpiryTimestamp?: boolean
    auctionExtensions?: boolean
    listingFee?: boolean
    marketTaxRate?: boolean
    escrowAmount?: boolean
    listingStatus?: boolean
    isOffSeasonConverted?: boolean
    autoDelistAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "sellerTeamId" | "startBid" | "buyNowPrice" | "minBuyNowPrice" | "currentBid" | "currentHighBidderTeamId" | "expiryTimestamp" | "originalExpiryTimestamp" | "auctionExtensions" | "listingFee" | "marketTaxRate" | "escrowAmount" | "listingStatus" | "isOffSeasonConverted" | "autoDelistAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["marketplaceListing"]>
  export type MarketplaceListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
    bids?: boolean | MarketplaceListing$bidsArgs<ExtArgs>
    history?: boolean | MarketplaceListing$historyArgs<ExtArgs>
    _count?: boolean | MarketplaceListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    sellerTeam?: boolean | TeamDefaultArgs<ExtArgs>
    currentHighBidderTeam?: boolean | MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>
  }

  export type $MarketplaceListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceListing"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      sellerTeam: Prisma.$TeamPayload<ExtArgs>
      currentHighBidderTeam: Prisma.$TeamPayload<ExtArgs> | null
      bids: Prisma.$BidPayload<ExtArgs>[]
      history: Prisma.$ListingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      playerId: number
      sellerTeamId: number
      startBid: bigint
      buyNowPrice: bigint | null
      minBuyNowPrice: bigint
      currentBid: bigint | null
      currentHighBidderTeamId: number | null
      expiryTimestamp: Date
      originalExpiryTimestamp: Date
      auctionExtensions: number
      listingFee: bigint
      marketTaxRate: number
      escrowAmount: bigint
      listingStatus: $Enums.MarketplaceStatus
      isOffSeasonConverted: boolean
      autoDelistAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceListing"]>
    composites: {}
  }

  type MarketplaceListingGetPayload<S extends boolean | null | undefined | MarketplaceListingDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceListingPayload, S>

  type MarketplaceListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketplaceListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketplaceListingCountAggregateInputType | true
    }

  export interface MarketplaceListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceListing'], meta: { name: 'MarketplaceListing' } }
    /**
     * Find zero or one MarketplaceListing that matches the filter.
     * @param {MarketplaceListingFindUniqueArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceListingFindUniqueArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketplaceListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketplaceListingFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceListingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceListingFindFirstArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceListingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketplaceListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany()
     * 
     * // Get first 10 MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceListingFindManyArgs>(args?: SelectSubset<T, MarketplaceListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketplaceListing.
     * @param {MarketplaceListingCreateArgs} args - Arguments to create a MarketplaceListing.
     * @example
     * // Create one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.create({
     *   data: {
     *     // ... data to create a MarketplaceListing
     *   }
     * })
     * 
     */
    create<T extends MarketplaceListingCreateArgs>(args: SelectSubset<T, MarketplaceListingCreateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketplaceListings.
     * @param {MarketplaceListingCreateManyArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceListingCreateManyArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceListings and returns the data saved in the database.
     * @param {MarketplaceListingCreateManyAndReturnArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceListingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketplaceListing.
     * @param {MarketplaceListingDeleteArgs} args - Arguments to delete one MarketplaceListing.
     * @example
     * // Delete one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceListing
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceListingDeleteArgs>(args: SelectSubset<T, MarketplaceListingDeleteArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketplaceListing.
     * @param {MarketplaceListingUpdateArgs} args - Arguments to update one MarketplaceListing.
     * @example
     * // Update one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceListingUpdateArgs>(args: SelectSubset<T, MarketplaceListingUpdateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketplaceListings.
     * @param {MarketplaceListingDeleteManyArgs} args - Arguments to filter MarketplaceListings to delete.
     * @example
     * // Delete a few MarketplaceListings
     * const { count } = await prisma.marketplaceListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceListingDeleteManyArgs>(args?: SelectSubset<T, MarketplaceListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceListingUpdateManyArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings and returns the data updated in the database.
     * @param {MarketplaceListingUpdateManyAndReturnArgs} args - Arguments to update many MarketplaceListings.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketplaceListingUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketplaceListing.
     * @param {MarketplaceListingUpsertArgs} args - Arguments to update or create a MarketplaceListing.
     * @example
     * // Update or create a MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.upsert({
     *   create: {
     *     // ... data to create a MarketplaceListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceListing we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceListingUpsertArgs>(args: SelectSubset<T, MarketplaceListingUpsertArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingCountArgs} args - Arguments to filter MarketplaceListings to count.
     * @example
     * // Count the number of MarketplaceListings
     * const count = await prisma.marketplaceListing.count({
     *   where: {
     *     // ... the filter for the MarketplaceListings we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceListingCountArgs>(
      args?: Subset<T, MarketplaceListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceListingAggregateArgs>(args: Subset<T, MarketplaceListingAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceListingAggregateType<T>>

    /**
     * Group by MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceListingGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceListing model
   */
  readonly fields: MarketplaceListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sellerTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentHighBidderTeam<T extends MarketplaceListing$currentHighBidderTeamArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListing$currentHighBidderTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bids<T extends MarketplaceListing$bidsArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListing$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends MarketplaceListing$historyArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListing$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceListing model
   */
  interface MarketplaceListingFieldRefs {
    readonly id: FieldRef<"MarketplaceListing", 'Int'>
    readonly playerId: FieldRef<"MarketplaceListing", 'Int'>
    readonly sellerTeamId: FieldRef<"MarketplaceListing", 'Int'>
    readonly startBid: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly buyNowPrice: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly minBuyNowPrice: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly currentBid: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly currentHighBidderTeamId: FieldRef<"MarketplaceListing", 'Int'>
    readonly expiryTimestamp: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly originalExpiryTimestamp: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly auctionExtensions: FieldRef<"MarketplaceListing", 'Int'>
    readonly listingFee: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly marketTaxRate: FieldRef<"MarketplaceListing", 'Float'>
    readonly escrowAmount: FieldRef<"MarketplaceListing", 'BigInt'>
    readonly listingStatus: FieldRef<"MarketplaceListing", 'MarketplaceStatus'>
    readonly isOffSeasonConverted: FieldRef<"MarketplaceListing", 'Boolean'>
    readonly autoDelistAt: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly isActive: FieldRef<"MarketplaceListing", 'Boolean'>
    readonly createdAt: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceListing findUnique
   */
  export type MarketplaceListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findUniqueOrThrow
   */
  export type MarketplaceListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findFirst
   */
  export type MarketplaceListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findFirstOrThrow
   */
  export type MarketplaceListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findMany
   */
  export type MarketplaceListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListings to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing create
   */
  export type MarketplaceListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceListing.
     */
    data: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
  }

  /**
   * MarketplaceListing createMany
   */
  export type MarketplaceListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceListing createManyAndReturn
   */
  export type MarketplaceListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing update
   */
  export type MarketplaceListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceListing.
     */
    data: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceListing to update.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing updateMany
   */
  export type MarketplaceListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
  }

  /**
   * MarketplaceListing updateManyAndReturn
   */
  export type MarketplaceListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing upsert
   */
  export type MarketplaceListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceListing to update in case it exists.
     */
    where: MarketplaceListingWhereUniqueInput
    /**
     * In case the MarketplaceListing found by the `where` argument doesn't exist, create a new MarketplaceListing with this data.
     */
    create: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
    /**
     * In case the MarketplaceListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
  }

  /**
   * MarketplaceListing delete
   */
  export type MarketplaceListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceListing to delete.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing deleteMany
   */
  export type MarketplaceListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListings to delete
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to delete.
     */
    limit?: number
  }

  /**
   * MarketplaceListing.currentHighBidderTeam
   */
  export type MarketplaceListing$currentHighBidderTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * MarketplaceListing.bids
   */
  export type MarketplaceListing$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * MarketplaceListing.history
   */
  export type MarketplaceListing$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    where?: ListingHistoryWhereInput
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    cursor?: ListingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingHistoryScalarFieldEnum | ListingHistoryScalarFieldEnum[]
  }

  /**
   * MarketplaceListing without action
   */
  export type MarketplaceListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
  }


  /**
   * Model Bid
   */

  export type AggregateBid = {
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  export type BidAvgAggregateOutputType = {
    id: number | null
    listingId: number | null
    bidderTeamId: number | null
    bidAmount: number | null
    escrowAmount: number | null
  }

  export type BidSumAggregateOutputType = {
    id: number | null
    listingId: number | null
    bidderTeamId: number | null
    bidAmount: bigint | null
    escrowAmount: bigint | null
  }

  export type BidMinAggregateOutputType = {
    id: number | null
    listingId: number | null
    bidderTeamId: number | null
    bidAmount: bigint | null
    escrowAmount: bigint | null
    isWinningBid: boolean | null
    isRefunded: boolean | null
    placedAt: Date | null
  }

  export type BidMaxAggregateOutputType = {
    id: number | null
    listingId: number | null
    bidderTeamId: number | null
    bidAmount: bigint | null
    escrowAmount: bigint | null
    isWinningBid: boolean | null
    isRefunded: boolean | null
    placedAt: Date | null
  }

  export type BidCountAggregateOutputType = {
    id: number
    listingId: number
    bidderTeamId: number
    bidAmount: number
    escrowAmount: number
    isWinningBid: number
    isRefunded: number
    placedAt: number
    _all: number
  }


  export type BidAvgAggregateInputType = {
    id?: true
    listingId?: true
    bidderTeamId?: true
    bidAmount?: true
    escrowAmount?: true
  }

  export type BidSumAggregateInputType = {
    id?: true
    listingId?: true
    bidderTeamId?: true
    bidAmount?: true
    escrowAmount?: true
  }

  export type BidMinAggregateInputType = {
    id?: true
    listingId?: true
    bidderTeamId?: true
    bidAmount?: true
    escrowAmount?: true
    isWinningBid?: true
    isRefunded?: true
    placedAt?: true
  }

  export type BidMaxAggregateInputType = {
    id?: true
    listingId?: true
    bidderTeamId?: true
    bidAmount?: true
    escrowAmount?: true
    isWinningBid?: true
    isRefunded?: true
    placedAt?: true
  }

  export type BidCountAggregateInputType = {
    id?: true
    listingId?: true
    bidderTeamId?: true
    bidAmount?: true
    escrowAmount?: true
    isWinningBid?: true
    isRefunded?: true
    placedAt?: true
    _all?: true
  }

  export type BidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bid to aggregate.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bids
    **/
    _count?: true | BidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidMaxAggregateInputType
  }

  export type GetBidAggregateType<T extends BidAggregateArgs> = {
        [P in keyof T & keyof AggregateBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBid[P]>
      : GetScalarType<T[P], AggregateBid[P]>
  }




  export type BidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
    orderBy?: BidOrderByWithAggregationInput | BidOrderByWithAggregationInput[]
    by: BidScalarFieldEnum[] | BidScalarFieldEnum
    having?: BidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidCountAggregateInputType | true
    _avg?: BidAvgAggregateInputType
    _sum?: BidSumAggregateInputType
    _min?: BidMinAggregateInputType
    _max?: BidMaxAggregateInputType
  }

  export type BidGroupByOutputType = {
    id: number
    listingId: number
    bidderTeamId: number
    bidAmount: bigint
    escrowAmount: bigint
    isWinningBid: boolean
    isRefunded: boolean
    placedAt: Date
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  type GetBidGroupByPayload<T extends BidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidGroupByOutputType[P]>
            : GetScalarType<T[P], BidGroupByOutputType[P]>
        }
      >
    >


  export type BidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderTeamId?: boolean
    bidAmount?: boolean
    escrowAmount?: boolean
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderTeamId?: boolean
    bidAmount?: boolean
    escrowAmount?: boolean
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    bidderTeamId?: boolean
    bidAmount?: boolean
    escrowAmount?: boolean
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectScalar = {
    id?: boolean
    listingId?: boolean
    bidderTeamId?: boolean
    bidAmount?: boolean
    escrowAmount?: boolean
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: boolean
  }

  export type BidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "bidderTeamId" | "bidAmount" | "escrowAmount" | "isWinningBid" | "isRefunded" | "placedAt", ExtArgs["result"]["bid"]>
  export type BidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type BidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type BidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    bidderTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $BidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bid"
    objects: {
      listing: Prisma.$MarketplaceListingPayload<ExtArgs>
      bidderTeam: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      listingId: number
      bidderTeamId: number
      bidAmount: bigint
      escrowAmount: bigint
      isWinningBid: boolean
      isRefunded: boolean
      placedAt: Date
    }, ExtArgs["result"]["bid"]>
    composites: {}
  }

  type BidGetPayload<S extends boolean | null | undefined | BidDefaultArgs> = $Result.GetResult<Prisma.$BidPayload, S>

  type BidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BidCountAggregateInputType | true
    }

  export interface BidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bid'], meta: { name: 'Bid' } }
    /**
     * Find zero or one Bid that matches the filter.
     * @param {BidFindUniqueArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidFindUniqueArgs>(args: SelectSubset<T, BidFindUniqueArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BidFindUniqueOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidFindUniqueOrThrowArgs>(args: SelectSubset<T, BidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidFindFirstArgs>(args?: SelectSubset<T, BidFindFirstArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidFindFirstOrThrowArgs>(args?: SelectSubset<T, BidFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bids
     * const bids = await prisma.bid.findMany()
     * 
     * // Get first 10 Bids
     * const bids = await prisma.bid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidWithIdOnly = await prisma.bid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidFindManyArgs>(args?: SelectSubset<T, BidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bid.
     * @param {BidCreateArgs} args - Arguments to create a Bid.
     * @example
     * // Create one Bid
     * const Bid = await prisma.bid.create({
     *   data: {
     *     // ... data to create a Bid
     *   }
     * })
     * 
     */
    create<T extends BidCreateArgs>(args: SelectSubset<T, BidCreateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bids.
     * @param {BidCreateManyArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidCreateManyArgs>(args?: SelectSubset<T, BidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bids and returns the data saved in the database.
     * @param {BidCreateManyAndReturnArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidCreateManyAndReturnArgs>(args?: SelectSubset<T, BidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bid.
     * @param {BidDeleteArgs} args - Arguments to delete one Bid.
     * @example
     * // Delete one Bid
     * const Bid = await prisma.bid.delete({
     *   where: {
     *     // ... filter to delete one Bid
     *   }
     * })
     * 
     */
    delete<T extends BidDeleteArgs>(args: SelectSubset<T, BidDeleteArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bid.
     * @param {BidUpdateArgs} args - Arguments to update one Bid.
     * @example
     * // Update one Bid
     * const bid = await prisma.bid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidUpdateArgs>(args: SelectSubset<T, BidUpdateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bids.
     * @param {BidDeleteManyArgs} args - Arguments to filter Bids to delete.
     * @example
     * // Delete a few Bids
     * const { count } = await prisma.bid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidDeleteManyArgs>(args?: SelectSubset<T, BidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidUpdateManyArgs>(args: SelectSubset<T, BidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids and returns the data updated in the database.
     * @param {BidUpdateManyAndReturnArgs} args - Arguments to update many Bids.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BidUpdateManyAndReturnArgs>(args: SelectSubset<T, BidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bid.
     * @param {BidUpsertArgs} args - Arguments to update or create a Bid.
     * @example
     * // Update or create a Bid
     * const bid = await prisma.bid.upsert({
     *   create: {
     *     // ... data to create a Bid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bid we want to update
     *   }
     * })
     */
    upsert<T extends BidUpsertArgs>(args: SelectSubset<T, BidUpsertArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidCountArgs} args - Arguments to filter Bids to count.
     * @example
     * // Count the number of Bids
     * const count = await prisma.bid.count({
     *   where: {
     *     // ... the filter for the Bids we want to count
     *   }
     * })
    **/
    count<T extends BidCountArgs>(
      args?: Subset<T, BidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidAggregateArgs>(args: Subset<T, BidAggregateArgs>): Prisma.PrismaPromise<GetBidAggregateType<T>>

    /**
     * Group by Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidGroupByArgs['orderBy'] }
        : { orderBy?: BidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bid model
   */
  readonly fields: BidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends MarketplaceListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListingDefaultArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bidderTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bid model
   */
  interface BidFieldRefs {
    readonly id: FieldRef<"Bid", 'Int'>
    readonly listingId: FieldRef<"Bid", 'Int'>
    readonly bidderTeamId: FieldRef<"Bid", 'Int'>
    readonly bidAmount: FieldRef<"Bid", 'BigInt'>
    readonly escrowAmount: FieldRef<"Bid", 'BigInt'>
    readonly isWinningBid: FieldRef<"Bid", 'Boolean'>
    readonly isRefunded: FieldRef<"Bid", 'Boolean'>
    readonly placedAt: FieldRef<"Bid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bid findUnique
   */
  export type BidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findUniqueOrThrow
   */
  export type BidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findFirst
   */
  export type BidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findFirstOrThrow
   */
  export type BidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findMany
   */
  export type BidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bids to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid create
   */
  export type BidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to create a Bid.
     */
    data: XOR<BidCreateInput, BidUncheckedCreateInput>
  }

  /**
   * Bid createMany
   */
  export type BidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bid createManyAndReturn
   */
  export type BidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid update
   */
  export type BidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to update a Bid.
     */
    data: XOR<BidUpdateInput, BidUncheckedUpdateInput>
    /**
     * Choose, which Bid to update.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid updateMany
   */
  export type BidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
  }

  /**
   * Bid updateManyAndReturn
   */
  export type BidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid upsert
   */
  export type BidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The filter to search for the Bid to update in case it exists.
     */
    where: BidWhereUniqueInput
    /**
     * In case the Bid found by the `where` argument doesn't exist, create a new Bid with this data.
     */
    create: XOR<BidCreateInput, BidUncheckedCreateInput>
    /**
     * In case the Bid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidUpdateInput, BidUncheckedUpdateInput>
  }

  /**
   * Bid delete
   */
  export type BidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter which Bid to delete.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid deleteMany
   */
  export type BidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bids to delete
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to delete.
     */
    limit?: number
  }

  /**
   * Bid without action
   */
  export type BidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
  }


  /**
   * Model ListingHistory
   */

  export type AggregateListingHistory = {
    _count: ListingHistoryCountAggregateOutputType | null
    _avg: ListingHistoryAvgAggregateOutputType | null
    _sum: ListingHistorySumAggregateOutputType | null
    _min: ListingHistoryMinAggregateOutputType | null
    _max: ListingHistoryMaxAggregateOutputType | null
  }

  export type ListingHistoryAvgAggregateOutputType = {
    id: number | null
    listingId: number | null
    teamId: number | null
    amount: number | null
    oldValue: number | null
    newValue: number | null
  }

  export type ListingHistorySumAggregateOutputType = {
    id: number | null
    listingId: number | null
    teamId: number | null
    amount: bigint | null
    oldValue: bigint | null
    newValue: bigint | null
  }

  export type ListingHistoryMinAggregateOutputType = {
    id: number | null
    listingId: number | null
    actionType: $Enums.ListingActionType | null
    teamId: number | null
    amount: bigint | null
    oldValue: bigint | null
    newValue: bigint | null
    description: string | null
    timestamp: Date | null
  }

  export type ListingHistoryMaxAggregateOutputType = {
    id: number | null
    listingId: number | null
    actionType: $Enums.ListingActionType | null
    teamId: number | null
    amount: bigint | null
    oldValue: bigint | null
    newValue: bigint | null
    description: string | null
    timestamp: Date | null
  }

  export type ListingHistoryCountAggregateOutputType = {
    id: number
    listingId: number
    actionType: number
    teamId: number
    amount: number
    oldValue: number
    newValue: number
    description: number
    timestamp: number
    _all: number
  }


  export type ListingHistoryAvgAggregateInputType = {
    id?: true
    listingId?: true
    teamId?: true
    amount?: true
    oldValue?: true
    newValue?: true
  }

  export type ListingHistorySumAggregateInputType = {
    id?: true
    listingId?: true
    teamId?: true
    amount?: true
    oldValue?: true
    newValue?: true
  }

  export type ListingHistoryMinAggregateInputType = {
    id?: true
    listingId?: true
    actionType?: true
    teamId?: true
    amount?: true
    oldValue?: true
    newValue?: true
    description?: true
    timestamp?: true
  }

  export type ListingHistoryMaxAggregateInputType = {
    id?: true
    listingId?: true
    actionType?: true
    teamId?: true
    amount?: true
    oldValue?: true
    newValue?: true
    description?: true
    timestamp?: true
  }

  export type ListingHistoryCountAggregateInputType = {
    id?: true
    listingId?: true
    actionType?: true
    teamId?: true
    amount?: true
    oldValue?: true
    newValue?: true
    description?: true
    timestamp?: true
    _all?: true
  }

  export type ListingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListingHistory to aggregate.
     */
    where?: ListingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListingHistories to fetch.
     */
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListingHistories
    **/
    _count?: true | ListingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingHistoryMaxAggregateInputType
  }

  export type GetListingHistoryAggregateType<T extends ListingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateListingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListingHistory[P]>
      : GetScalarType<T[P], AggregateListingHistory[P]>
  }




  export type ListingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingHistoryWhereInput
    orderBy?: ListingHistoryOrderByWithAggregationInput | ListingHistoryOrderByWithAggregationInput[]
    by: ListingHistoryScalarFieldEnum[] | ListingHistoryScalarFieldEnum
    having?: ListingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingHistoryCountAggregateInputType | true
    _avg?: ListingHistoryAvgAggregateInputType
    _sum?: ListingHistorySumAggregateInputType
    _min?: ListingHistoryMinAggregateInputType
    _max?: ListingHistoryMaxAggregateInputType
  }

  export type ListingHistoryGroupByOutputType = {
    id: number
    listingId: number
    actionType: $Enums.ListingActionType
    teamId: number | null
    amount: bigint | null
    oldValue: bigint | null
    newValue: bigint | null
    description: string | null
    timestamp: Date
    _count: ListingHistoryCountAggregateOutputType | null
    _avg: ListingHistoryAvgAggregateOutputType | null
    _sum: ListingHistorySumAggregateOutputType | null
    _min: ListingHistoryMinAggregateOutputType | null
    _max: ListingHistoryMaxAggregateOutputType | null
  }

  type GetListingHistoryGroupByPayload<T extends ListingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ListingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ListingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    actionType?: boolean
    teamId?: boolean
    amount?: boolean
    oldValue?: boolean
    newValue?: boolean
    description?: boolean
    timestamp?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }, ExtArgs["result"]["listingHistory"]>

  export type ListingHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    actionType?: boolean
    teamId?: boolean
    amount?: boolean
    oldValue?: boolean
    newValue?: boolean
    description?: boolean
    timestamp?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }, ExtArgs["result"]["listingHistory"]>

  export type ListingHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    actionType?: boolean
    teamId?: boolean
    amount?: boolean
    oldValue?: boolean
    newValue?: boolean
    description?: boolean
    timestamp?: boolean
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }, ExtArgs["result"]["listingHistory"]>

  export type ListingHistorySelectScalar = {
    id?: boolean
    listingId?: boolean
    actionType?: boolean
    teamId?: boolean
    amount?: boolean
    oldValue?: boolean
    newValue?: boolean
    description?: boolean
    timestamp?: boolean
  }

  export type ListingHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "actionType" | "teamId" | "amount" | "oldValue" | "newValue" | "description" | "timestamp", ExtArgs["result"]["listingHistory"]>
  export type ListingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }
  export type ListingHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }
  export type ListingHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | MarketplaceListingDefaultArgs<ExtArgs>
    team?: boolean | ListingHistory$teamArgs<ExtArgs>
  }

  export type $ListingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListingHistory"
    objects: {
      listing: Prisma.$MarketplaceListingPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      listingId: number
      actionType: $Enums.ListingActionType
      teamId: number | null
      amount: bigint | null
      oldValue: bigint | null
      newValue: bigint | null
      description: string | null
      timestamp: Date
    }, ExtArgs["result"]["listingHistory"]>
    composites: {}
  }

  type ListingHistoryGetPayload<S extends boolean | null | undefined | ListingHistoryDefaultArgs> = $Result.GetResult<Prisma.$ListingHistoryPayload, S>

  type ListingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListingHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListingHistoryCountAggregateInputType | true
    }

  export interface ListingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListingHistory'], meta: { name: 'ListingHistory' } }
    /**
     * Find zero or one ListingHistory that matches the filter.
     * @param {ListingHistoryFindUniqueArgs} args - Arguments to find a ListingHistory
     * @example
     * // Get one ListingHistory
     * const listingHistory = await prisma.listingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListingHistoryFindUniqueArgs>(args: SelectSubset<T, ListingHistoryFindUniqueArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListingHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListingHistoryFindUniqueOrThrowArgs} args - Arguments to find a ListingHistory
     * @example
     * // Get one ListingHistory
     * const listingHistory = await prisma.listingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListingHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ListingHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryFindFirstArgs} args - Arguments to find a ListingHistory
     * @example
     * // Get one ListingHistory
     * const listingHistory = await prisma.listingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListingHistoryFindFirstArgs>(args?: SelectSubset<T, ListingHistoryFindFirstArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryFindFirstOrThrowArgs} args - Arguments to find a ListingHistory
     * @example
     * // Get one ListingHistory
     * const listingHistory = await prisma.listingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListingHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ListingHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListingHistories
     * const listingHistories = await prisma.listingHistory.findMany()
     * 
     * // Get first 10 ListingHistories
     * const listingHistories = await prisma.listingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingHistoryWithIdOnly = await prisma.listingHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListingHistoryFindManyArgs>(args?: SelectSubset<T, ListingHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListingHistory.
     * @param {ListingHistoryCreateArgs} args - Arguments to create a ListingHistory.
     * @example
     * // Create one ListingHistory
     * const ListingHistory = await prisma.listingHistory.create({
     *   data: {
     *     // ... data to create a ListingHistory
     *   }
     * })
     * 
     */
    create<T extends ListingHistoryCreateArgs>(args: SelectSubset<T, ListingHistoryCreateArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListingHistories.
     * @param {ListingHistoryCreateManyArgs} args - Arguments to create many ListingHistories.
     * @example
     * // Create many ListingHistories
     * const listingHistory = await prisma.listingHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListingHistoryCreateManyArgs>(args?: SelectSubset<T, ListingHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListingHistories and returns the data saved in the database.
     * @param {ListingHistoryCreateManyAndReturnArgs} args - Arguments to create many ListingHistories.
     * @example
     * // Create many ListingHistories
     * const listingHistory = await prisma.listingHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListingHistories and only return the `id`
     * const listingHistoryWithIdOnly = await prisma.listingHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListingHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ListingHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListingHistory.
     * @param {ListingHistoryDeleteArgs} args - Arguments to delete one ListingHistory.
     * @example
     * // Delete one ListingHistory
     * const ListingHistory = await prisma.listingHistory.delete({
     *   where: {
     *     // ... filter to delete one ListingHistory
     *   }
     * })
     * 
     */
    delete<T extends ListingHistoryDeleteArgs>(args: SelectSubset<T, ListingHistoryDeleteArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListingHistory.
     * @param {ListingHistoryUpdateArgs} args - Arguments to update one ListingHistory.
     * @example
     * // Update one ListingHistory
     * const listingHistory = await prisma.listingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListingHistoryUpdateArgs>(args: SelectSubset<T, ListingHistoryUpdateArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListingHistories.
     * @param {ListingHistoryDeleteManyArgs} args - Arguments to filter ListingHistories to delete.
     * @example
     * // Delete a few ListingHistories
     * const { count } = await prisma.listingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListingHistoryDeleteManyArgs>(args?: SelectSubset<T, ListingHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListingHistories
     * const listingHistory = await prisma.listingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListingHistoryUpdateManyArgs>(args: SelectSubset<T, ListingHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListingHistories and returns the data updated in the database.
     * @param {ListingHistoryUpdateManyAndReturnArgs} args - Arguments to update many ListingHistories.
     * @example
     * // Update many ListingHistories
     * const listingHistory = await prisma.listingHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListingHistories and only return the `id`
     * const listingHistoryWithIdOnly = await prisma.listingHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListingHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ListingHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListingHistory.
     * @param {ListingHistoryUpsertArgs} args - Arguments to update or create a ListingHistory.
     * @example
     * // Update or create a ListingHistory
     * const listingHistory = await prisma.listingHistory.upsert({
     *   create: {
     *     // ... data to create a ListingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListingHistory we want to update
     *   }
     * })
     */
    upsert<T extends ListingHistoryUpsertArgs>(args: SelectSubset<T, ListingHistoryUpsertArgs<ExtArgs>>): Prisma__ListingHistoryClient<$Result.GetResult<Prisma.$ListingHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryCountArgs} args - Arguments to filter ListingHistories to count.
     * @example
     * // Count the number of ListingHistories
     * const count = await prisma.listingHistory.count({
     *   where: {
     *     // ... the filter for the ListingHistories we want to count
     *   }
     * })
    **/
    count<T extends ListingHistoryCountArgs>(
      args?: Subset<T, ListingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingHistoryAggregateArgs>(args: Subset<T, ListingHistoryAggregateArgs>): Prisma.PrismaPromise<GetListingHistoryAggregateType<T>>

    /**
     * Group by ListingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ListingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListingHistory model
   */
  readonly fields: ListingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends MarketplaceListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListingDefaultArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends ListingHistory$teamArgs<ExtArgs> = {}>(args?: Subset<T, ListingHistory$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListingHistory model
   */
  interface ListingHistoryFieldRefs {
    readonly id: FieldRef<"ListingHistory", 'Int'>
    readonly listingId: FieldRef<"ListingHistory", 'Int'>
    readonly actionType: FieldRef<"ListingHistory", 'ListingActionType'>
    readonly teamId: FieldRef<"ListingHistory", 'Int'>
    readonly amount: FieldRef<"ListingHistory", 'BigInt'>
    readonly oldValue: FieldRef<"ListingHistory", 'BigInt'>
    readonly newValue: FieldRef<"ListingHistory", 'BigInt'>
    readonly description: FieldRef<"ListingHistory", 'String'>
    readonly timestamp: FieldRef<"ListingHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListingHistory findUnique
   */
  export type ListingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListingHistory to fetch.
     */
    where: ListingHistoryWhereUniqueInput
  }

  /**
   * ListingHistory findUniqueOrThrow
   */
  export type ListingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListingHistory to fetch.
     */
    where: ListingHistoryWhereUniqueInput
  }

  /**
   * ListingHistory findFirst
   */
  export type ListingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListingHistory to fetch.
     */
    where?: ListingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListingHistories to fetch.
     */
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListingHistories.
     */
    cursor?: ListingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListingHistories.
     */
    distinct?: ListingHistoryScalarFieldEnum | ListingHistoryScalarFieldEnum[]
  }

  /**
   * ListingHistory findFirstOrThrow
   */
  export type ListingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListingHistory to fetch.
     */
    where?: ListingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListingHistories to fetch.
     */
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListingHistories.
     */
    cursor?: ListingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListingHistories.
     */
    distinct?: ListingHistoryScalarFieldEnum | ListingHistoryScalarFieldEnum[]
  }

  /**
   * ListingHistory findMany
   */
  export type ListingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListingHistories to fetch.
     */
    where?: ListingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListingHistories to fetch.
     */
    orderBy?: ListingHistoryOrderByWithRelationInput | ListingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListingHistories.
     */
    cursor?: ListingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListingHistories.
     */
    skip?: number
    distinct?: ListingHistoryScalarFieldEnum | ListingHistoryScalarFieldEnum[]
  }

  /**
   * ListingHistory create
   */
  export type ListingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ListingHistory.
     */
    data: XOR<ListingHistoryCreateInput, ListingHistoryUncheckedCreateInput>
  }

  /**
   * ListingHistory createMany
   */
  export type ListingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListingHistories.
     */
    data: ListingHistoryCreateManyInput | ListingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListingHistory createManyAndReturn
   */
  export type ListingHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ListingHistories.
     */
    data: ListingHistoryCreateManyInput | ListingHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListingHistory update
   */
  export type ListingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ListingHistory.
     */
    data: XOR<ListingHistoryUpdateInput, ListingHistoryUncheckedUpdateInput>
    /**
     * Choose, which ListingHistory to update.
     */
    where: ListingHistoryWhereUniqueInput
  }

  /**
   * ListingHistory updateMany
   */
  export type ListingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListingHistories.
     */
    data: XOR<ListingHistoryUpdateManyMutationInput, ListingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ListingHistories to update
     */
    where?: ListingHistoryWhereInput
    /**
     * Limit how many ListingHistories to update.
     */
    limit?: number
  }

  /**
   * ListingHistory updateManyAndReturn
   */
  export type ListingHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ListingHistories.
     */
    data: XOR<ListingHistoryUpdateManyMutationInput, ListingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ListingHistories to update
     */
    where?: ListingHistoryWhereInput
    /**
     * Limit how many ListingHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListingHistory upsert
   */
  export type ListingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ListingHistory to update in case it exists.
     */
    where: ListingHistoryWhereUniqueInput
    /**
     * In case the ListingHistory found by the `where` argument doesn't exist, create a new ListingHistory with this data.
     */
    create: XOR<ListingHistoryCreateInput, ListingHistoryUncheckedCreateInput>
    /**
     * In case the ListingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingHistoryUpdateInput, ListingHistoryUncheckedUpdateInput>
  }

  /**
   * ListingHistory delete
   */
  export type ListingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
    /**
     * Filter which ListingHistory to delete.
     */
    where: ListingHistoryWhereUniqueInput
  }

  /**
   * ListingHistory deleteMany
   */
  export type ListingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListingHistories to delete
     */
    where?: ListingHistoryWhereInput
    /**
     * Limit how many ListingHistories to delete.
     */
    limit?: number
  }

  /**
   * ListingHistory.team
   */
  export type ListingHistory$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * ListingHistory without action
   */
  export type ListingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingHistory
     */
    select?: ListingHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListingHistory
     */
    omit?: ListingHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PlayerMarketValue
   */

  export type AggregatePlayerMarketValue = {
    _count: PlayerMarketValueCountAggregateOutputType | null
    _avg: PlayerMarketValueAvgAggregateOutputType | null
    _sum: PlayerMarketValueSumAggregateOutputType | null
    _min: PlayerMarketValueMinAggregateOutputType | null
    _max: PlayerMarketValueMaxAggregateOutputType | null
  }

  export type PlayerMarketValueAvgAggregateOutputType = {
    id: number | null
    playerId: number | null
    carRating: number | null
    potential: number | null
    minBuyNow: number | null
    marketValue: number | null
  }

  export type PlayerMarketValueSumAggregateOutputType = {
    id: number | null
    playerId: number | null
    carRating: number | null
    potential: number | null
    minBuyNow: bigint | null
    marketValue: bigint | null
  }

  export type PlayerMarketValueMinAggregateOutputType = {
    id: number | null
    playerId: number | null
    carRating: number | null
    potential: number | null
    minBuyNow: bigint | null
    marketValue: bigint | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type PlayerMarketValueMaxAggregateOutputType = {
    id: number | null
    playerId: number | null
    carRating: number | null
    potential: number | null
    minBuyNow: bigint | null
    marketValue: bigint | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type PlayerMarketValueCountAggregateOutputType = {
    id: number
    playerId: number
    carRating: number
    potential: number
    minBuyNow: number
    marketValue: number
    lastUpdated: number
    createdAt: number
    _all: number
  }


  export type PlayerMarketValueAvgAggregateInputType = {
    id?: true
    playerId?: true
    carRating?: true
    potential?: true
    minBuyNow?: true
    marketValue?: true
  }

  export type PlayerMarketValueSumAggregateInputType = {
    id?: true
    playerId?: true
    carRating?: true
    potential?: true
    minBuyNow?: true
    marketValue?: true
  }

  export type PlayerMarketValueMinAggregateInputType = {
    id?: true
    playerId?: true
    carRating?: true
    potential?: true
    minBuyNow?: true
    marketValue?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type PlayerMarketValueMaxAggregateInputType = {
    id?: true
    playerId?: true
    carRating?: true
    potential?: true
    minBuyNow?: true
    marketValue?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type PlayerMarketValueCountAggregateInputType = {
    id?: true
    playerId?: true
    carRating?: true
    potential?: true
    minBuyNow?: true
    marketValue?: true
    lastUpdated?: true
    createdAt?: true
    _all?: true
  }

  export type PlayerMarketValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMarketValue to aggregate.
     */
    where?: PlayerMarketValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMarketValues to fetch.
     */
    orderBy?: PlayerMarketValueOrderByWithRelationInput | PlayerMarketValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerMarketValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMarketValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMarketValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerMarketValues
    **/
    _count?: true | PlayerMarketValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerMarketValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerMarketValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMarketValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMarketValueMaxAggregateInputType
  }

  export type GetPlayerMarketValueAggregateType<T extends PlayerMarketValueAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerMarketValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerMarketValue[P]>
      : GetScalarType<T[P], AggregatePlayerMarketValue[P]>
  }




  export type PlayerMarketValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMarketValueWhereInput
    orderBy?: PlayerMarketValueOrderByWithAggregationInput | PlayerMarketValueOrderByWithAggregationInput[]
    by: PlayerMarketValueScalarFieldEnum[] | PlayerMarketValueScalarFieldEnum
    having?: PlayerMarketValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerMarketValueCountAggregateInputType | true
    _avg?: PlayerMarketValueAvgAggregateInputType
    _sum?: PlayerMarketValueSumAggregateInputType
    _min?: PlayerMarketValueMinAggregateInputType
    _max?: PlayerMarketValueMaxAggregateInputType
  }

  export type PlayerMarketValueGroupByOutputType = {
    id: number
    playerId: number
    carRating: number
    potential: number
    minBuyNow: bigint
    marketValue: bigint
    lastUpdated: Date
    createdAt: Date
    _count: PlayerMarketValueCountAggregateOutputType | null
    _avg: PlayerMarketValueAvgAggregateOutputType | null
    _sum: PlayerMarketValueSumAggregateOutputType | null
    _min: PlayerMarketValueMinAggregateOutputType | null
    _max: PlayerMarketValueMaxAggregateOutputType | null
  }

  type GetPlayerMarketValueGroupByPayload<T extends PlayerMarketValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerMarketValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerMarketValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerMarketValueGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerMarketValueGroupByOutputType[P]>
        }
      >
    >


  export type PlayerMarketValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    carRating?: boolean
    potential?: boolean
    minBuyNow?: boolean
    marketValue?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMarketValue"]>

  export type PlayerMarketValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    carRating?: boolean
    potential?: boolean
    minBuyNow?: boolean
    marketValue?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMarketValue"]>

  export type PlayerMarketValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    carRating?: boolean
    potential?: boolean
    minBuyNow?: boolean
    marketValue?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMarketValue"]>

  export type PlayerMarketValueSelectScalar = {
    id?: boolean
    playerId?: boolean
    carRating?: boolean
    potential?: boolean
    minBuyNow?: boolean
    marketValue?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
  }

  export type PlayerMarketValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "carRating" | "potential" | "minBuyNow" | "marketValue" | "lastUpdated" | "createdAt", ExtArgs["result"]["playerMarketValue"]>
  export type PlayerMarketValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerMarketValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerMarketValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlayerMarketValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerMarketValue"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      playerId: number
      carRating: number
      potential: number
      minBuyNow: bigint
      marketValue: bigint
      lastUpdated: Date
      createdAt: Date
    }, ExtArgs["result"]["playerMarketValue"]>
    composites: {}
  }

  type PlayerMarketValueGetPayload<S extends boolean | null | undefined | PlayerMarketValueDefaultArgs> = $Result.GetResult<Prisma.$PlayerMarketValuePayload, S>

  type PlayerMarketValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerMarketValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerMarketValueCountAggregateInputType | true
    }

  export interface PlayerMarketValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerMarketValue'], meta: { name: 'PlayerMarketValue' } }
    /**
     * Find zero or one PlayerMarketValue that matches the filter.
     * @param {PlayerMarketValueFindUniqueArgs} args - Arguments to find a PlayerMarketValue
     * @example
     * // Get one PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerMarketValueFindUniqueArgs>(args: SelectSubset<T, PlayerMarketValueFindUniqueArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerMarketValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerMarketValueFindUniqueOrThrowArgs} args - Arguments to find a PlayerMarketValue
     * @example
     * // Get one PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerMarketValueFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerMarketValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerMarketValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueFindFirstArgs} args - Arguments to find a PlayerMarketValue
     * @example
     * // Get one PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerMarketValueFindFirstArgs>(args?: SelectSubset<T, PlayerMarketValueFindFirstArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerMarketValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueFindFirstOrThrowArgs} args - Arguments to find a PlayerMarketValue
     * @example
     * // Get one PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerMarketValueFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerMarketValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerMarketValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerMarketValues
     * const playerMarketValues = await prisma.playerMarketValue.findMany()
     * 
     * // Get first 10 PlayerMarketValues
     * const playerMarketValues = await prisma.playerMarketValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerMarketValueWithIdOnly = await prisma.playerMarketValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerMarketValueFindManyArgs>(args?: SelectSubset<T, PlayerMarketValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerMarketValue.
     * @param {PlayerMarketValueCreateArgs} args - Arguments to create a PlayerMarketValue.
     * @example
     * // Create one PlayerMarketValue
     * const PlayerMarketValue = await prisma.playerMarketValue.create({
     *   data: {
     *     // ... data to create a PlayerMarketValue
     *   }
     * })
     * 
     */
    create<T extends PlayerMarketValueCreateArgs>(args: SelectSubset<T, PlayerMarketValueCreateArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerMarketValues.
     * @param {PlayerMarketValueCreateManyArgs} args - Arguments to create many PlayerMarketValues.
     * @example
     * // Create many PlayerMarketValues
     * const playerMarketValue = await prisma.playerMarketValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerMarketValueCreateManyArgs>(args?: SelectSubset<T, PlayerMarketValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerMarketValues and returns the data saved in the database.
     * @param {PlayerMarketValueCreateManyAndReturnArgs} args - Arguments to create many PlayerMarketValues.
     * @example
     * // Create many PlayerMarketValues
     * const playerMarketValue = await prisma.playerMarketValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerMarketValues and only return the `id`
     * const playerMarketValueWithIdOnly = await prisma.playerMarketValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerMarketValueCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerMarketValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerMarketValue.
     * @param {PlayerMarketValueDeleteArgs} args - Arguments to delete one PlayerMarketValue.
     * @example
     * // Delete one PlayerMarketValue
     * const PlayerMarketValue = await prisma.playerMarketValue.delete({
     *   where: {
     *     // ... filter to delete one PlayerMarketValue
     *   }
     * })
     * 
     */
    delete<T extends PlayerMarketValueDeleteArgs>(args: SelectSubset<T, PlayerMarketValueDeleteArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerMarketValue.
     * @param {PlayerMarketValueUpdateArgs} args - Arguments to update one PlayerMarketValue.
     * @example
     * // Update one PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerMarketValueUpdateArgs>(args: SelectSubset<T, PlayerMarketValueUpdateArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerMarketValues.
     * @param {PlayerMarketValueDeleteManyArgs} args - Arguments to filter PlayerMarketValues to delete.
     * @example
     * // Delete a few PlayerMarketValues
     * const { count } = await prisma.playerMarketValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerMarketValueDeleteManyArgs>(args?: SelectSubset<T, PlayerMarketValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerMarketValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerMarketValues
     * const playerMarketValue = await prisma.playerMarketValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerMarketValueUpdateManyArgs>(args: SelectSubset<T, PlayerMarketValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerMarketValues and returns the data updated in the database.
     * @param {PlayerMarketValueUpdateManyAndReturnArgs} args - Arguments to update many PlayerMarketValues.
     * @example
     * // Update many PlayerMarketValues
     * const playerMarketValue = await prisma.playerMarketValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerMarketValues and only return the `id`
     * const playerMarketValueWithIdOnly = await prisma.playerMarketValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerMarketValueUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerMarketValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerMarketValue.
     * @param {PlayerMarketValueUpsertArgs} args - Arguments to update or create a PlayerMarketValue.
     * @example
     * // Update or create a PlayerMarketValue
     * const playerMarketValue = await prisma.playerMarketValue.upsert({
     *   create: {
     *     // ... data to create a PlayerMarketValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerMarketValue we want to update
     *   }
     * })
     */
    upsert<T extends PlayerMarketValueUpsertArgs>(args: SelectSubset<T, PlayerMarketValueUpsertArgs<ExtArgs>>): Prisma__PlayerMarketValueClient<$Result.GetResult<Prisma.$PlayerMarketValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerMarketValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueCountArgs} args - Arguments to filter PlayerMarketValues to count.
     * @example
     * // Count the number of PlayerMarketValues
     * const count = await prisma.playerMarketValue.count({
     *   where: {
     *     // ... the filter for the PlayerMarketValues we want to count
     *   }
     * })
    **/
    count<T extends PlayerMarketValueCountArgs>(
      args?: Subset<T, PlayerMarketValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerMarketValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerMarketValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerMarketValueAggregateArgs>(args: Subset<T, PlayerMarketValueAggregateArgs>): Prisma.PrismaPromise<GetPlayerMarketValueAggregateType<T>>

    /**
     * Group by PlayerMarketValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMarketValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerMarketValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerMarketValueGroupByArgs['orderBy'] }
        : { orderBy?: PlayerMarketValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerMarketValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerMarketValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerMarketValue model
   */
  readonly fields: PlayerMarketValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerMarketValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerMarketValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerMarketValue model
   */
  interface PlayerMarketValueFieldRefs {
    readonly id: FieldRef<"PlayerMarketValue", 'Int'>
    readonly playerId: FieldRef<"PlayerMarketValue", 'Int'>
    readonly carRating: FieldRef<"PlayerMarketValue", 'Float'>
    readonly potential: FieldRef<"PlayerMarketValue", 'Float'>
    readonly minBuyNow: FieldRef<"PlayerMarketValue", 'BigInt'>
    readonly marketValue: FieldRef<"PlayerMarketValue", 'BigInt'>
    readonly lastUpdated: FieldRef<"PlayerMarketValue", 'DateTime'>
    readonly createdAt: FieldRef<"PlayerMarketValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerMarketValue findUnique
   */
  export type PlayerMarketValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMarketValue to fetch.
     */
    where: PlayerMarketValueWhereUniqueInput
  }

  /**
   * PlayerMarketValue findUniqueOrThrow
   */
  export type PlayerMarketValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMarketValue to fetch.
     */
    where: PlayerMarketValueWhereUniqueInput
  }

  /**
   * PlayerMarketValue findFirst
   */
  export type PlayerMarketValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMarketValue to fetch.
     */
    where?: PlayerMarketValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMarketValues to fetch.
     */
    orderBy?: PlayerMarketValueOrderByWithRelationInput | PlayerMarketValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMarketValues.
     */
    cursor?: PlayerMarketValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMarketValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMarketValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMarketValues.
     */
    distinct?: PlayerMarketValueScalarFieldEnum | PlayerMarketValueScalarFieldEnum[]
  }

  /**
   * PlayerMarketValue findFirstOrThrow
   */
  export type PlayerMarketValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMarketValue to fetch.
     */
    where?: PlayerMarketValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMarketValues to fetch.
     */
    orderBy?: PlayerMarketValueOrderByWithRelationInput | PlayerMarketValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMarketValues.
     */
    cursor?: PlayerMarketValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMarketValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMarketValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMarketValues.
     */
    distinct?: PlayerMarketValueScalarFieldEnum | PlayerMarketValueScalarFieldEnum[]
  }

  /**
   * PlayerMarketValue findMany
   */
  export type PlayerMarketValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMarketValues to fetch.
     */
    where?: PlayerMarketValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMarketValues to fetch.
     */
    orderBy?: PlayerMarketValueOrderByWithRelationInput | PlayerMarketValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerMarketValues.
     */
    cursor?: PlayerMarketValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMarketValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMarketValues.
     */
    skip?: number
    distinct?: PlayerMarketValueScalarFieldEnum | PlayerMarketValueScalarFieldEnum[]
  }

  /**
   * PlayerMarketValue create
   */
  export type PlayerMarketValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerMarketValue.
     */
    data: XOR<PlayerMarketValueCreateInput, PlayerMarketValueUncheckedCreateInput>
  }

  /**
   * PlayerMarketValue createMany
   */
  export type PlayerMarketValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerMarketValues.
     */
    data: PlayerMarketValueCreateManyInput | PlayerMarketValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerMarketValue createManyAndReturn
   */
  export type PlayerMarketValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerMarketValues.
     */
    data: PlayerMarketValueCreateManyInput | PlayerMarketValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerMarketValue update
   */
  export type PlayerMarketValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerMarketValue.
     */
    data: XOR<PlayerMarketValueUpdateInput, PlayerMarketValueUncheckedUpdateInput>
    /**
     * Choose, which PlayerMarketValue to update.
     */
    where: PlayerMarketValueWhereUniqueInput
  }

  /**
   * PlayerMarketValue updateMany
   */
  export type PlayerMarketValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerMarketValues.
     */
    data: XOR<PlayerMarketValueUpdateManyMutationInput, PlayerMarketValueUncheckedUpdateManyInput>
    /**
     * Filter which PlayerMarketValues to update
     */
    where?: PlayerMarketValueWhereInput
    /**
     * Limit how many PlayerMarketValues to update.
     */
    limit?: number
  }

  /**
   * PlayerMarketValue updateManyAndReturn
   */
  export type PlayerMarketValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * The data used to update PlayerMarketValues.
     */
    data: XOR<PlayerMarketValueUpdateManyMutationInput, PlayerMarketValueUncheckedUpdateManyInput>
    /**
     * Filter which PlayerMarketValues to update
     */
    where?: PlayerMarketValueWhereInput
    /**
     * Limit how many PlayerMarketValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerMarketValue upsert
   */
  export type PlayerMarketValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerMarketValue to update in case it exists.
     */
    where: PlayerMarketValueWhereUniqueInput
    /**
     * In case the PlayerMarketValue found by the `where` argument doesn't exist, create a new PlayerMarketValue with this data.
     */
    create: XOR<PlayerMarketValueCreateInput, PlayerMarketValueUncheckedCreateInput>
    /**
     * In case the PlayerMarketValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerMarketValueUpdateInput, PlayerMarketValueUncheckedUpdateInput>
  }

  /**
   * PlayerMarketValue delete
   */
  export type PlayerMarketValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
    /**
     * Filter which PlayerMarketValue to delete.
     */
    where: PlayerMarketValueWhereUniqueInput
  }

  /**
   * PlayerMarketValue deleteMany
   */
  export type PlayerMarketValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMarketValues to delete
     */
    where?: PlayerMarketValueWhereInput
    /**
     * Limit how many PlayerMarketValues to delete.
     */
    limit?: number
  }

  /**
   * PlayerMarketValue without action
   */
  export type PlayerMarketValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMarketValue
     */
    select?: PlayerMarketValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMarketValue
     */
    omit?: PlayerMarketValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMarketValueInclude<ExtArgs> | null
  }


  /**
   * Model Strategy
   */

  export type AggregateStrategy = {
    _count: StrategyCountAggregateOutputType | null
    _avg: StrategyAvgAggregateOutputType | null
    _sum: StrategySumAggregateOutputType | null
    _min: StrategyMinAggregateOutputType | null
    _max: StrategyMaxAggregateOutputType | null
  }

  export type StrategyAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type StrategySumAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type StrategyMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyCountAggregateOutputType = {
    id: number
    teamId: number
    formationJson: number
    substitutionJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StrategyAvgAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type StrategySumAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type StrategyMinAggregateInputType = {
    id?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyMaxAggregateInputType = {
    id?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyCountAggregateInputType = {
    id?: true
    teamId?: true
    formationJson?: true
    substitutionJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strategy to aggregate.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strategies
    **/
    _count?: true | StrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyMaxAggregateInputType
  }

  export type GetStrategyAggregateType<T extends StrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategy[P]>
      : GetScalarType<T[P], AggregateStrategy[P]>
  }




  export type StrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyWhereInput
    orderBy?: StrategyOrderByWithAggregationInput | StrategyOrderByWithAggregationInput[]
    by: StrategyScalarFieldEnum[] | StrategyScalarFieldEnum
    having?: StrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyCountAggregateInputType | true
    _avg?: StrategyAvgAggregateInputType
    _sum?: StrategySumAggregateInputType
    _min?: StrategyMinAggregateInputType
    _max?: StrategyMaxAggregateInputType
  }

  export type StrategyGroupByOutputType = {
    id: number
    teamId: number
    formationJson: JsonValue | null
    substitutionJson: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StrategyCountAggregateOutputType | null
    _avg: StrategyAvgAggregateOutputType | null
    _sum: StrategySumAggregateOutputType | null
    _min: StrategyMinAggregateOutputType | null
    _max: StrategyMaxAggregateOutputType | null
  }

  type GetStrategyGroupByPayload<T extends StrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyGroupByOutputType[P]>
        }
      >
    >


  export type StrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    formationJson?: boolean
    substitutionJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategy"]>

  export type StrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    formationJson?: boolean
    substitutionJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategy"]>

  export type StrategySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    formationJson?: boolean
    substitutionJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategy"]>

  export type StrategySelectScalar = {
    id?: boolean
    teamId?: boolean
    formationJson?: boolean
    substitutionJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StrategyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "formationJson" | "substitutionJson" | "createdAt" | "updatedAt", ExtArgs["result"]["strategy"]>
  export type StrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type StrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type StrategyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $StrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Strategy"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      formationJson: Prisma.JsonValue | null
      substitutionJson: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["strategy"]>
    composites: {}
  }

  type StrategyGetPayload<S extends boolean | null | undefined | StrategyDefaultArgs> = $Result.GetResult<Prisma.$StrategyPayload, S>

  type StrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StrategyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrategyCountAggregateInputType | true
    }

  export interface StrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Strategy'], meta: { name: 'Strategy' } }
    /**
     * Find zero or one Strategy that matches the filter.
     * @param {StrategyFindUniqueArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyFindUniqueArgs>(args: SelectSubset<T, StrategyFindUniqueArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Strategy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StrategyFindUniqueOrThrowArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindFirstArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyFindFirstArgs>(args?: SelectSubset<T, StrategyFindFirstArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindFirstOrThrowArgs} args - Arguments to find a Strategy
     * @example
     * // Get one Strategy
     * const strategy = await prisma.strategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Strategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strategies
     * const strategies = await prisma.strategy.findMany()
     * 
     * // Get first 10 Strategies
     * const strategies = await prisma.strategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyWithIdOnly = await prisma.strategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyFindManyArgs>(args?: SelectSubset<T, StrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Strategy.
     * @param {StrategyCreateArgs} args - Arguments to create a Strategy.
     * @example
     * // Create one Strategy
     * const Strategy = await prisma.strategy.create({
     *   data: {
     *     // ... data to create a Strategy
     *   }
     * })
     * 
     */
    create<T extends StrategyCreateArgs>(args: SelectSubset<T, StrategyCreateArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Strategies.
     * @param {StrategyCreateManyArgs} args - Arguments to create many Strategies.
     * @example
     * // Create many Strategies
     * const strategy = await prisma.strategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyCreateManyArgs>(args?: SelectSubset<T, StrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Strategies and returns the data saved in the database.
     * @param {StrategyCreateManyAndReturnArgs} args - Arguments to create many Strategies.
     * @example
     * // Create many Strategies
     * const strategy = await prisma.strategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Strategies and only return the `id`
     * const strategyWithIdOnly = await prisma.strategy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Strategy.
     * @param {StrategyDeleteArgs} args - Arguments to delete one Strategy.
     * @example
     * // Delete one Strategy
     * const Strategy = await prisma.strategy.delete({
     *   where: {
     *     // ... filter to delete one Strategy
     *   }
     * })
     * 
     */
    delete<T extends StrategyDeleteArgs>(args: SelectSubset<T, StrategyDeleteArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Strategy.
     * @param {StrategyUpdateArgs} args - Arguments to update one Strategy.
     * @example
     * // Update one Strategy
     * const strategy = await prisma.strategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyUpdateArgs>(args: SelectSubset<T, StrategyUpdateArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Strategies.
     * @param {StrategyDeleteManyArgs} args - Arguments to filter Strategies to delete.
     * @example
     * // Delete a few Strategies
     * const { count } = await prisma.strategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyDeleteManyArgs>(args?: SelectSubset<T, StrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strategies
     * const strategy = await prisma.strategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyUpdateManyArgs>(args: SelectSubset<T, StrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategies and returns the data updated in the database.
     * @param {StrategyUpdateManyAndReturnArgs} args - Arguments to update many Strategies.
     * @example
     * // Update many Strategies
     * const strategy = await prisma.strategy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Strategies and only return the `id`
     * const strategyWithIdOnly = await prisma.strategy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StrategyUpdateManyAndReturnArgs>(args: SelectSubset<T, StrategyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Strategy.
     * @param {StrategyUpsertArgs} args - Arguments to update or create a Strategy.
     * @example
     * // Update or create a Strategy
     * const strategy = await prisma.strategy.upsert({
     *   create: {
     *     // ... data to create a Strategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strategy we want to update
     *   }
     * })
     */
    upsert<T extends StrategyUpsertArgs>(args: SelectSubset<T, StrategyUpsertArgs<ExtArgs>>): Prisma__StrategyClient<$Result.GetResult<Prisma.$StrategyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyCountArgs} args - Arguments to filter Strategies to count.
     * @example
     * // Count the number of Strategies
     * const count = await prisma.strategy.count({
     *   where: {
     *     // ... the filter for the Strategies we want to count
     *   }
     * })
    **/
    count<T extends StrategyCountArgs>(
      args?: Subset<T, StrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyAggregateArgs>(args: Subset<T, StrategyAggregateArgs>): Prisma.PrismaPromise<GetStrategyAggregateType<T>>

    /**
     * Group by Strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyGroupByArgs['orderBy'] }
        : { orderBy?: StrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Strategy model
   */
  readonly fields: StrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Strategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Strategy model
   */
  interface StrategyFieldRefs {
    readonly id: FieldRef<"Strategy", 'Int'>
    readonly teamId: FieldRef<"Strategy", 'Int'>
    readonly formationJson: FieldRef<"Strategy", 'Json'>
    readonly substitutionJson: FieldRef<"Strategy", 'Json'>
    readonly createdAt: FieldRef<"Strategy", 'DateTime'>
    readonly updatedAt: FieldRef<"Strategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Strategy findUnique
   */
  export type StrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy findUniqueOrThrow
   */
  export type StrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy findFirst
   */
  export type StrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strategies.
     */
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy findFirstOrThrow
   */
  export type StrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategy to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strategies.
     */
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy findMany
   */
  export type StrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter, which Strategies to fetch.
     */
    where?: StrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     */
    orderBy?: StrategyOrderByWithRelationInput | StrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strategies.
     */
    cursor?: StrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     */
    skip?: number
    distinct?: StrategyScalarFieldEnum | StrategyScalarFieldEnum[]
  }

  /**
   * Strategy create
   */
  export type StrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a Strategy.
     */
    data: XOR<StrategyCreateInput, StrategyUncheckedCreateInput>
  }

  /**
   * Strategy createMany
   */
  export type StrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Strategies.
     */
    data: StrategyCreateManyInput | StrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strategy createManyAndReturn
   */
  export type StrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * The data used to create many Strategies.
     */
    data: StrategyCreateManyInput | StrategyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strategy update
   */
  export type StrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a Strategy.
     */
    data: XOR<StrategyUpdateInput, StrategyUncheckedUpdateInput>
    /**
     * Choose, which Strategy to update.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy updateMany
   */
  export type StrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Strategies.
     */
    data: XOR<StrategyUpdateManyMutationInput, StrategyUncheckedUpdateManyInput>
    /**
     * Filter which Strategies to update
     */
    where?: StrategyWhereInput
    /**
     * Limit how many Strategies to update.
     */
    limit?: number
  }

  /**
   * Strategy updateManyAndReturn
   */
  export type StrategyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * The data used to update Strategies.
     */
    data: XOR<StrategyUpdateManyMutationInput, StrategyUncheckedUpdateManyInput>
    /**
     * Filter which Strategies to update
     */
    where?: StrategyWhereInput
    /**
     * Limit how many Strategies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strategy upsert
   */
  export type StrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the Strategy to update in case it exists.
     */
    where: StrategyWhereUniqueInput
    /**
     * In case the Strategy found by the `where` argument doesn't exist, create a new Strategy with this data.
     */
    create: XOR<StrategyCreateInput, StrategyUncheckedCreateInput>
    /**
     * In case the Strategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyUpdateInput, StrategyUncheckedUpdateInput>
  }

  /**
   * Strategy delete
   */
  export type StrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
    /**
     * Filter which Strategy to delete.
     */
    where: StrategyWhereUniqueInput
  }

  /**
   * Strategy deleteMany
   */
  export type StrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strategies to delete
     */
    where?: StrategyWhereInput
    /**
     * Limit how many Strategies to delete.
     */
    limit?: number
  }

  /**
   * Strategy without action
   */
  export type StrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strategy
     */
    select?: StrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strategy
     */
    omit?: StrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyInclude<ExtArgs> | null
  }


  /**
   * Model League
   */

  export type AggregateLeague = {
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  export type LeagueAvgAggregateOutputType = {
    id: number | null
    division: number | null
  }

  export type LeagueSumAggregateOutputType = {
    id: number | null
    division: number | null
  }

  export type LeagueMinAggregateOutputType = {
    id: number | null
    division: number | null
    name: string | null
    seasonId: string | null
  }

  export type LeagueMaxAggregateOutputType = {
    id: number | null
    division: number | null
    name: string | null
    seasonId: string | null
  }

  export type LeagueCountAggregateOutputType = {
    id: number
    division: number
    name: number
    seasonId: number
    _all: number
  }


  export type LeagueAvgAggregateInputType = {
    id?: true
    division?: true
  }

  export type LeagueSumAggregateInputType = {
    id?: true
    division?: true
  }

  export type LeagueMinAggregateInputType = {
    id?: true
    division?: true
    name?: true
    seasonId?: true
  }

  export type LeagueMaxAggregateInputType = {
    id?: true
    division?: true
    name?: true
    seasonId?: true
  }

  export type LeagueCountAggregateInputType = {
    id?: true
    division?: true
    name?: true
    seasonId?: true
    _all?: true
  }

  export type LeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which League to aggregate.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leagues
    **/
    _count?: true | LeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeagueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeagueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueMaxAggregateInputType
  }

  export type GetLeagueAggregateType<T extends LeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeague[P]>
      : GetScalarType<T[P], AggregateLeague[P]>
  }




  export type LeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithAggregationInput | LeagueOrderByWithAggregationInput[]
    by: LeagueScalarFieldEnum[] | LeagueScalarFieldEnum
    having?: LeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueCountAggregateInputType | true
    _avg?: LeagueAvgAggregateInputType
    _sum?: LeagueSumAggregateInputType
    _min?: LeagueMinAggregateInputType
    _max?: LeagueMaxAggregateInputType
  }

  export type LeagueGroupByOutputType = {
    id: number
    division: number
    name: string
    seasonId: string
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  type GetLeagueGroupByPayload<T extends LeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueGroupByOutputType[P]>
        }
      >
    >


  export type LeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    division?: boolean
    name?: boolean
    seasonId?: boolean
    teams?: boolean | League$teamsArgs<ExtArgs>
    schedule?: boolean | League$scheduleArgs<ExtArgs>
    standings?: boolean | League$standingsArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    division?: boolean
    name?: boolean
    seasonId?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    division?: boolean
    name?: boolean
    seasonId?: boolean
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectScalar = {
    id?: boolean
    division?: boolean
    name?: boolean
    seasonId?: boolean
  }

  export type LeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "division" | "name" | "seasonId", ExtArgs["result"]["league"]>
  export type LeagueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | League$teamsArgs<ExtArgs>
    schedule?: boolean | League$scheduleArgs<ExtArgs>
    standings?: boolean | League$standingsArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }

  export type $LeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "League"
    objects: {
      teams: Prisma.$TeamPayload<ExtArgs>[]
      schedule: Prisma.$GamePayload<ExtArgs>[]
      standings: Prisma.$LeagueStandingPayload<ExtArgs>[]
      season: Prisma.$SeasonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      division: number
      name: string
      seasonId: string
    }, ExtArgs["result"]["league"]>
    composites: {}
  }

  type LeagueGetPayload<S extends boolean | null | undefined | LeagueDefaultArgs> = $Result.GetResult<Prisma.$LeaguePayload, S>

  type LeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueCountAggregateInputType | true
    }

  export interface LeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['League'], meta: { name: 'League' } }
    /**
     * Find zero or one League that matches the filter.
     * @param {LeagueFindUniqueArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueFindUniqueArgs>(args: SelectSubset<T, LeagueFindUniqueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one League that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueFindUniqueOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueFindFirstArgs>(args?: SelectSubset<T, LeagueFindFirstArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.league.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.league.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueWithIdOnly = await prisma.league.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueFindManyArgs>(args?: SelectSubset<T, LeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a League.
     * @param {LeagueCreateArgs} args - Arguments to create a League.
     * @example
     * // Create one League
     * const League = await prisma.league.create({
     *   data: {
     *     // ... data to create a League
     *   }
     * })
     * 
     */
    create<T extends LeagueCreateArgs>(args: SelectSubset<T, LeagueCreateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leagues.
     * @param {LeagueCreateManyArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueCreateManyArgs>(args?: SelectSubset<T, LeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leagues and returns the data saved in the database.
     * @param {LeagueCreateManyAndReturnArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a League.
     * @param {LeagueDeleteArgs} args - Arguments to delete one League.
     * @example
     * // Delete one League
     * const League = await prisma.league.delete({
     *   where: {
     *     // ... filter to delete one League
     *   }
     * })
     * 
     */
    delete<T extends LeagueDeleteArgs>(args: SelectSubset<T, LeagueDeleteArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one League.
     * @param {LeagueUpdateArgs} args - Arguments to update one League.
     * @example
     * // Update one League
     * const league = await prisma.league.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueUpdateArgs>(args: SelectSubset<T, LeagueUpdateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leagues.
     * @param {LeagueDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.league.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueDeleteManyArgs>(args?: SelectSubset<T, LeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueUpdateManyArgs>(args: SelectSubset<T, LeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues and returns the data updated in the database.
     * @param {LeagueUpdateManyAndReturnArgs} args - Arguments to update many Leagues.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one League.
     * @param {LeagueUpsertArgs} args - Arguments to update or create a League.
     * @example
     * // Update or create a League
     * const league = await prisma.league.upsert({
     *   create: {
     *     // ... data to create a League
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the League we want to update
     *   }
     * })
     */
    upsert<T extends LeagueUpsertArgs>(args: SelectSubset<T, LeagueUpsertArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.league.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends LeagueCountArgs>(
      args?: Subset<T, LeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueAggregateArgs>(args: Subset<T, LeagueAggregateArgs>): Prisma.PrismaPromise<GetLeagueAggregateType<T>>

    /**
     * Group by League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueGroupByArgs['orderBy'] }
        : { orderBy?: LeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the League model
   */
  readonly fields: LeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for League.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teams<T extends League$teamsArgs<ExtArgs> = {}>(args?: Subset<T, League$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedule<T extends League$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, League$scheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standings<T extends League$standingsArgs<ExtArgs> = {}>(args?: Subset<T, League$standingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the League model
   */
  interface LeagueFieldRefs {
    readonly id: FieldRef<"League", 'Int'>
    readonly division: FieldRef<"League", 'Int'>
    readonly name: FieldRef<"League", 'String'>
    readonly seasonId: FieldRef<"League", 'String'>
  }
    

  // Custom InputTypes
  /**
   * League findUnique
   */
  export type LeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findUniqueOrThrow
   */
  export type LeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findFirst
   */
  export type LeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findFirstOrThrow
   */
  export type LeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findMany
   */
  export type LeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League create
   */
  export type LeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to create a League.
     */
    data: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
  }

  /**
   * League createMany
   */
  export type LeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * League createManyAndReturn
   */
  export type LeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * League update
   */
  export type LeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to update a League.
     */
    data: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
    /**
     * Choose, which League to update.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League updateMany
   */
  export type LeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
  }

  /**
   * League updateManyAndReturn
   */
  export type LeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * League upsert
   */
  export type LeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The filter to search for the League to update in case it exists.
     */
    where: LeagueWhereUniqueInput
    /**
     * In case the League found by the `where` argument doesn't exist, create a new League with this data.
     */
    create: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
    /**
     * In case the League was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
  }

  /**
   * League delete
   */
  export type LeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter which League to delete.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League deleteMany
   */
  export type LeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to delete
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to delete.
     */
    limit?: number
  }

  /**
   * League.teams
   */
  export type League$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * League.schedule
   */
  export type League$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * League.standings
   */
  export type League$standingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    where?: LeagueStandingWhereInput
    orderBy?: LeagueStandingOrderByWithRelationInput | LeagueStandingOrderByWithRelationInput[]
    cursor?: LeagueStandingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeagueStandingScalarFieldEnum | LeagueStandingScalarFieldEnum[]
  }

  /**
   * League without action
   */
  export type LeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
  }


  /**
   * Model LeagueStanding
   */

  export type AggregateLeagueStanding = {
    _count: LeagueStandingCountAggregateOutputType | null
    _avg: LeagueStandingAvgAggregateOutputType | null
    _sum: LeagueStandingSumAggregateOutputType | null
    _min: LeagueStandingMinAggregateOutputType | null
    _max: LeagueStandingMaxAggregateOutputType | null
  }

  export type LeagueStandingAvgAggregateOutputType = {
    id: number | null
    leagueId: number | null
    teamId: number | null
    wins: number | null
    losses: number | null
    ties: number | null
    pointsFor: number | null
    pointsAgainst: number | null
    pointDifferential: number | null
    rank: number | null
  }

  export type LeagueStandingSumAggregateOutputType = {
    id: number | null
    leagueId: number | null
    teamId: number | null
    wins: number | null
    losses: number | null
    ties: number | null
    pointsFor: number | null
    pointsAgainst: number | null
    pointDifferential: number | null
    rank: number | null
  }

  export type LeagueStandingMinAggregateOutputType = {
    id: number | null
    leagueId: number | null
    teamId: number | null
    teamName: string | null
    wins: number | null
    losses: number | null
    ties: number | null
    pointsFor: number | null
    pointsAgainst: number | null
    pointDifferential: number | null
    streak: string | null
    rank: number | null
    updatedAt: Date | null
  }

  export type LeagueStandingMaxAggregateOutputType = {
    id: number | null
    leagueId: number | null
    teamId: number | null
    teamName: string | null
    wins: number | null
    losses: number | null
    ties: number | null
    pointsFor: number | null
    pointsAgainst: number | null
    pointDifferential: number | null
    streak: string | null
    rank: number | null
    updatedAt: Date | null
  }

  export type LeagueStandingCountAggregateOutputType = {
    id: number
    leagueId: number
    teamId: number
    teamName: number
    wins: number
    losses: number
    ties: number
    pointsFor: number
    pointsAgainst: number
    pointDifferential: number
    streak: number
    rank: number
    updatedAt: number
    _all: number
  }


  export type LeagueStandingAvgAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    wins?: true
    losses?: true
    ties?: true
    pointsFor?: true
    pointsAgainst?: true
    pointDifferential?: true
    rank?: true
  }

  export type LeagueStandingSumAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    wins?: true
    losses?: true
    ties?: true
    pointsFor?: true
    pointsAgainst?: true
    pointDifferential?: true
    rank?: true
  }

  export type LeagueStandingMinAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    teamName?: true
    wins?: true
    losses?: true
    ties?: true
    pointsFor?: true
    pointsAgainst?: true
    pointDifferential?: true
    streak?: true
    rank?: true
    updatedAt?: true
  }

  export type LeagueStandingMaxAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    teamName?: true
    wins?: true
    losses?: true
    ties?: true
    pointsFor?: true
    pointsAgainst?: true
    pointDifferential?: true
    streak?: true
    rank?: true
    updatedAt?: true
  }

  export type LeagueStandingCountAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    teamName?: true
    wins?: true
    losses?: true
    ties?: true
    pointsFor?: true
    pointsAgainst?: true
    pointDifferential?: true
    streak?: true
    rank?: true
    updatedAt?: true
    _all?: true
  }

  export type LeagueStandingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeagueStanding to aggregate.
     */
    where?: LeagueStandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueStandings to fetch.
     */
    orderBy?: LeagueStandingOrderByWithRelationInput | LeagueStandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueStandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueStandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueStandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeagueStandings
    **/
    _count?: true | LeagueStandingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeagueStandingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeagueStandingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueStandingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueStandingMaxAggregateInputType
  }

  export type GetLeagueStandingAggregateType<T extends LeagueStandingAggregateArgs> = {
        [P in keyof T & keyof AggregateLeagueStanding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeagueStanding[P]>
      : GetScalarType<T[P], AggregateLeagueStanding[P]>
  }




  export type LeagueStandingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueStandingWhereInput
    orderBy?: LeagueStandingOrderByWithAggregationInput | LeagueStandingOrderByWithAggregationInput[]
    by: LeagueStandingScalarFieldEnum[] | LeagueStandingScalarFieldEnum
    having?: LeagueStandingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueStandingCountAggregateInputType | true
    _avg?: LeagueStandingAvgAggregateInputType
    _sum?: LeagueStandingSumAggregateInputType
    _min?: LeagueStandingMinAggregateInputType
    _max?: LeagueStandingMaxAggregateInputType
  }

  export type LeagueStandingGroupByOutputType = {
    id: number
    leagueId: number
    teamId: number
    teamName: string
    wins: number
    losses: number
    ties: number
    pointsFor: number
    pointsAgainst: number
    pointDifferential: number
    streak: string
    rank: number
    updatedAt: Date
    _count: LeagueStandingCountAggregateOutputType | null
    _avg: LeagueStandingAvgAggregateOutputType | null
    _sum: LeagueStandingSumAggregateOutputType | null
    _min: LeagueStandingMinAggregateOutputType | null
    _max: LeagueStandingMaxAggregateOutputType | null
  }

  type GetLeagueStandingGroupByPayload<T extends LeagueStandingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueStandingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueStandingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueStandingGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueStandingGroupByOutputType[P]>
        }
      >
    >


  export type LeagueStandingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    teamName?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    pointsFor?: boolean
    pointsAgainst?: boolean
    pointDifferential?: boolean
    streak?: boolean
    rank?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueStanding"]>

  export type LeagueStandingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    teamName?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    pointsFor?: boolean
    pointsAgainst?: boolean
    pointDifferential?: boolean
    streak?: boolean
    rank?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueStanding"]>

  export type LeagueStandingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    teamName?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    pointsFor?: boolean
    pointsAgainst?: boolean
    pointDifferential?: boolean
    streak?: boolean
    rank?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueStanding"]>

  export type LeagueStandingSelectScalar = {
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    teamName?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    pointsFor?: boolean
    pointsAgainst?: boolean
    pointDifferential?: boolean
    streak?: boolean
    rank?: boolean
    updatedAt?: boolean
  }

  export type LeagueStandingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "teamId" | "teamName" | "wins" | "losses" | "ties" | "pointsFor" | "pointsAgainst" | "pointDifferential" | "streak" | "rank" | "updatedAt", ExtArgs["result"]["leagueStanding"]>
  export type LeagueStandingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type LeagueStandingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type LeagueStandingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $LeagueStandingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeagueStanding"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leagueId: number
      teamId: number
      teamName: string
      wins: number
      losses: number
      ties: number
      pointsFor: number
      pointsAgainst: number
      pointDifferential: number
      streak: string
      rank: number
      updatedAt: Date
    }, ExtArgs["result"]["leagueStanding"]>
    composites: {}
  }

  type LeagueStandingGetPayload<S extends boolean | null | undefined | LeagueStandingDefaultArgs> = $Result.GetResult<Prisma.$LeagueStandingPayload, S>

  type LeagueStandingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueStandingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueStandingCountAggregateInputType | true
    }

  export interface LeagueStandingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeagueStanding'], meta: { name: 'LeagueStanding' } }
    /**
     * Find zero or one LeagueStanding that matches the filter.
     * @param {LeagueStandingFindUniqueArgs} args - Arguments to find a LeagueStanding
     * @example
     * // Get one LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueStandingFindUniqueArgs>(args: SelectSubset<T, LeagueStandingFindUniqueArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeagueStanding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueStandingFindUniqueOrThrowArgs} args - Arguments to find a LeagueStanding
     * @example
     * // Get one LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueStandingFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueStandingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeagueStanding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingFindFirstArgs} args - Arguments to find a LeagueStanding
     * @example
     * // Get one LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueStandingFindFirstArgs>(args?: SelectSubset<T, LeagueStandingFindFirstArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeagueStanding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingFindFirstOrThrowArgs} args - Arguments to find a LeagueStanding
     * @example
     * // Get one LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueStandingFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueStandingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeagueStandings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeagueStandings
     * const leagueStandings = await prisma.leagueStanding.findMany()
     * 
     * // Get first 10 LeagueStandings
     * const leagueStandings = await prisma.leagueStanding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueStandingWithIdOnly = await prisma.leagueStanding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueStandingFindManyArgs>(args?: SelectSubset<T, LeagueStandingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeagueStanding.
     * @param {LeagueStandingCreateArgs} args - Arguments to create a LeagueStanding.
     * @example
     * // Create one LeagueStanding
     * const LeagueStanding = await prisma.leagueStanding.create({
     *   data: {
     *     // ... data to create a LeagueStanding
     *   }
     * })
     * 
     */
    create<T extends LeagueStandingCreateArgs>(args: SelectSubset<T, LeagueStandingCreateArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeagueStandings.
     * @param {LeagueStandingCreateManyArgs} args - Arguments to create many LeagueStandings.
     * @example
     * // Create many LeagueStandings
     * const leagueStanding = await prisma.leagueStanding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueStandingCreateManyArgs>(args?: SelectSubset<T, LeagueStandingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeagueStandings and returns the data saved in the database.
     * @param {LeagueStandingCreateManyAndReturnArgs} args - Arguments to create many LeagueStandings.
     * @example
     * // Create many LeagueStandings
     * const leagueStanding = await prisma.leagueStanding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeagueStandings and only return the `id`
     * const leagueStandingWithIdOnly = await prisma.leagueStanding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueStandingCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueStandingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeagueStanding.
     * @param {LeagueStandingDeleteArgs} args - Arguments to delete one LeagueStanding.
     * @example
     * // Delete one LeagueStanding
     * const LeagueStanding = await prisma.leagueStanding.delete({
     *   where: {
     *     // ... filter to delete one LeagueStanding
     *   }
     * })
     * 
     */
    delete<T extends LeagueStandingDeleteArgs>(args: SelectSubset<T, LeagueStandingDeleteArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeagueStanding.
     * @param {LeagueStandingUpdateArgs} args - Arguments to update one LeagueStanding.
     * @example
     * // Update one LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueStandingUpdateArgs>(args: SelectSubset<T, LeagueStandingUpdateArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeagueStandings.
     * @param {LeagueStandingDeleteManyArgs} args - Arguments to filter LeagueStandings to delete.
     * @example
     * // Delete a few LeagueStandings
     * const { count } = await prisma.leagueStanding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueStandingDeleteManyArgs>(args?: SelectSubset<T, LeagueStandingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeagueStandings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeagueStandings
     * const leagueStanding = await prisma.leagueStanding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueStandingUpdateManyArgs>(args: SelectSubset<T, LeagueStandingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeagueStandings and returns the data updated in the database.
     * @param {LeagueStandingUpdateManyAndReturnArgs} args - Arguments to update many LeagueStandings.
     * @example
     * // Update many LeagueStandings
     * const leagueStanding = await prisma.leagueStanding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeagueStandings and only return the `id`
     * const leagueStandingWithIdOnly = await prisma.leagueStanding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueStandingUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueStandingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeagueStanding.
     * @param {LeagueStandingUpsertArgs} args - Arguments to update or create a LeagueStanding.
     * @example
     * // Update or create a LeagueStanding
     * const leagueStanding = await prisma.leagueStanding.upsert({
     *   create: {
     *     // ... data to create a LeagueStanding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeagueStanding we want to update
     *   }
     * })
     */
    upsert<T extends LeagueStandingUpsertArgs>(args: SelectSubset<T, LeagueStandingUpsertArgs<ExtArgs>>): Prisma__LeagueStandingClient<$Result.GetResult<Prisma.$LeagueStandingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeagueStandings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingCountArgs} args - Arguments to filter LeagueStandings to count.
     * @example
     * // Count the number of LeagueStandings
     * const count = await prisma.leagueStanding.count({
     *   where: {
     *     // ... the filter for the LeagueStandings we want to count
     *   }
     * })
    **/
    count<T extends LeagueStandingCountArgs>(
      args?: Subset<T, LeagueStandingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueStandingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeagueStanding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueStandingAggregateArgs>(args: Subset<T, LeagueStandingAggregateArgs>): Prisma.PrismaPromise<GetLeagueStandingAggregateType<T>>

    /**
     * Group by LeagueStanding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueStandingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueStandingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueStandingGroupByArgs['orderBy'] }
        : { orderBy?: LeagueStandingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueStandingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueStandingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeagueStanding model
   */
  readonly fields: LeagueStandingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeagueStanding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueStandingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeagueStanding model
   */
  interface LeagueStandingFieldRefs {
    readonly id: FieldRef<"LeagueStanding", 'Int'>
    readonly leagueId: FieldRef<"LeagueStanding", 'Int'>
    readonly teamId: FieldRef<"LeagueStanding", 'Int'>
    readonly teamName: FieldRef<"LeagueStanding", 'String'>
    readonly wins: FieldRef<"LeagueStanding", 'Int'>
    readonly losses: FieldRef<"LeagueStanding", 'Int'>
    readonly ties: FieldRef<"LeagueStanding", 'Int'>
    readonly pointsFor: FieldRef<"LeagueStanding", 'Int'>
    readonly pointsAgainst: FieldRef<"LeagueStanding", 'Int'>
    readonly pointDifferential: FieldRef<"LeagueStanding", 'Int'>
    readonly streak: FieldRef<"LeagueStanding", 'String'>
    readonly rank: FieldRef<"LeagueStanding", 'Int'>
    readonly updatedAt: FieldRef<"LeagueStanding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeagueStanding findUnique
   */
  export type LeagueStandingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter, which LeagueStanding to fetch.
     */
    where: LeagueStandingWhereUniqueInput
  }

  /**
   * LeagueStanding findUniqueOrThrow
   */
  export type LeagueStandingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter, which LeagueStanding to fetch.
     */
    where: LeagueStandingWhereUniqueInput
  }

  /**
   * LeagueStanding findFirst
   */
  export type LeagueStandingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter, which LeagueStanding to fetch.
     */
    where?: LeagueStandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueStandings to fetch.
     */
    orderBy?: LeagueStandingOrderByWithRelationInput | LeagueStandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeagueStandings.
     */
    cursor?: LeagueStandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueStandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueStandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeagueStandings.
     */
    distinct?: LeagueStandingScalarFieldEnum | LeagueStandingScalarFieldEnum[]
  }

  /**
   * LeagueStanding findFirstOrThrow
   */
  export type LeagueStandingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter, which LeagueStanding to fetch.
     */
    where?: LeagueStandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueStandings to fetch.
     */
    orderBy?: LeagueStandingOrderByWithRelationInput | LeagueStandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeagueStandings.
     */
    cursor?: LeagueStandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueStandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueStandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeagueStandings.
     */
    distinct?: LeagueStandingScalarFieldEnum | LeagueStandingScalarFieldEnum[]
  }

  /**
   * LeagueStanding findMany
   */
  export type LeagueStandingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter, which LeagueStandings to fetch.
     */
    where?: LeagueStandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueStandings to fetch.
     */
    orderBy?: LeagueStandingOrderByWithRelationInput | LeagueStandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeagueStandings.
     */
    cursor?: LeagueStandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueStandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueStandings.
     */
    skip?: number
    distinct?: LeagueStandingScalarFieldEnum | LeagueStandingScalarFieldEnum[]
  }

  /**
   * LeagueStanding create
   */
  export type LeagueStandingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * The data needed to create a LeagueStanding.
     */
    data: XOR<LeagueStandingCreateInput, LeagueStandingUncheckedCreateInput>
  }

  /**
   * LeagueStanding createMany
   */
  export type LeagueStandingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeagueStandings.
     */
    data: LeagueStandingCreateManyInput | LeagueStandingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeagueStanding createManyAndReturn
   */
  export type LeagueStandingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * The data used to create many LeagueStandings.
     */
    data: LeagueStandingCreateManyInput | LeagueStandingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeagueStanding update
   */
  export type LeagueStandingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * The data needed to update a LeagueStanding.
     */
    data: XOR<LeagueStandingUpdateInput, LeagueStandingUncheckedUpdateInput>
    /**
     * Choose, which LeagueStanding to update.
     */
    where: LeagueStandingWhereUniqueInput
  }

  /**
   * LeagueStanding updateMany
   */
  export type LeagueStandingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeagueStandings.
     */
    data: XOR<LeagueStandingUpdateManyMutationInput, LeagueStandingUncheckedUpdateManyInput>
    /**
     * Filter which LeagueStandings to update
     */
    where?: LeagueStandingWhereInput
    /**
     * Limit how many LeagueStandings to update.
     */
    limit?: number
  }

  /**
   * LeagueStanding updateManyAndReturn
   */
  export type LeagueStandingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * The data used to update LeagueStandings.
     */
    data: XOR<LeagueStandingUpdateManyMutationInput, LeagueStandingUncheckedUpdateManyInput>
    /**
     * Filter which LeagueStandings to update
     */
    where?: LeagueStandingWhereInput
    /**
     * Limit how many LeagueStandings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeagueStanding upsert
   */
  export type LeagueStandingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * The filter to search for the LeagueStanding to update in case it exists.
     */
    where: LeagueStandingWhereUniqueInput
    /**
     * In case the LeagueStanding found by the `where` argument doesn't exist, create a new LeagueStanding with this data.
     */
    create: XOR<LeagueStandingCreateInput, LeagueStandingUncheckedCreateInput>
    /**
     * In case the LeagueStanding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueStandingUpdateInput, LeagueStandingUncheckedUpdateInput>
  }

  /**
   * LeagueStanding delete
   */
  export type LeagueStandingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
    /**
     * Filter which LeagueStanding to delete.
     */
    where: LeagueStandingWhereUniqueInput
  }

  /**
   * LeagueStanding deleteMany
   */
  export type LeagueStandingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeagueStandings to delete
     */
    where?: LeagueStandingWhereInput
    /**
     * Limit how many LeagueStandings to delete.
     */
    limit?: number
  }

  /**
   * LeagueStanding without action
   */
  export type LeagueStandingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueStanding
     */
    select?: LeagueStandingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueStanding
     */
    omit?: LeagueStandingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueStandingInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    id: number | null
    leagueId: number | null
    homeTeamId: number | null
    awayTeamId: number | null
    homeScore: number | null
    awayScore: number | null
    tournamentId: number | null
    round: number | null
  }

  export type GameSumAggregateOutputType = {
    id: number | null
    leagueId: number | null
    homeTeamId: number | null
    awayTeamId: number | null
    homeScore: number | null
    awayScore: number | null
    tournamentId: number | null
    round: number | null
  }

  export type GameMinAggregateOutputType = {
    id: number | null
    leagueId: number | null
    homeTeamId: number | null
    awayTeamId: number | null
    homeScore: number | null
    awayScore: number | null
    gameDate: Date | null
    simulated: boolean | null
    matchType: $Enums.MatchType | null
    tournamentId: number | null
    round: number | null
    status: $Enums.GameStatus | null
    createdAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: number | null
    leagueId: number | null
    homeTeamId: number | null
    awayTeamId: number | null
    homeScore: number | null
    awayScore: number | null
    gameDate: Date | null
    simulated: boolean | null
    matchType: $Enums.MatchType | null
    tournamentId: number | null
    round: number | null
    status: $Enums.GameStatus | null
    createdAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    leagueId: number
    homeTeamId: number
    awayTeamId: number
    homeScore: number
    awayScore: number
    gameDate: number
    simulated: number
    simulationLog: number
    matchType: number
    tournamentId: number
    round: number
    status: number
    createdAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeScore?: true
    awayScore?: true
    tournamentId?: true
    round?: true
  }

  export type GameSumAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeScore?: true
    awayScore?: true
    tournamentId?: true
    round?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeScore?: true
    awayScore?: true
    gameDate?: true
    simulated?: true
    matchType?: true
    tournamentId?: true
    round?: true
    status?: true
    createdAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeScore?: true
    awayScore?: true
    gameDate?: true
    simulated?: true
    matchType?: true
    tournamentId?: true
    round?: true
    status?: true
    createdAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeScore?: true
    awayScore?: true
    gameDate?: true
    simulated?: true
    simulationLog?: true
    matchType?: true
    tournamentId?: true
    round?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: number
    leagueId: number | null
    homeTeamId: number
    awayTeamId: number
    homeScore: number | null
    awayScore: number | null
    gameDate: Date
    simulated: boolean
    simulationLog: JsonValue | null
    matchType: $Enums.MatchType
    tournamentId: number | null
    round: number | null
    status: $Enums.GameStatus
    createdAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeScore?: boolean
    awayScore?: boolean
    gameDate?: boolean
    simulated?: boolean
    simulationLog?: boolean
    matchType?: boolean
    tournamentId?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeScore?: boolean
    awayScore?: boolean
    gameDate?: boolean
    simulated?: boolean
    simulationLog?: boolean
    matchType?: boolean
    tournamentId?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeScore?: boolean
    awayScore?: boolean
    gameDate?: boolean
    simulated?: boolean
    simulationLog?: boolean
    matchType?: boolean
    tournamentId?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeScore?: boolean
    awayScore?: boolean
    gameDate?: boolean
    simulated?: boolean
    simulationLog?: boolean
    matchType?: boolean
    tournamentId?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "homeTeamId" | "awayTeamId" | "homeScore" | "awayScore" | "gameDate" | "simulated" | "simulationLog" | "matchType" | "tournamentId" | "round" | "status" | "createdAt", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Game$leagueArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    tournament?: boolean | Game$tournamentArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs> | null
      homeTeam: Prisma.$TeamPayload<ExtArgs>
      awayTeam: Prisma.$TeamPayload<ExtArgs>
      tournament: Prisma.$TournamentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leagueId: number | null
      homeTeamId: number
      awayTeamId: number
      homeScore: number | null
      awayScore: number | null
      gameDate: Date
      simulated: boolean
      simulationLog: Prisma.JsonValue | null
      matchType: $Enums.MatchType
      tournamentId: number | null
      round: number | null
      status: $Enums.GameStatus
      createdAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends Game$leagueArgs<ExtArgs> = {}>(args?: Subset<T, Game$leagueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    homeTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    awayTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends Game$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, Game$tournamentArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'Int'>
    readonly leagueId: FieldRef<"Game", 'Int'>
    readonly homeTeamId: FieldRef<"Game", 'Int'>
    readonly awayTeamId: FieldRef<"Game", 'Int'>
    readonly homeScore: FieldRef<"Game", 'Int'>
    readonly awayScore: FieldRef<"Game", 'Int'>
    readonly gameDate: FieldRef<"Game", 'DateTime'>
    readonly simulated: FieldRef<"Game", 'Boolean'>
    readonly simulationLog: FieldRef<"Game", 'Json'>
    readonly matchType: FieldRef<"Game", 'MatchType'>
    readonly tournamentId: FieldRef<"Game", 'Int'>
    readonly round: FieldRef<"Game", 'Int'>
    readonly status: FieldRef<"Game", 'GameStatus'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.league
   */
  export type Game$leagueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
  }

  /**
   * Game.tournament
   */
  export type Game$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    seasonNumber: number | null
    currentDay: number | null
  }

  export type SeasonSumAggregateOutputType = {
    seasonNumber: number | null
    currentDay: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    seasonNumber: number | null
    startDate: Date | null
    endDate: Date | null
    currentDay: number | null
    phase: $Enums.SeasonPhase | null
    createdAt: Date | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    seasonNumber: number | null
    startDate: Date | null
    endDate: Date | null
    currentDay: number | null
    phase: $Enums.SeasonPhase | null
    createdAt: Date | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    seasonNumber: number
    startDate: number
    endDate: number
    currentDay: number
    phase: number
    createdAt: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    seasonNumber?: true
    currentDay?: true
  }

  export type SeasonSumAggregateInputType = {
    seasonNumber?: true
    currentDay?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    seasonNumber?: true
    startDate?: true
    endDate?: true
    currentDay?: true
    phase?: true
    createdAt?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    seasonNumber?: true
    startDate?: true
    endDate?: true
    currentDay?: true
    phase?: true
    createdAt?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    seasonNumber?: true
    startDate?: true
    endDate?: true
    currentDay?: true
    phase?: true
    createdAt?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    seasonNumber: number
    startDate: Date
    endDate: Date
    currentDay: number
    phase: $Enums.SeasonPhase
    createdAt: Date
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    currentDay?: boolean
    phase?: boolean
    createdAt?: boolean
    leagues?: boolean | Season$leaguesArgs<ExtArgs>
    tryoutHistory?: boolean | Season$tryoutHistoryArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    currentDay?: boolean
    phase?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    currentDay?: boolean
    phase?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    seasonNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    currentDay?: boolean
    phase?: boolean
    createdAt?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seasonNumber" | "startDate" | "endDate" | "currentDay" | "phase" | "createdAt", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leagues?: boolean | Season$leaguesArgs<ExtArgs>
    tryoutHistory?: boolean | Season$tryoutHistoryArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      leagues: Prisma.$LeaguePayload<ExtArgs>[]
      tryoutHistory: Prisma.$TryoutHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seasonNumber: number
      startDate: Date
      endDate: Date
      currentDay: number
      phase: $Enums.SeasonPhase
      createdAt: Date
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons and returns the data updated in the database.
     * @param {SeasonUpdateManyAndReturnArgs} args - Arguments to update many Seasons.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leagues<T extends Season$leaguesArgs<ExtArgs> = {}>(args?: Subset<T, Season$leaguesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tryoutHistory<T extends Season$tryoutHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Season$tryoutHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly seasonNumber: FieldRef<"Season", 'Int'>
    readonly startDate: FieldRef<"Season", 'DateTime'>
    readonly endDate: FieldRef<"Season", 'DateTime'>
    readonly currentDay: FieldRef<"Season", 'Int'>
    readonly phase: FieldRef<"Season", 'SeasonPhase'>
    readonly createdAt: FieldRef<"Season", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season updateManyAndReturn
   */
  export type SeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season.leagues
   */
  export type Season$leaguesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    cursor?: LeagueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * Season.tryoutHistory
   */
  export type Season$tryoutHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    where?: TryoutHistoryWhereInput
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    cursor?: TryoutHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    linkTo: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    linkTo: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    teamId: number
    message: number
    type: number
    isRead: number
    linkTo: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    teamId?: true
    message?: true
    type?: true
    isRead?: true
    linkTo?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    teamId?: true
    message?: true
    type?: true
    isRead?: true
    linkTo?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    teamId?: true
    message?: true
    type?: true
    isRead?: true
    linkTo?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    teamId: number
    message: string
    type: $Enums.NotificationType
    isRead: boolean
    linkTo: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    linkTo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    linkTo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    linkTo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    teamId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    linkTo?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "message" | "type" | "isRead" | "linkTo" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      message: string
      type: $Enums.NotificationType
      isRead: boolean
      linkTo: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly teamId: FieldRef<"Notification", 'Int'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly linkTo: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model TryoutPack
   */

  export type AggregateTryoutPack = {
    _count: TryoutPackCountAggregateOutputType | null
    _avg: TryoutPackAvgAggregateOutputType | null
    _sum: TryoutPackSumAggregateOutputType | null
    _min: TryoutPackMinAggregateOutputType | null
    _max: TryoutPackMaxAggregateOutputType | null
  }

  export type TryoutPackAvgAggregateOutputType = {
    id: number | null
    creditCost: number | null
    gemCost: number | null
    numPlayers: number | null
  }

  export type TryoutPackSumAggregateOutputType = {
    id: number | null
    creditCost: bigint | null
    gemCost: number | null
    numPlayers: number | null
  }

  export type TryoutPackMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    creditCost: bigint | null
    gemCost: number | null
    numPlayers: number | null
    qualityTier: string | null
  }

  export type TryoutPackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    creditCost: bigint | null
    gemCost: number | null
    numPlayers: number | null
    qualityTier: string | null
  }

  export type TryoutPackCountAggregateOutputType = {
    id: number
    name: number
    description: number
    creditCost: number
    gemCost: number
    numPlayers: number
    qualityTier: number
    _all: number
  }


  export type TryoutPackAvgAggregateInputType = {
    id?: true
    creditCost?: true
    gemCost?: true
    numPlayers?: true
  }

  export type TryoutPackSumAggregateInputType = {
    id?: true
    creditCost?: true
    gemCost?: true
    numPlayers?: true
  }

  export type TryoutPackMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creditCost?: true
    gemCost?: true
    numPlayers?: true
    qualityTier?: true
  }

  export type TryoutPackMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creditCost?: true
    gemCost?: true
    numPlayers?: true
    qualityTier?: true
  }

  export type TryoutPackCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creditCost?: true
    gemCost?: true
    numPlayers?: true
    qualityTier?: true
    _all?: true
  }

  export type TryoutPackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TryoutPack to aggregate.
     */
    where?: TryoutPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutPacks to fetch.
     */
    orderBy?: TryoutPackOrderByWithRelationInput | TryoutPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TryoutPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TryoutPacks
    **/
    _count?: true | TryoutPackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TryoutPackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TryoutPackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TryoutPackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TryoutPackMaxAggregateInputType
  }

  export type GetTryoutPackAggregateType<T extends TryoutPackAggregateArgs> = {
        [P in keyof T & keyof AggregateTryoutPack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTryoutPack[P]>
      : GetScalarType<T[P], AggregateTryoutPack[P]>
  }




  export type TryoutPackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TryoutPackWhereInput
    orderBy?: TryoutPackOrderByWithAggregationInput | TryoutPackOrderByWithAggregationInput[]
    by: TryoutPackScalarFieldEnum[] | TryoutPackScalarFieldEnum
    having?: TryoutPackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TryoutPackCountAggregateInputType | true
    _avg?: TryoutPackAvgAggregateInputType
    _sum?: TryoutPackSumAggregateInputType
    _min?: TryoutPackMinAggregateInputType
    _max?: TryoutPackMaxAggregateInputType
  }

  export type TryoutPackGroupByOutputType = {
    id: number
    name: string
    description: string
    creditCost: bigint
    gemCost: number | null
    numPlayers: number
    qualityTier: string
    _count: TryoutPackCountAggregateOutputType | null
    _avg: TryoutPackAvgAggregateOutputType | null
    _sum: TryoutPackSumAggregateOutputType | null
    _min: TryoutPackMinAggregateOutputType | null
    _max: TryoutPackMaxAggregateOutputType | null
  }

  type GetTryoutPackGroupByPayload<T extends TryoutPackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TryoutPackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TryoutPackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TryoutPackGroupByOutputType[P]>
            : GetScalarType<T[P], TryoutPackGroupByOutputType[P]>
        }
      >
    >


  export type TryoutPackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creditCost?: boolean
    gemCost?: boolean
    numPlayers?: boolean
    qualityTier?: boolean
  }, ExtArgs["result"]["tryoutPack"]>

  export type TryoutPackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creditCost?: boolean
    gemCost?: boolean
    numPlayers?: boolean
    qualityTier?: boolean
  }, ExtArgs["result"]["tryoutPack"]>

  export type TryoutPackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creditCost?: boolean
    gemCost?: boolean
    numPlayers?: boolean
    qualityTier?: boolean
  }, ExtArgs["result"]["tryoutPack"]>

  export type TryoutPackSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    creditCost?: boolean
    gemCost?: boolean
    numPlayers?: boolean
    qualityTier?: boolean
  }

  export type TryoutPackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "creditCost" | "gemCost" | "numPlayers" | "qualityTier", ExtArgs["result"]["tryoutPack"]>

  export type $TryoutPackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TryoutPack"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      creditCost: bigint
      gemCost: number | null
      numPlayers: number
      qualityTier: string
    }, ExtArgs["result"]["tryoutPack"]>
    composites: {}
  }

  type TryoutPackGetPayload<S extends boolean | null | undefined | TryoutPackDefaultArgs> = $Result.GetResult<Prisma.$TryoutPackPayload, S>

  type TryoutPackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TryoutPackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TryoutPackCountAggregateInputType | true
    }

  export interface TryoutPackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TryoutPack'], meta: { name: 'TryoutPack' } }
    /**
     * Find zero or one TryoutPack that matches the filter.
     * @param {TryoutPackFindUniqueArgs} args - Arguments to find a TryoutPack
     * @example
     * // Get one TryoutPack
     * const tryoutPack = await prisma.tryoutPack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TryoutPackFindUniqueArgs>(args: SelectSubset<T, TryoutPackFindUniqueArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TryoutPack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TryoutPackFindUniqueOrThrowArgs} args - Arguments to find a TryoutPack
     * @example
     * // Get one TryoutPack
     * const tryoutPack = await prisma.tryoutPack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TryoutPackFindUniqueOrThrowArgs>(args: SelectSubset<T, TryoutPackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TryoutPack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackFindFirstArgs} args - Arguments to find a TryoutPack
     * @example
     * // Get one TryoutPack
     * const tryoutPack = await prisma.tryoutPack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TryoutPackFindFirstArgs>(args?: SelectSubset<T, TryoutPackFindFirstArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TryoutPack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackFindFirstOrThrowArgs} args - Arguments to find a TryoutPack
     * @example
     * // Get one TryoutPack
     * const tryoutPack = await prisma.tryoutPack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TryoutPackFindFirstOrThrowArgs>(args?: SelectSubset<T, TryoutPackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TryoutPacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TryoutPacks
     * const tryoutPacks = await prisma.tryoutPack.findMany()
     * 
     * // Get first 10 TryoutPacks
     * const tryoutPacks = await prisma.tryoutPack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tryoutPackWithIdOnly = await prisma.tryoutPack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TryoutPackFindManyArgs>(args?: SelectSubset<T, TryoutPackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TryoutPack.
     * @param {TryoutPackCreateArgs} args - Arguments to create a TryoutPack.
     * @example
     * // Create one TryoutPack
     * const TryoutPack = await prisma.tryoutPack.create({
     *   data: {
     *     // ... data to create a TryoutPack
     *   }
     * })
     * 
     */
    create<T extends TryoutPackCreateArgs>(args: SelectSubset<T, TryoutPackCreateArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TryoutPacks.
     * @param {TryoutPackCreateManyArgs} args - Arguments to create many TryoutPacks.
     * @example
     * // Create many TryoutPacks
     * const tryoutPack = await prisma.tryoutPack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TryoutPackCreateManyArgs>(args?: SelectSubset<T, TryoutPackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TryoutPacks and returns the data saved in the database.
     * @param {TryoutPackCreateManyAndReturnArgs} args - Arguments to create many TryoutPacks.
     * @example
     * // Create many TryoutPacks
     * const tryoutPack = await prisma.tryoutPack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TryoutPacks and only return the `id`
     * const tryoutPackWithIdOnly = await prisma.tryoutPack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TryoutPackCreateManyAndReturnArgs>(args?: SelectSubset<T, TryoutPackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TryoutPack.
     * @param {TryoutPackDeleteArgs} args - Arguments to delete one TryoutPack.
     * @example
     * // Delete one TryoutPack
     * const TryoutPack = await prisma.tryoutPack.delete({
     *   where: {
     *     // ... filter to delete one TryoutPack
     *   }
     * })
     * 
     */
    delete<T extends TryoutPackDeleteArgs>(args: SelectSubset<T, TryoutPackDeleteArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TryoutPack.
     * @param {TryoutPackUpdateArgs} args - Arguments to update one TryoutPack.
     * @example
     * // Update one TryoutPack
     * const tryoutPack = await prisma.tryoutPack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TryoutPackUpdateArgs>(args: SelectSubset<T, TryoutPackUpdateArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TryoutPacks.
     * @param {TryoutPackDeleteManyArgs} args - Arguments to filter TryoutPacks to delete.
     * @example
     * // Delete a few TryoutPacks
     * const { count } = await prisma.tryoutPack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TryoutPackDeleteManyArgs>(args?: SelectSubset<T, TryoutPackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TryoutPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TryoutPacks
     * const tryoutPack = await prisma.tryoutPack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TryoutPackUpdateManyArgs>(args: SelectSubset<T, TryoutPackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TryoutPacks and returns the data updated in the database.
     * @param {TryoutPackUpdateManyAndReturnArgs} args - Arguments to update many TryoutPacks.
     * @example
     * // Update many TryoutPacks
     * const tryoutPack = await prisma.tryoutPack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TryoutPacks and only return the `id`
     * const tryoutPackWithIdOnly = await prisma.tryoutPack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TryoutPackUpdateManyAndReturnArgs>(args: SelectSubset<T, TryoutPackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TryoutPack.
     * @param {TryoutPackUpsertArgs} args - Arguments to update or create a TryoutPack.
     * @example
     * // Update or create a TryoutPack
     * const tryoutPack = await prisma.tryoutPack.upsert({
     *   create: {
     *     // ... data to create a TryoutPack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TryoutPack we want to update
     *   }
     * })
     */
    upsert<T extends TryoutPackUpsertArgs>(args: SelectSubset<T, TryoutPackUpsertArgs<ExtArgs>>): Prisma__TryoutPackClient<$Result.GetResult<Prisma.$TryoutPackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TryoutPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackCountArgs} args - Arguments to filter TryoutPacks to count.
     * @example
     * // Count the number of TryoutPacks
     * const count = await prisma.tryoutPack.count({
     *   where: {
     *     // ... the filter for the TryoutPacks we want to count
     *   }
     * })
    **/
    count<T extends TryoutPackCountArgs>(
      args?: Subset<T, TryoutPackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TryoutPackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TryoutPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TryoutPackAggregateArgs>(args: Subset<T, TryoutPackAggregateArgs>): Prisma.PrismaPromise<GetTryoutPackAggregateType<T>>

    /**
     * Group by TryoutPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutPackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TryoutPackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TryoutPackGroupByArgs['orderBy'] }
        : { orderBy?: TryoutPackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TryoutPackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTryoutPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TryoutPack model
   */
  readonly fields: TryoutPackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TryoutPack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TryoutPackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TryoutPack model
   */
  interface TryoutPackFieldRefs {
    readonly id: FieldRef<"TryoutPack", 'Int'>
    readonly name: FieldRef<"TryoutPack", 'String'>
    readonly description: FieldRef<"TryoutPack", 'String'>
    readonly creditCost: FieldRef<"TryoutPack", 'BigInt'>
    readonly gemCost: FieldRef<"TryoutPack", 'Int'>
    readonly numPlayers: FieldRef<"TryoutPack", 'Int'>
    readonly qualityTier: FieldRef<"TryoutPack", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TryoutPack findUnique
   */
  export type TryoutPackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter, which TryoutPack to fetch.
     */
    where: TryoutPackWhereUniqueInput
  }

  /**
   * TryoutPack findUniqueOrThrow
   */
  export type TryoutPackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter, which TryoutPack to fetch.
     */
    where: TryoutPackWhereUniqueInput
  }

  /**
   * TryoutPack findFirst
   */
  export type TryoutPackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter, which TryoutPack to fetch.
     */
    where?: TryoutPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutPacks to fetch.
     */
    orderBy?: TryoutPackOrderByWithRelationInput | TryoutPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TryoutPacks.
     */
    cursor?: TryoutPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TryoutPacks.
     */
    distinct?: TryoutPackScalarFieldEnum | TryoutPackScalarFieldEnum[]
  }

  /**
   * TryoutPack findFirstOrThrow
   */
  export type TryoutPackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter, which TryoutPack to fetch.
     */
    where?: TryoutPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutPacks to fetch.
     */
    orderBy?: TryoutPackOrderByWithRelationInput | TryoutPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TryoutPacks.
     */
    cursor?: TryoutPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TryoutPacks.
     */
    distinct?: TryoutPackScalarFieldEnum | TryoutPackScalarFieldEnum[]
  }

  /**
   * TryoutPack findMany
   */
  export type TryoutPackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter, which TryoutPacks to fetch.
     */
    where?: TryoutPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutPacks to fetch.
     */
    orderBy?: TryoutPackOrderByWithRelationInput | TryoutPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TryoutPacks.
     */
    cursor?: TryoutPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutPacks.
     */
    skip?: number
    distinct?: TryoutPackScalarFieldEnum | TryoutPackScalarFieldEnum[]
  }

  /**
   * TryoutPack create
   */
  export type TryoutPackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * The data needed to create a TryoutPack.
     */
    data: XOR<TryoutPackCreateInput, TryoutPackUncheckedCreateInput>
  }

  /**
   * TryoutPack createMany
   */
  export type TryoutPackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TryoutPacks.
     */
    data: TryoutPackCreateManyInput | TryoutPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TryoutPack createManyAndReturn
   */
  export type TryoutPackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * The data used to create many TryoutPacks.
     */
    data: TryoutPackCreateManyInput | TryoutPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TryoutPack update
   */
  export type TryoutPackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * The data needed to update a TryoutPack.
     */
    data: XOR<TryoutPackUpdateInput, TryoutPackUncheckedUpdateInput>
    /**
     * Choose, which TryoutPack to update.
     */
    where: TryoutPackWhereUniqueInput
  }

  /**
   * TryoutPack updateMany
   */
  export type TryoutPackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TryoutPacks.
     */
    data: XOR<TryoutPackUpdateManyMutationInput, TryoutPackUncheckedUpdateManyInput>
    /**
     * Filter which TryoutPacks to update
     */
    where?: TryoutPackWhereInput
    /**
     * Limit how many TryoutPacks to update.
     */
    limit?: number
  }

  /**
   * TryoutPack updateManyAndReturn
   */
  export type TryoutPackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * The data used to update TryoutPacks.
     */
    data: XOR<TryoutPackUpdateManyMutationInput, TryoutPackUncheckedUpdateManyInput>
    /**
     * Filter which TryoutPacks to update
     */
    where?: TryoutPackWhereInput
    /**
     * Limit how many TryoutPacks to update.
     */
    limit?: number
  }

  /**
   * TryoutPack upsert
   */
  export type TryoutPackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * The filter to search for the TryoutPack to update in case it exists.
     */
    where: TryoutPackWhereUniqueInput
    /**
     * In case the TryoutPack found by the `where` argument doesn't exist, create a new TryoutPack with this data.
     */
    create: XOR<TryoutPackCreateInput, TryoutPackUncheckedCreateInput>
    /**
     * In case the TryoutPack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TryoutPackUpdateInput, TryoutPackUncheckedUpdateInput>
  }

  /**
   * TryoutPack delete
   */
  export type TryoutPackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
    /**
     * Filter which TryoutPack to delete.
     */
    where: TryoutPackWhereUniqueInput
  }

  /**
   * TryoutPack deleteMany
   */
  export type TryoutPackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TryoutPacks to delete
     */
    where?: TryoutPackWhereInput
    /**
     * Limit how many TryoutPacks to delete.
     */
    limit?: number
  }

  /**
   * TryoutPack without action
   */
  export type TryoutPackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutPack
     */
    select?: TryoutPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutPack
     */
    omit?: TryoutPackOmit<ExtArgs> | null
  }


  /**
   * Model TryoutHistory
   */

  export type AggregateTryoutHistory = {
    _count: TryoutHistoryCountAggregateOutputType | null
    _avg: TryoutHistoryAvgAggregateOutputType | null
    _sum: TryoutHistorySumAggregateOutputType | null
    _min: TryoutHistoryMinAggregateOutputType | null
    _max: TryoutHistoryMaxAggregateOutputType | null
  }

  export type TryoutHistoryAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    cost: number | null
    playersAdded: number | null
    playerId: number | null
  }

  export type TryoutHistorySumAggregateOutputType = {
    id: number | null
    teamId: number | null
    cost: number | null
    playersAdded: number | null
    playerId: number | null
  }

  export type TryoutHistoryMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    seasonId: string | null
    tryoutType: string | null
    cost: number | null
    playersAdded: number | null
    conductedAt: Date | null
    playerId: number | null
  }

  export type TryoutHistoryMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    seasonId: string | null
    tryoutType: string | null
    cost: number | null
    playersAdded: number | null
    conductedAt: Date | null
    playerId: number | null
  }

  export type TryoutHistoryCountAggregateOutputType = {
    id: number
    teamId: number
    seasonId: number
    tryoutType: number
    cost: number
    playersAdded: number
    conductedAt: number
    playerId: number
    _all: number
  }


  export type TryoutHistoryAvgAggregateInputType = {
    id?: true
    teamId?: true
    cost?: true
    playersAdded?: true
    playerId?: true
  }

  export type TryoutHistorySumAggregateInputType = {
    id?: true
    teamId?: true
    cost?: true
    playersAdded?: true
    playerId?: true
  }

  export type TryoutHistoryMinAggregateInputType = {
    id?: true
    teamId?: true
    seasonId?: true
    tryoutType?: true
    cost?: true
    playersAdded?: true
    conductedAt?: true
    playerId?: true
  }

  export type TryoutHistoryMaxAggregateInputType = {
    id?: true
    teamId?: true
    seasonId?: true
    tryoutType?: true
    cost?: true
    playersAdded?: true
    conductedAt?: true
    playerId?: true
  }

  export type TryoutHistoryCountAggregateInputType = {
    id?: true
    teamId?: true
    seasonId?: true
    tryoutType?: true
    cost?: true
    playersAdded?: true
    conductedAt?: true
    playerId?: true
    _all?: true
  }

  export type TryoutHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TryoutHistory to aggregate.
     */
    where?: TryoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutHistories to fetch.
     */
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TryoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TryoutHistories
    **/
    _count?: true | TryoutHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TryoutHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TryoutHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TryoutHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TryoutHistoryMaxAggregateInputType
  }

  export type GetTryoutHistoryAggregateType<T extends TryoutHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTryoutHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTryoutHistory[P]>
      : GetScalarType<T[P], AggregateTryoutHistory[P]>
  }




  export type TryoutHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TryoutHistoryWhereInput
    orderBy?: TryoutHistoryOrderByWithAggregationInput | TryoutHistoryOrderByWithAggregationInput[]
    by: TryoutHistoryScalarFieldEnum[] | TryoutHistoryScalarFieldEnum
    having?: TryoutHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TryoutHistoryCountAggregateInputType | true
    _avg?: TryoutHistoryAvgAggregateInputType
    _sum?: TryoutHistorySumAggregateInputType
    _min?: TryoutHistoryMinAggregateInputType
    _max?: TryoutHistoryMaxAggregateInputType
  }

  export type TryoutHistoryGroupByOutputType = {
    id: number
    teamId: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt: Date
    playerId: number | null
    _count: TryoutHistoryCountAggregateOutputType | null
    _avg: TryoutHistoryAvgAggregateOutputType | null
    _sum: TryoutHistorySumAggregateOutputType | null
    _min: TryoutHistoryMinAggregateOutputType | null
    _max: TryoutHistoryMaxAggregateOutputType | null
  }

  type GetTryoutHistoryGroupByPayload<T extends TryoutHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TryoutHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TryoutHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TryoutHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TryoutHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TryoutHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    seasonId?: boolean
    tryoutType?: boolean
    cost?: boolean
    playersAdded?: boolean
    conductedAt?: boolean
    playerId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }, ExtArgs["result"]["tryoutHistory"]>

  export type TryoutHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    seasonId?: boolean
    tryoutType?: boolean
    cost?: boolean
    playersAdded?: boolean
    conductedAt?: boolean
    playerId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }, ExtArgs["result"]["tryoutHistory"]>

  export type TryoutHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    seasonId?: boolean
    tryoutType?: boolean
    cost?: boolean
    playersAdded?: boolean
    conductedAt?: boolean
    playerId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }, ExtArgs["result"]["tryoutHistory"]>

  export type TryoutHistorySelectScalar = {
    id?: boolean
    teamId?: boolean
    seasonId?: boolean
    tryoutType?: boolean
    cost?: boolean
    playersAdded?: boolean
    conductedAt?: boolean
    playerId?: boolean
  }

  export type TryoutHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "seasonId" | "tryoutType" | "cost" | "playersAdded" | "conductedAt" | "playerId", ExtArgs["result"]["tryoutHistory"]>
  export type TryoutHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }
  export type TryoutHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }
  export type TryoutHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    player?: boolean | TryoutHistory$playerArgs<ExtArgs>
  }

  export type $TryoutHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TryoutHistory"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      seasonId: string
      tryoutType: string
      cost: number
      playersAdded: number
      conductedAt: Date
      playerId: number | null
    }, ExtArgs["result"]["tryoutHistory"]>
    composites: {}
  }

  type TryoutHistoryGetPayload<S extends boolean | null | undefined | TryoutHistoryDefaultArgs> = $Result.GetResult<Prisma.$TryoutHistoryPayload, S>

  type TryoutHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TryoutHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TryoutHistoryCountAggregateInputType | true
    }

  export interface TryoutHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TryoutHistory'], meta: { name: 'TryoutHistory' } }
    /**
     * Find zero or one TryoutHistory that matches the filter.
     * @param {TryoutHistoryFindUniqueArgs} args - Arguments to find a TryoutHistory
     * @example
     * // Get one TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TryoutHistoryFindUniqueArgs>(args: SelectSubset<T, TryoutHistoryFindUniqueArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TryoutHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TryoutHistoryFindUniqueOrThrowArgs} args - Arguments to find a TryoutHistory
     * @example
     * // Get one TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TryoutHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TryoutHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TryoutHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryFindFirstArgs} args - Arguments to find a TryoutHistory
     * @example
     * // Get one TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TryoutHistoryFindFirstArgs>(args?: SelectSubset<T, TryoutHistoryFindFirstArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TryoutHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryFindFirstOrThrowArgs} args - Arguments to find a TryoutHistory
     * @example
     * // Get one TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TryoutHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TryoutHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TryoutHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TryoutHistories
     * const tryoutHistories = await prisma.tryoutHistory.findMany()
     * 
     * // Get first 10 TryoutHistories
     * const tryoutHistories = await prisma.tryoutHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tryoutHistoryWithIdOnly = await prisma.tryoutHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TryoutHistoryFindManyArgs>(args?: SelectSubset<T, TryoutHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TryoutHistory.
     * @param {TryoutHistoryCreateArgs} args - Arguments to create a TryoutHistory.
     * @example
     * // Create one TryoutHistory
     * const TryoutHistory = await prisma.tryoutHistory.create({
     *   data: {
     *     // ... data to create a TryoutHistory
     *   }
     * })
     * 
     */
    create<T extends TryoutHistoryCreateArgs>(args: SelectSubset<T, TryoutHistoryCreateArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TryoutHistories.
     * @param {TryoutHistoryCreateManyArgs} args - Arguments to create many TryoutHistories.
     * @example
     * // Create many TryoutHistories
     * const tryoutHistory = await prisma.tryoutHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TryoutHistoryCreateManyArgs>(args?: SelectSubset<T, TryoutHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TryoutHistories and returns the data saved in the database.
     * @param {TryoutHistoryCreateManyAndReturnArgs} args - Arguments to create many TryoutHistories.
     * @example
     * // Create many TryoutHistories
     * const tryoutHistory = await prisma.tryoutHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TryoutHistories and only return the `id`
     * const tryoutHistoryWithIdOnly = await prisma.tryoutHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TryoutHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TryoutHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TryoutHistory.
     * @param {TryoutHistoryDeleteArgs} args - Arguments to delete one TryoutHistory.
     * @example
     * // Delete one TryoutHistory
     * const TryoutHistory = await prisma.tryoutHistory.delete({
     *   where: {
     *     // ... filter to delete one TryoutHistory
     *   }
     * })
     * 
     */
    delete<T extends TryoutHistoryDeleteArgs>(args: SelectSubset<T, TryoutHistoryDeleteArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TryoutHistory.
     * @param {TryoutHistoryUpdateArgs} args - Arguments to update one TryoutHistory.
     * @example
     * // Update one TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TryoutHistoryUpdateArgs>(args: SelectSubset<T, TryoutHistoryUpdateArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TryoutHistories.
     * @param {TryoutHistoryDeleteManyArgs} args - Arguments to filter TryoutHistories to delete.
     * @example
     * // Delete a few TryoutHistories
     * const { count } = await prisma.tryoutHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TryoutHistoryDeleteManyArgs>(args?: SelectSubset<T, TryoutHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TryoutHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TryoutHistories
     * const tryoutHistory = await prisma.tryoutHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TryoutHistoryUpdateManyArgs>(args: SelectSubset<T, TryoutHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TryoutHistories and returns the data updated in the database.
     * @param {TryoutHistoryUpdateManyAndReturnArgs} args - Arguments to update many TryoutHistories.
     * @example
     * // Update many TryoutHistories
     * const tryoutHistory = await prisma.tryoutHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TryoutHistories and only return the `id`
     * const tryoutHistoryWithIdOnly = await prisma.tryoutHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TryoutHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TryoutHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TryoutHistory.
     * @param {TryoutHistoryUpsertArgs} args - Arguments to update or create a TryoutHistory.
     * @example
     * // Update or create a TryoutHistory
     * const tryoutHistory = await prisma.tryoutHistory.upsert({
     *   create: {
     *     // ... data to create a TryoutHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TryoutHistory we want to update
     *   }
     * })
     */
    upsert<T extends TryoutHistoryUpsertArgs>(args: SelectSubset<T, TryoutHistoryUpsertArgs<ExtArgs>>): Prisma__TryoutHistoryClient<$Result.GetResult<Prisma.$TryoutHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TryoutHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryCountArgs} args - Arguments to filter TryoutHistories to count.
     * @example
     * // Count the number of TryoutHistories
     * const count = await prisma.tryoutHistory.count({
     *   where: {
     *     // ... the filter for the TryoutHistories we want to count
     *   }
     * })
    **/
    count<T extends TryoutHistoryCountArgs>(
      args?: Subset<T, TryoutHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TryoutHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TryoutHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TryoutHistoryAggregateArgs>(args: Subset<T, TryoutHistoryAggregateArgs>): Prisma.PrismaPromise<GetTryoutHistoryAggregateType<T>>

    /**
     * Group by TryoutHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TryoutHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TryoutHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TryoutHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TryoutHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TryoutHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTryoutHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TryoutHistory model
   */
  readonly fields: TryoutHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TryoutHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TryoutHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends TryoutHistory$playerArgs<ExtArgs> = {}>(args?: Subset<T, TryoutHistory$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TryoutHistory model
   */
  interface TryoutHistoryFieldRefs {
    readonly id: FieldRef<"TryoutHistory", 'Int'>
    readonly teamId: FieldRef<"TryoutHistory", 'Int'>
    readonly seasonId: FieldRef<"TryoutHistory", 'String'>
    readonly tryoutType: FieldRef<"TryoutHistory", 'String'>
    readonly cost: FieldRef<"TryoutHistory", 'Int'>
    readonly playersAdded: FieldRef<"TryoutHistory", 'Int'>
    readonly conductedAt: FieldRef<"TryoutHistory", 'DateTime'>
    readonly playerId: FieldRef<"TryoutHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TryoutHistory findUnique
   */
  export type TryoutHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TryoutHistory to fetch.
     */
    where: TryoutHistoryWhereUniqueInput
  }

  /**
   * TryoutHistory findUniqueOrThrow
   */
  export type TryoutHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TryoutHistory to fetch.
     */
    where: TryoutHistoryWhereUniqueInput
  }

  /**
   * TryoutHistory findFirst
   */
  export type TryoutHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TryoutHistory to fetch.
     */
    where?: TryoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutHistories to fetch.
     */
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TryoutHistories.
     */
    cursor?: TryoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TryoutHistories.
     */
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * TryoutHistory findFirstOrThrow
   */
  export type TryoutHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TryoutHistory to fetch.
     */
    where?: TryoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutHistories to fetch.
     */
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TryoutHistories.
     */
    cursor?: TryoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TryoutHistories.
     */
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * TryoutHistory findMany
   */
  export type TryoutHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TryoutHistories to fetch.
     */
    where?: TryoutHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TryoutHistories to fetch.
     */
    orderBy?: TryoutHistoryOrderByWithRelationInput | TryoutHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TryoutHistories.
     */
    cursor?: TryoutHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TryoutHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TryoutHistories.
     */
    skip?: number
    distinct?: TryoutHistoryScalarFieldEnum | TryoutHistoryScalarFieldEnum[]
  }

  /**
   * TryoutHistory create
   */
  export type TryoutHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TryoutHistory.
     */
    data: XOR<TryoutHistoryCreateInput, TryoutHistoryUncheckedCreateInput>
  }

  /**
   * TryoutHistory createMany
   */
  export type TryoutHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TryoutHistories.
     */
    data: TryoutHistoryCreateManyInput | TryoutHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TryoutHistory createManyAndReturn
   */
  export type TryoutHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many TryoutHistories.
     */
    data: TryoutHistoryCreateManyInput | TryoutHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TryoutHistory update
   */
  export type TryoutHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TryoutHistory.
     */
    data: XOR<TryoutHistoryUpdateInput, TryoutHistoryUncheckedUpdateInput>
    /**
     * Choose, which TryoutHistory to update.
     */
    where: TryoutHistoryWhereUniqueInput
  }

  /**
   * TryoutHistory updateMany
   */
  export type TryoutHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TryoutHistories.
     */
    data: XOR<TryoutHistoryUpdateManyMutationInput, TryoutHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TryoutHistories to update
     */
    where?: TryoutHistoryWhereInput
    /**
     * Limit how many TryoutHistories to update.
     */
    limit?: number
  }

  /**
   * TryoutHistory updateManyAndReturn
   */
  export type TryoutHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * The data used to update TryoutHistories.
     */
    data: XOR<TryoutHistoryUpdateManyMutationInput, TryoutHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TryoutHistories to update
     */
    where?: TryoutHistoryWhereInput
    /**
     * Limit how many TryoutHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TryoutHistory upsert
   */
  export type TryoutHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TryoutHistory to update in case it exists.
     */
    where: TryoutHistoryWhereUniqueInput
    /**
     * In case the TryoutHistory found by the `where` argument doesn't exist, create a new TryoutHistory with this data.
     */
    create: XOR<TryoutHistoryCreateInput, TryoutHistoryUncheckedCreateInput>
    /**
     * In case the TryoutHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TryoutHistoryUpdateInput, TryoutHistoryUncheckedUpdateInput>
  }

  /**
   * TryoutHistory delete
   */
  export type TryoutHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
    /**
     * Filter which TryoutHistory to delete.
     */
    where: TryoutHistoryWhereUniqueInput
  }

  /**
   * TryoutHistory deleteMany
   */
  export type TryoutHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TryoutHistories to delete
     */
    where?: TryoutHistoryWhereInput
    /**
     * Limit how many TryoutHistories to delete.
     */
    limit?: number
  }

  /**
   * TryoutHistory.player
   */
  export type TryoutHistory$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * TryoutHistory without action
   */
  export type TryoutHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TryoutHistory
     */
    select?: TryoutHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TryoutHistory
     */
    omit?: TryoutHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TryoutHistoryInclude<ExtArgs> | null
  }


  /**
   * Model GemPack
   */

  export type AggregateGemPack = {
    _count: GemPackCountAggregateOutputType | null
    _avg: GemPackAvgAggregateOutputType | null
    _sum: GemPackSumAggregateOutputType | null
    _min: GemPackMinAggregateOutputType | null
    _max: GemPackMaxAggregateOutputType | null
  }

  export type GemPackAvgAggregateOutputType = {
    id: number | null
    gemAmount: number | null
    usdPrice: number | null
  }

  export type GemPackSumAggregateOutputType = {
    id: number | null
    gemAmount: number | null
    usdPrice: number | null
  }

  export type GemPackMinAggregateOutputType = {
    id: number | null
    name: string | null
    gemAmount: number | null
    usdPrice: number | null
    productId: string | null
  }

  export type GemPackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    gemAmount: number | null
    usdPrice: number | null
    productId: string | null
  }

  export type GemPackCountAggregateOutputType = {
    id: number
    name: number
    gemAmount: number
    usdPrice: number
    productId: number
    _all: number
  }


  export type GemPackAvgAggregateInputType = {
    id?: true
    gemAmount?: true
    usdPrice?: true
  }

  export type GemPackSumAggregateInputType = {
    id?: true
    gemAmount?: true
    usdPrice?: true
  }

  export type GemPackMinAggregateInputType = {
    id?: true
    name?: true
    gemAmount?: true
    usdPrice?: true
    productId?: true
  }

  export type GemPackMaxAggregateInputType = {
    id?: true
    name?: true
    gemAmount?: true
    usdPrice?: true
    productId?: true
  }

  export type GemPackCountAggregateInputType = {
    id?: true
    name?: true
    gemAmount?: true
    usdPrice?: true
    productId?: true
    _all?: true
  }

  export type GemPackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GemPack to aggregate.
     */
    where?: GemPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GemPacks to fetch.
     */
    orderBy?: GemPackOrderByWithRelationInput | GemPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GemPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GemPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GemPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GemPacks
    **/
    _count?: true | GemPackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GemPackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GemPackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GemPackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GemPackMaxAggregateInputType
  }

  export type GetGemPackAggregateType<T extends GemPackAggregateArgs> = {
        [P in keyof T & keyof AggregateGemPack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGemPack[P]>
      : GetScalarType<T[P], AggregateGemPack[P]>
  }




  export type GemPackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GemPackWhereInput
    orderBy?: GemPackOrderByWithAggregationInput | GemPackOrderByWithAggregationInput[]
    by: GemPackScalarFieldEnum[] | GemPackScalarFieldEnum
    having?: GemPackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GemPackCountAggregateInputType | true
    _avg?: GemPackAvgAggregateInputType
    _sum?: GemPackSumAggregateInputType
    _min?: GemPackMinAggregateInputType
    _max?: GemPackMaxAggregateInputType
  }

  export type GemPackGroupByOutputType = {
    id: number
    name: string
    gemAmount: number
    usdPrice: number
    productId: string
    _count: GemPackCountAggregateOutputType | null
    _avg: GemPackAvgAggregateOutputType | null
    _sum: GemPackSumAggregateOutputType | null
    _min: GemPackMinAggregateOutputType | null
    _max: GemPackMaxAggregateOutputType | null
  }

  type GetGemPackGroupByPayload<T extends GemPackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GemPackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GemPackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GemPackGroupByOutputType[P]>
            : GetScalarType<T[P], GemPackGroupByOutputType[P]>
        }
      >
    >


  export type GemPackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gemAmount?: boolean
    usdPrice?: boolean
    productId?: boolean
  }, ExtArgs["result"]["gemPack"]>

  export type GemPackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gemAmount?: boolean
    usdPrice?: boolean
    productId?: boolean
  }, ExtArgs["result"]["gemPack"]>

  export type GemPackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gemAmount?: boolean
    usdPrice?: boolean
    productId?: boolean
  }, ExtArgs["result"]["gemPack"]>

  export type GemPackSelectScalar = {
    id?: boolean
    name?: boolean
    gemAmount?: boolean
    usdPrice?: boolean
    productId?: boolean
  }

  export type GemPackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gemAmount" | "usdPrice" | "productId", ExtArgs["result"]["gemPack"]>

  export type $GemPackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GemPack"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      gemAmount: number
      usdPrice: number
      productId: string
    }, ExtArgs["result"]["gemPack"]>
    composites: {}
  }

  type GemPackGetPayload<S extends boolean | null | undefined | GemPackDefaultArgs> = $Result.GetResult<Prisma.$GemPackPayload, S>

  type GemPackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GemPackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GemPackCountAggregateInputType | true
    }

  export interface GemPackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GemPack'], meta: { name: 'GemPack' } }
    /**
     * Find zero or one GemPack that matches the filter.
     * @param {GemPackFindUniqueArgs} args - Arguments to find a GemPack
     * @example
     * // Get one GemPack
     * const gemPack = await prisma.gemPack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GemPackFindUniqueArgs>(args: SelectSubset<T, GemPackFindUniqueArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GemPack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GemPackFindUniqueOrThrowArgs} args - Arguments to find a GemPack
     * @example
     * // Get one GemPack
     * const gemPack = await prisma.gemPack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GemPackFindUniqueOrThrowArgs>(args: SelectSubset<T, GemPackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GemPack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackFindFirstArgs} args - Arguments to find a GemPack
     * @example
     * // Get one GemPack
     * const gemPack = await prisma.gemPack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GemPackFindFirstArgs>(args?: SelectSubset<T, GemPackFindFirstArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GemPack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackFindFirstOrThrowArgs} args - Arguments to find a GemPack
     * @example
     * // Get one GemPack
     * const gemPack = await prisma.gemPack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GemPackFindFirstOrThrowArgs>(args?: SelectSubset<T, GemPackFindFirstOrThrowArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GemPacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GemPacks
     * const gemPacks = await prisma.gemPack.findMany()
     * 
     * // Get first 10 GemPacks
     * const gemPacks = await prisma.gemPack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gemPackWithIdOnly = await prisma.gemPack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GemPackFindManyArgs>(args?: SelectSubset<T, GemPackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GemPack.
     * @param {GemPackCreateArgs} args - Arguments to create a GemPack.
     * @example
     * // Create one GemPack
     * const GemPack = await prisma.gemPack.create({
     *   data: {
     *     // ... data to create a GemPack
     *   }
     * })
     * 
     */
    create<T extends GemPackCreateArgs>(args: SelectSubset<T, GemPackCreateArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GemPacks.
     * @param {GemPackCreateManyArgs} args - Arguments to create many GemPacks.
     * @example
     * // Create many GemPacks
     * const gemPack = await prisma.gemPack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GemPackCreateManyArgs>(args?: SelectSubset<T, GemPackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GemPacks and returns the data saved in the database.
     * @param {GemPackCreateManyAndReturnArgs} args - Arguments to create many GemPacks.
     * @example
     * // Create many GemPacks
     * const gemPack = await prisma.gemPack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GemPacks and only return the `id`
     * const gemPackWithIdOnly = await prisma.gemPack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GemPackCreateManyAndReturnArgs>(args?: SelectSubset<T, GemPackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GemPack.
     * @param {GemPackDeleteArgs} args - Arguments to delete one GemPack.
     * @example
     * // Delete one GemPack
     * const GemPack = await prisma.gemPack.delete({
     *   where: {
     *     // ... filter to delete one GemPack
     *   }
     * })
     * 
     */
    delete<T extends GemPackDeleteArgs>(args: SelectSubset<T, GemPackDeleteArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GemPack.
     * @param {GemPackUpdateArgs} args - Arguments to update one GemPack.
     * @example
     * // Update one GemPack
     * const gemPack = await prisma.gemPack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GemPackUpdateArgs>(args: SelectSubset<T, GemPackUpdateArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GemPacks.
     * @param {GemPackDeleteManyArgs} args - Arguments to filter GemPacks to delete.
     * @example
     * // Delete a few GemPacks
     * const { count } = await prisma.gemPack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GemPackDeleteManyArgs>(args?: SelectSubset<T, GemPackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GemPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GemPacks
     * const gemPack = await prisma.gemPack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GemPackUpdateManyArgs>(args: SelectSubset<T, GemPackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GemPacks and returns the data updated in the database.
     * @param {GemPackUpdateManyAndReturnArgs} args - Arguments to update many GemPacks.
     * @example
     * // Update many GemPacks
     * const gemPack = await prisma.gemPack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GemPacks and only return the `id`
     * const gemPackWithIdOnly = await prisma.gemPack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GemPackUpdateManyAndReturnArgs>(args: SelectSubset<T, GemPackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GemPack.
     * @param {GemPackUpsertArgs} args - Arguments to update or create a GemPack.
     * @example
     * // Update or create a GemPack
     * const gemPack = await prisma.gemPack.upsert({
     *   create: {
     *     // ... data to create a GemPack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GemPack we want to update
     *   }
     * })
     */
    upsert<T extends GemPackUpsertArgs>(args: SelectSubset<T, GemPackUpsertArgs<ExtArgs>>): Prisma__GemPackClient<$Result.GetResult<Prisma.$GemPackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GemPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackCountArgs} args - Arguments to filter GemPacks to count.
     * @example
     * // Count the number of GemPacks
     * const count = await prisma.gemPack.count({
     *   where: {
     *     // ... the filter for the GemPacks we want to count
     *   }
     * })
    **/
    count<T extends GemPackCountArgs>(
      args?: Subset<T, GemPackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GemPackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GemPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GemPackAggregateArgs>(args: Subset<T, GemPackAggregateArgs>): Prisma.PrismaPromise<GetGemPackAggregateType<T>>

    /**
     * Group by GemPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GemPackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GemPackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GemPackGroupByArgs['orderBy'] }
        : { orderBy?: GemPackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GemPackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGemPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GemPack model
   */
  readonly fields: GemPackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GemPack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GemPackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GemPack model
   */
  interface GemPackFieldRefs {
    readonly id: FieldRef<"GemPack", 'Int'>
    readonly name: FieldRef<"GemPack", 'String'>
    readonly gemAmount: FieldRef<"GemPack", 'Int'>
    readonly usdPrice: FieldRef<"GemPack", 'Float'>
    readonly productId: FieldRef<"GemPack", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GemPack findUnique
   */
  export type GemPackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter, which GemPack to fetch.
     */
    where: GemPackWhereUniqueInput
  }

  /**
   * GemPack findUniqueOrThrow
   */
  export type GemPackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter, which GemPack to fetch.
     */
    where: GemPackWhereUniqueInput
  }

  /**
   * GemPack findFirst
   */
  export type GemPackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter, which GemPack to fetch.
     */
    where?: GemPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GemPacks to fetch.
     */
    orderBy?: GemPackOrderByWithRelationInput | GemPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GemPacks.
     */
    cursor?: GemPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GemPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GemPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GemPacks.
     */
    distinct?: GemPackScalarFieldEnum | GemPackScalarFieldEnum[]
  }

  /**
   * GemPack findFirstOrThrow
   */
  export type GemPackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter, which GemPack to fetch.
     */
    where?: GemPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GemPacks to fetch.
     */
    orderBy?: GemPackOrderByWithRelationInput | GemPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GemPacks.
     */
    cursor?: GemPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GemPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GemPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GemPacks.
     */
    distinct?: GemPackScalarFieldEnum | GemPackScalarFieldEnum[]
  }

  /**
   * GemPack findMany
   */
  export type GemPackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter, which GemPacks to fetch.
     */
    where?: GemPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GemPacks to fetch.
     */
    orderBy?: GemPackOrderByWithRelationInput | GemPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GemPacks.
     */
    cursor?: GemPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GemPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GemPacks.
     */
    skip?: number
    distinct?: GemPackScalarFieldEnum | GemPackScalarFieldEnum[]
  }

  /**
   * GemPack create
   */
  export type GemPackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * The data needed to create a GemPack.
     */
    data: XOR<GemPackCreateInput, GemPackUncheckedCreateInput>
  }

  /**
   * GemPack createMany
   */
  export type GemPackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GemPacks.
     */
    data: GemPackCreateManyInput | GemPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GemPack createManyAndReturn
   */
  export type GemPackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * The data used to create many GemPacks.
     */
    data: GemPackCreateManyInput | GemPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GemPack update
   */
  export type GemPackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * The data needed to update a GemPack.
     */
    data: XOR<GemPackUpdateInput, GemPackUncheckedUpdateInput>
    /**
     * Choose, which GemPack to update.
     */
    where: GemPackWhereUniqueInput
  }

  /**
   * GemPack updateMany
   */
  export type GemPackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GemPacks.
     */
    data: XOR<GemPackUpdateManyMutationInput, GemPackUncheckedUpdateManyInput>
    /**
     * Filter which GemPacks to update
     */
    where?: GemPackWhereInput
    /**
     * Limit how many GemPacks to update.
     */
    limit?: number
  }

  /**
   * GemPack updateManyAndReturn
   */
  export type GemPackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * The data used to update GemPacks.
     */
    data: XOR<GemPackUpdateManyMutationInput, GemPackUncheckedUpdateManyInput>
    /**
     * Filter which GemPacks to update
     */
    where?: GemPackWhereInput
    /**
     * Limit how many GemPacks to update.
     */
    limit?: number
  }

  /**
   * GemPack upsert
   */
  export type GemPackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * The filter to search for the GemPack to update in case it exists.
     */
    where: GemPackWhereUniqueInput
    /**
     * In case the GemPack found by the `where` argument doesn't exist, create a new GemPack with this data.
     */
    create: XOR<GemPackCreateInput, GemPackUncheckedCreateInput>
    /**
     * In case the GemPack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GemPackUpdateInput, GemPackUncheckedUpdateInput>
  }

  /**
   * GemPack delete
   */
  export type GemPackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
    /**
     * Filter which GemPack to delete.
     */
    where: GemPackWhereUniqueInput
  }

  /**
   * GemPack deleteMany
   */
  export type GemPackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GemPacks to delete
     */
    where?: GemPackWhereInput
    /**
     * Limit how many GemPacks to delete.
     */
    limit?: number
  }

  /**
   * GemPack without action
   */
  export type GemPackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GemPack
     */
    select?: GemPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GemPack
     */
    omit?: GemPackOmit<ExtArgs> | null
  }


  /**
   * Model CreditExchangeRate
   */

  export type AggregateCreditExchangeRate = {
    _count: CreditExchangeRateCountAggregateOutputType | null
    _avg: CreditExchangeRateAvgAggregateOutputType | null
    _sum: CreditExchangeRateSumAggregateOutputType | null
    _min: CreditExchangeRateMinAggregateOutputType | null
    _max: CreditExchangeRateMaxAggregateOutputType | null
  }

  export type CreditExchangeRateAvgAggregateOutputType = {
    id: number | null
    gems: number | null
    credits: number | null
    bonusPercentage: number | null
  }

  export type CreditExchangeRateSumAggregateOutputType = {
    id: number | null
    gems: number | null
    credits: bigint | null
    bonusPercentage: number | null
  }

  export type CreditExchangeRateMinAggregateOutputType = {
    id: number | null
    gems: number | null
    credits: bigint | null
    bonusPercentage: number | null
  }

  export type CreditExchangeRateMaxAggregateOutputType = {
    id: number | null
    gems: number | null
    credits: bigint | null
    bonusPercentage: number | null
  }

  export type CreditExchangeRateCountAggregateOutputType = {
    id: number
    gems: number
    credits: number
    bonusPercentage: number
    _all: number
  }


  export type CreditExchangeRateAvgAggregateInputType = {
    id?: true
    gems?: true
    credits?: true
    bonusPercentage?: true
  }

  export type CreditExchangeRateSumAggregateInputType = {
    id?: true
    gems?: true
    credits?: true
    bonusPercentage?: true
  }

  export type CreditExchangeRateMinAggregateInputType = {
    id?: true
    gems?: true
    credits?: true
    bonusPercentage?: true
  }

  export type CreditExchangeRateMaxAggregateInputType = {
    id?: true
    gems?: true
    credits?: true
    bonusPercentage?: true
  }

  export type CreditExchangeRateCountAggregateInputType = {
    id?: true
    gems?: true
    credits?: true
    bonusPercentage?: true
    _all?: true
  }

  export type CreditExchangeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditExchangeRate to aggregate.
     */
    where?: CreditExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditExchangeRates to fetch.
     */
    orderBy?: CreditExchangeRateOrderByWithRelationInput | CreditExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditExchangeRates
    **/
    _count?: true | CreditExchangeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditExchangeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditExchangeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditExchangeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditExchangeRateMaxAggregateInputType
  }

  export type GetCreditExchangeRateAggregateType<T extends CreditExchangeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditExchangeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditExchangeRate[P]>
      : GetScalarType<T[P], AggregateCreditExchangeRate[P]>
  }




  export type CreditExchangeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditExchangeRateWhereInput
    orderBy?: CreditExchangeRateOrderByWithAggregationInput | CreditExchangeRateOrderByWithAggregationInput[]
    by: CreditExchangeRateScalarFieldEnum[] | CreditExchangeRateScalarFieldEnum
    having?: CreditExchangeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditExchangeRateCountAggregateInputType | true
    _avg?: CreditExchangeRateAvgAggregateInputType
    _sum?: CreditExchangeRateSumAggregateInputType
    _min?: CreditExchangeRateMinAggregateInputType
    _max?: CreditExchangeRateMaxAggregateInputType
  }

  export type CreditExchangeRateGroupByOutputType = {
    id: number
    gems: number
    credits: bigint
    bonusPercentage: number
    _count: CreditExchangeRateCountAggregateOutputType | null
    _avg: CreditExchangeRateAvgAggregateOutputType | null
    _sum: CreditExchangeRateSumAggregateOutputType | null
    _min: CreditExchangeRateMinAggregateOutputType | null
    _max: CreditExchangeRateMaxAggregateOutputType | null
  }

  type GetCreditExchangeRateGroupByPayload<T extends CreditExchangeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditExchangeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditExchangeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditExchangeRateGroupByOutputType[P]>
            : GetScalarType<T[P], CreditExchangeRateGroupByOutputType[P]>
        }
      >
    >


  export type CreditExchangeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gems?: boolean
    credits?: boolean
    bonusPercentage?: boolean
  }, ExtArgs["result"]["creditExchangeRate"]>

  export type CreditExchangeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gems?: boolean
    credits?: boolean
    bonusPercentage?: boolean
  }, ExtArgs["result"]["creditExchangeRate"]>

  export type CreditExchangeRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gems?: boolean
    credits?: boolean
    bonusPercentage?: boolean
  }, ExtArgs["result"]["creditExchangeRate"]>

  export type CreditExchangeRateSelectScalar = {
    id?: boolean
    gems?: boolean
    credits?: boolean
    bonusPercentage?: boolean
  }

  export type CreditExchangeRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gems" | "credits" | "bonusPercentage", ExtArgs["result"]["creditExchangeRate"]>

  export type $CreditExchangeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditExchangeRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gems: number
      credits: bigint
      bonusPercentage: number
    }, ExtArgs["result"]["creditExchangeRate"]>
    composites: {}
  }

  type CreditExchangeRateGetPayload<S extends boolean | null | undefined | CreditExchangeRateDefaultArgs> = $Result.GetResult<Prisma.$CreditExchangeRatePayload, S>

  type CreditExchangeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditExchangeRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditExchangeRateCountAggregateInputType | true
    }

  export interface CreditExchangeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditExchangeRate'], meta: { name: 'CreditExchangeRate' } }
    /**
     * Find zero or one CreditExchangeRate that matches the filter.
     * @param {CreditExchangeRateFindUniqueArgs} args - Arguments to find a CreditExchangeRate
     * @example
     * // Get one CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditExchangeRateFindUniqueArgs>(args: SelectSubset<T, CreditExchangeRateFindUniqueArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditExchangeRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditExchangeRateFindUniqueOrThrowArgs} args - Arguments to find a CreditExchangeRate
     * @example
     * // Get one CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditExchangeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditExchangeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditExchangeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateFindFirstArgs} args - Arguments to find a CreditExchangeRate
     * @example
     * // Get one CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditExchangeRateFindFirstArgs>(args?: SelectSubset<T, CreditExchangeRateFindFirstArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditExchangeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateFindFirstOrThrowArgs} args - Arguments to find a CreditExchangeRate
     * @example
     * // Get one CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditExchangeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditExchangeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditExchangeRates
     * const creditExchangeRates = await prisma.creditExchangeRate.findMany()
     * 
     * // Get first 10 CreditExchangeRates
     * const creditExchangeRates = await prisma.creditExchangeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditExchangeRateWithIdOnly = await prisma.creditExchangeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditExchangeRateFindManyArgs>(args?: SelectSubset<T, CreditExchangeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditExchangeRate.
     * @param {CreditExchangeRateCreateArgs} args - Arguments to create a CreditExchangeRate.
     * @example
     * // Create one CreditExchangeRate
     * const CreditExchangeRate = await prisma.creditExchangeRate.create({
     *   data: {
     *     // ... data to create a CreditExchangeRate
     *   }
     * })
     * 
     */
    create<T extends CreditExchangeRateCreateArgs>(args: SelectSubset<T, CreditExchangeRateCreateArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditExchangeRates.
     * @param {CreditExchangeRateCreateManyArgs} args - Arguments to create many CreditExchangeRates.
     * @example
     * // Create many CreditExchangeRates
     * const creditExchangeRate = await prisma.creditExchangeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditExchangeRateCreateManyArgs>(args?: SelectSubset<T, CreditExchangeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditExchangeRates and returns the data saved in the database.
     * @param {CreditExchangeRateCreateManyAndReturnArgs} args - Arguments to create many CreditExchangeRates.
     * @example
     * // Create many CreditExchangeRates
     * const creditExchangeRate = await prisma.creditExchangeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditExchangeRates and only return the `id`
     * const creditExchangeRateWithIdOnly = await prisma.creditExchangeRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditExchangeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditExchangeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditExchangeRate.
     * @param {CreditExchangeRateDeleteArgs} args - Arguments to delete one CreditExchangeRate.
     * @example
     * // Delete one CreditExchangeRate
     * const CreditExchangeRate = await prisma.creditExchangeRate.delete({
     *   where: {
     *     // ... filter to delete one CreditExchangeRate
     *   }
     * })
     * 
     */
    delete<T extends CreditExchangeRateDeleteArgs>(args: SelectSubset<T, CreditExchangeRateDeleteArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditExchangeRate.
     * @param {CreditExchangeRateUpdateArgs} args - Arguments to update one CreditExchangeRate.
     * @example
     * // Update one CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditExchangeRateUpdateArgs>(args: SelectSubset<T, CreditExchangeRateUpdateArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditExchangeRates.
     * @param {CreditExchangeRateDeleteManyArgs} args - Arguments to filter CreditExchangeRates to delete.
     * @example
     * // Delete a few CreditExchangeRates
     * const { count } = await prisma.creditExchangeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditExchangeRateDeleteManyArgs>(args?: SelectSubset<T, CreditExchangeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditExchangeRates
     * const creditExchangeRate = await prisma.creditExchangeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditExchangeRateUpdateManyArgs>(args: SelectSubset<T, CreditExchangeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditExchangeRates and returns the data updated in the database.
     * @param {CreditExchangeRateUpdateManyAndReturnArgs} args - Arguments to update many CreditExchangeRates.
     * @example
     * // Update many CreditExchangeRates
     * const creditExchangeRate = await prisma.creditExchangeRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditExchangeRates and only return the `id`
     * const creditExchangeRateWithIdOnly = await prisma.creditExchangeRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditExchangeRateUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditExchangeRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditExchangeRate.
     * @param {CreditExchangeRateUpsertArgs} args - Arguments to update or create a CreditExchangeRate.
     * @example
     * // Update or create a CreditExchangeRate
     * const creditExchangeRate = await prisma.creditExchangeRate.upsert({
     *   create: {
     *     // ... data to create a CreditExchangeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditExchangeRate we want to update
     *   }
     * })
     */
    upsert<T extends CreditExchangeRateUpsertArgs>(args: SelectSubset<T, CreditExchangeRateUpsertArgs<ExtArgs>>): Prisma__CreditExchangeRateClient<$Result.GetResult<Prisma.$CreditExchangeRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateCountArgs} args - Arguments to filter CreditExchangeRates to count.
     * @example
     * // Count the number of CreditExchangeRates
     * const count = await prisma.creditExchangeRate.count({
     *   where: {
     *     // ... the filter for the CreditExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends CreditExchangeRateCountArgs>(
      args?: Subset<T, CreditExchangeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditExchangeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditExchangeRateAggregateArgs>(args: Subset<T, CreditExchangeRateAggregateArgs>): Prisma.PrismaPromise<GetCreditExchangeRateAggregateType<T>>

    /**
     * Group by CreditExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditExchangeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditExchangeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditExchangeRateGroupByArgs['orderBy'] }
        : { orderBy?: CreditExchangeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditExchangeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditExchangeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditExchangeRate model
   */
  readonly fields: CreditExchangeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditExchangeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditExchangeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditExchangeRate model
   */
  interface CreditExchangeRateFieldRefs {
    readonly id: FieldRef<"CreditExchangeRate", 'Int'>
    readonly gems: FieldRef<"CreditExchangeRate", 'Int'>
    readonly credits: FieldRef<"CreditExchangeRate", 'BigInt'>
    readonly bonusPercentage: FieldRef<"CreditExchangeRate", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CreditExchangeRate findUnique
   */
  export type CreditExchangeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which CreditExchangeRate to fetch.
     */
    where: CreditExchangeRateWhereUniqueInput
  }

  /**
   * CreditExchangeRate findUniqueOrThrow
   */
  export type CreditExchangeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which CreditExchangeRate to fetch.
     */
    where: CreditExchangeRateWhereUniqueInput
  }

  /**
   * CreditExchangeRate findFirst
   */
  export type CreditExchangeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which CreditExchangeRate to fetch.
     */
    where?: CreditExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditExchangeRates to fetch.
     */
    orderBy?: CreditExchangeRateOrderByWithRelationInput | CreditExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditExchangeRates.
     */
    cursor?: CreditExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditExchangeRates.
     */
    distinct?: CreditExchangeRateScalarFieldEnum | CreditExchangeRateScalarFieldEnum[]
  }

  /**
   * CreditExchangeRate findFirstOrThrow
   */
  export type CreditExchangeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which CreditExchangeRate to fetch.
     */
    where?: CreditExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditExchangeRates to fetch.
     */
    orderBy?: CreditExchangeRateOrderByWithRelationInput | CreditExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditExchangeRates.
     */
    cursor?: CreditExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditExchangeRates.
     */
    distinct?: CreditExchangeRateScalarFieldEnum | CreditExchangeRateScalarFieldEnum[]
  }

  /**
   * CreditExchangeRate findMany
   */
  export type CreditExchangeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which CreditExchangeRates to fetch.
     */
    where?: CreditExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditExchangeRates to fetch.
     */
    orderBy?: CreditExchangeRateOrderByWithRelationInput | CreditExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditExchangeRates.
     */
    cursor?: CreditExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditExchangeRates.
     */
    skip?: number
    distinct?: CreditExchangeRateScalarFieldEnum | CreditExchangeRateScalarFieldEnum[]
  }

  /**
   * CreditExchangeRate create
   */
  export type CreditExchangeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * The data needed to create a CreditExchangeRate.
     */
    data: XOR<CreditExchangeRateCreateInput, CreditExchangeRateUncheckedCreateInput>
  }

  /**
   * CreditExchangeRate createMany
   */
  export type CreditExchangeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditExchangeRates.
     */
    data: CreditExchangeRateCreateManyInput | CreditExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditExchangeRate createManyAndReturn
   */
  export type CreditExchangeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to create many CreditExchangeRates.
     */
    data: CreditExchangeRateCreateManyInput | CreditExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditExchangeRate update
   */
  export type CreditExchangeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * The data needed to update a CreditExchangeRate.
     */
    data: XOR<CreditExchangeRateUpdateInput, CreditExchangeRateUncheckedUpdateInput>
    /**
     * Choose, which CreditExchangeRate to update.
     */
    where: CreditExchangeRateWhereUniqueInput
  }

  /**
   * CreditExchangeRate updateMany
   */
  export type CreditExchangeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditExchangeRates.
     */
    data: XOR<CreditExchangeRateUpdateManyMutationInput, CreditExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which CreditExchangeRates to update
     */
    where?: CreditExchangeRateWhereInput
    /**
     * Limit how many CreditExchangeRates to update.
     */
    limit?: number
  }

  /**
   * CreditExchangeRate updateManyAndReturn
   */
  export type CreditExchangeRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to update CreditExchangeRates.
     */
    data: XOR<CreditExchangeRateUpdateManyMutationInput, CreditExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which CreditExchangeRates to update
     */
    where?: CreditExchangeRateWhereInput
    /**
     * Limit how many CreditExchangeRates to update.
     */
    limit?: number
  }

  /**
   * CreditExchangeRate upsert
   */
  export type CreditExchangeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * The filter to search for the CreditExchangeRate to update in case it exists.
     */
    where: CreditExchangeRateWhereUniqueInput
    /**
     * In case the CreditExchangeRate found by the `where` argument doesn't exist, create a new CreditExchangeRate with this data.
     */
    create: XOR<CreditExchangeRateCreateInput, CreditExchangeRateUncheckedCreateInput>
    /**
     * In case the CreditExchangeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditExchangeRateUpdateInput, CreditExchangeRateUncheckedUpdateInput>
  }

  /**
   * CreditExchangeRate delete
   */
  export type CreditExchangeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
    /**
     * Filter which CreditExchangeRate to delete.
     */
    where: CreditExchangeRateWhereUniqueInput
  }

  /**
   * CreditExchangeRate deleteMany
   */
  export type CreditExchangeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditExchangeRates to delete
     */
    where?: CreditExchangeRateWhereInput
    /**
     * Limit how many CreditExchangeRates to delete.
     */
    limit?: number
  }

  /**
   * CreditExchangeRate without action
   */
  export type CreditExchangeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditExchangeRate
     */
    select?: CreditExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditExchangeRate
     */
    omit?: CreditExchangeRateOmit<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    id: number | null
  }

  export type ReferralSumAggregateOutputType = {
    id: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: number | null
    referrerUserId: string | null
    referredUserId: string | null
    rewardGiven: boolean | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: number | null
    referrerUserId: string | null
    referredUserId: string | null
    rewardGiven: boolean | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerUserId: number
    referredUserId: number
    rewardGiven: number
    createdAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    id?: true
  }

  export type ReferralSumAggregateInputType = {
    id?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerUserId?: true
    referredUserId?: true
    rewardGiven?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerUserId?: true
    referredUserId?: true
    rewardGiven?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerUserId?: true
    referredUserId?: true
    rewardGiven?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: number
    referrerUserId: string
    referredUserId: string
    rewardGiven: boolean
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerUserId?: boolean
    referredUserId?: boolean
    rewardGiven?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerUserId?: boolean
    referredUserId?: boolean
    rewardGiven?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerUserId?: boolean
    referredUserId?: boolean
    rewardGiven?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerUserId?: boolean
    referredUserId?: boolean
    rewardGiven?: boolean
    createdAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerUserId" | "referredUserId" | "rewardGiven" | "createdAt", ExtArgs["result"]["referral"]>

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referrerUserId: string
      referredUserId: string
      rewardGiven: boolean
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'Int'>
    readonly referrerUserId: FieldRef<"Referral", 'String'>
    readonly referredUserId: FieldRef<"Referral", 'String'>
    readonly rewardGiven: FieldRef<"Referral", 'Boolean'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
  }


  /**
   * Model RedeemCode
   */

  export type AggregateRedeemCode = {
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  export type RedeemCodeAvgAggregateOutputType = {
    maxUses: number | null
    currentUses: number | null
  }

  export type RedeemCodeSumAggregateOutputType = {
    maxUses: number | null
    currentUses: number | null
  }

  export type RedeemCodeMinAggregateOutputType = {
    id: string | null
    description: string | null
    rewardType: $Enums.RewardType | null
    maxUses: number | null
    currentUses: number | null
    isActive: boolean | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type RedeemCodeMaxAggregateOutputType = {
    id: string | null
    description: string | null
    rewardType: $Enums.RewardType | null
    maxUses: number | null
    currentUses: number | null
    isActive: boolean | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type RedeemCodeCountAggregateOutputType = {
    id: number
    description: number
    rewardType: number
    rewardValue: number
    maxUses: number
    currentUses: number
    isActive: number
    expiryDate: number
    createdAt: number
    _all: number
  }


  export type RedeemCodeAvgAggregateInputType = {
    maxUses?: true
    currentUses?: true
  }

  export type RedeemCodeSumAggregateInputType = {
    maxUses?: true
    currentUses?: true
  }

  export type RedeemCodeMinAggregateInputType = {
    id?: true
    description?: true
    rewardType?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    expiryDate?: true
    createdAt?: true
  }

  export type RedeemCodeMaxAggregateInputType = {
    id?: true
    description?: true
    rewardType?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    expiryDate?: true
    createdAt?: true
  }

  export type RedeemCodeCountAggregateInputType = {
    id?: true
    description?: true
    rewardType?: true
    rewardValue?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    expiryDate?: true
    createdAt?: true
    _all?: true
  }

  export type RedeemCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCode to aggregate.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedeemCodes
    **/
    _count?: true | RedeemCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type GetRedeemCodeAggregateType<T extends RedeemCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemCode[P]>
      : GetScalarType<T[P], AggregateRedeemCode[P]>
  }




  export type RedeemCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeWhereInput
    orderBy?: RedeemCodeOrderByWithAggregationInput | RedeemCodeOrderByWithAggregationInput[]
    by: RedeemCodeScalarFieldEnum[] | RedeemCodeScalarFieldEnum
    having?: RedeemCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemCodeCountAggregateInputType | true
    _avg?: RedeemCodeAvgAggregateInputType
    _sum?: RedeemCodeSumAggregateInputType
    _min?: RedeemCodeMinAggregateInputType
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type RedeemCodeGroupByOutputType = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonValue
    maxUses: number | null
    currentUses: number
    isActive: boolean
    expiryDate: Date | null
    createdAt: Date
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  type GetRedeemCodeGroupByPayload<T extends RedeemCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
        }
      >
    >


  export type RedeemCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    redeemedBy?: boolean | RedeemCode$redeemedByArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    expiryDate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    expiryDate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectScalar = {
    id?: boolean
    description?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    expiryDate?: boolean
    createdAt?: boolean
  }

  export type RedeemCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "rewardType" | "rewardValue" | "maxUses" | "currentUses" | "isActive" | "expiryDate" | "createdAt", ExtArgs["result"]["redeemCode"]>
  export type RedeemCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemedBy?: boolean | RedeemCode$redeemedByArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RedeemCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RedeemCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RedeemCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedeemCode"
    objects: {
      redeemedBy: Prisma.$RedeemCodeRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      rewardType: $Enums.RewardType
      rewardValue: Prisma.JsonValue
      maxUses: number | null
      currentUses: number
      isActive: boolean
      expiryDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["redeemCode"]>
    composites: {}
  }

  type RedeemCodeGetPayload<S extends boolean | null | undefined | RedeemCodeDefaultArgs> = $Result.GetResult<Prisma.$RedeemCodePayload, S>

  type RedeemCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedeemCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemCodeCountAggregateInputType | true
    }

  export interface RedeemCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedeemCode'], meta: { name: 'RedeemCode' } }
    /**
     * Find zero or one RedeemCode that matches the filter.
     * @param {RedeemCodeFindUniqueArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedeemCodeFindUniqueArgs>(args: SelectSubset<T, RedeemCodeFindUniqueArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RedeemCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedeemCodeFindUniqueOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedeemCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, RedeemCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedeemCodeFindFirstArgs>(args?: SelectSubset<T, RedeemCodeFindFirstArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedeemCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, RedeemCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RedeemCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany()
     * 
     * // Get first 10 RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedeemCodeFindManyArgs>(args?: SelectSubset<T, RedeemCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RedeemCode.
     * @param {RedeemCodeCreateArgs} args - Arguments to create a RedeemCode.
     * @example
     * // Create one RedeemCode
     * const RedeemCode = await prisma.redeemCode.create({
     *   data: {
     *     // ... data to create a RedeemCode
     *   }
     * })
     * 
     */
    create<T extends RedeemCodeCreateArgs>(args: SelectSubset<T, RedeemCodeCreateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RedeemCodes.
     * @param {RedeemCodeCreateManyArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedeemCodeCreateManyArgs>(args?: SelectSubset<T, RedeemCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedeemCodes and returns the data saved in the database.
     * @param {RedeemCodeCreateManyAndReturnArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedeemCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, RedeemCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RedeemCode.
     * @param {RedeemCodeDeleteArgs} args - Arguments to delete one RedeemCode.
     * @example
     * // Delete one RedeemCode
     * const RedeemCode = await prisma.redeemCode.delete({
     *   where: {
     *     // ... filter to delete one RedeemCode
     *   }
     * })
     * 
     */
    delete<T extends RedeemCodeDeleteArgs>(args: SelectSubset<T, RedeemCodeDeleteArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RedeemCode.
     * @param {RedeemCodeUpdateArgs} args - Arguments to update one RedeemCode.
     * @example
     * // Update one RedeemCode
     * const redeemCode = await prisma.redeemCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedeemCodeUpdateArgs>(args: SelectSubset<T, RedeemCodeUpdateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RedeemCodes.
     * @param {RedeemCodeDeleteManyArgs} args - Arguments to filter RedeemCodes to delete.
     * @example
     * // Delete a few RedeemCodes
     * const { count } = await prisma.redeemCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedeemCodeDeleteManyArgs>(args?: SelectSubset<T, RedeemCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedeemCodeUpdateManyArgs>(args: SelectSubset<T, RedeemCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes and returns the data updated in the database.
     * @param {RedeemCodeUpdateManyAndReturnArgs} args - Arguments to update many RedeemCodes.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedeemCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, RedeemCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RedeemCode.
     * @param {RedeemCodeUpsertArgs} args - Arguments to update or create a RedeemCode.
     * @example
     * // Update or create a RedeemCode
     * const redeemCode = await prisma.redeemCode.upsert({
     *   create: {
     *     // ... data to create a RedeemCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedeemCode we want to update
     *   }
     * })
     */
    upsert<T extends RedeemCodeUpsertArgs>(args: SelectSubset<T, RedeemCodeUpsertArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeCountArgs} args - Arguments to filter RedeemCodes to count.
     * @example
     * // Count the number of RedeemCodes
     * const count = await prisma.redeemCode.count({
     *   where: {
     *     // ... the filter for the RedeemCodes we want to count
     *   }
     * })
    **/
    count<T extends RedeemCodeCountArgs>(
      args?: Subset<T, RedeemCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemCodeAggregateArgs>(args: Subset<T, RedeemCodeAggregateArgs>): Prisma.PrismaPromise<GetRedeemCodeAggregateType<T>>

    /**
     * Group by RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedeemCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedeemCodeGroupByArgs['orderBy'] }
        : { orderBy?: RedeemCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedeemCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedeemCode model
   */
  readonly fields: RedeemCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedeemCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedeemCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redeemedBy<T extends RedeemCode$redeemedByArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCode$redeemedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedeemCode model
   */
  interface RedeemCodeFieldRefs {
    readonly id: FieldRef<"RedeemCode", 'String'>
    readonly description: FieldRef<"RedeemCode", 'String'>
    readonly rewardType: FieldRef<"RedeemCode", 'RewardType'>
    readonly rewardValue: FieldRef<"RedeemCode", 'Json'>
    readonly maxUses: FieldRef<"RedeemCode", 'Int'>
    readonly currentUses: FieldRef<"RedeemCode", 'Int'>
    readonly isActive: FieldRef<"RedeemCode", 'Boolean'>
    readonly expiryDate: FieldRef<"RedeemCode", 'DateTime'>
    readonly createdAt: FieldRef<"RedeemCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RedeemCode findUnique
   */
  export type RedeemCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findUniqueOrThrow
   */
  export type RedeemCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findFirst
   */
  export type RedeemCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findFirstOrThrow
   */
  export type RedeemCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findMany
   */
  export type RedeemCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodes to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode create
   */
  export type RedeemCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a RedeemCode.
     */
    data: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
  }

  /**
   * RedeemCode createMany
   */
  export type RedeemCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemCode createManyAndReturn
   */
  export type RedeemCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemCode update
   */
  export type RedeemCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a RedeemCode.
     */
    data: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
    /**
     * Choose, which RedeemCode to update.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode updateMany
   */
  export type RedeemCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
  }

  /**
   * RedeemCode updateManyAndReturn
   */
  export type RedeemCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
  }

  /**
   * RedeemCode upsert
   */
  export type RedeemCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the RedeemCode to update in case it exists.
     */
    where: RedeemCodeWhereUniqueInput
    /**
     * In case the RedeemCode found by the `where` argument doesn't exist, create a new RedeemCode with this data.
     */
    create: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
    /**
     * In case the RedeemCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
  }

  /**
   * RedeemCode delete
   */
  export type RedeemCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter which RedeemCode to delete.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode deleteMany
   */
  export type RedeemCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCodes to delete
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to delete.
     */
    limit?: number
  }

  /**
   * RedeemCode.redeemedBy
   */
  export type RedeemCode$redeemedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    where?: RedeemCodeRecordWhereInput
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    cursor?: RedeemCodeRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemCodeRecordScalarFieldEnum | RedeemCodeRecordScalarFieldEnum[]
  }

  /**
   * RedeemCode without action
   */
  export type RedeemCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
  }


  /**
   * Model RedeemCodeRecord
   */

  export type AggregateRedeemCodeRecord = {
    _count: RedeemCodeRecordCountAggregateOutputType | null
    _avg: RedeemCodeRecordAvgAggregateOutputType | null
    _sum: RedeemCodeRecordSumAggregateOutputType | null
    _min: RedeemCodeRecordMinAggregateOutputType | null
    _max: RedeemCodeRecordMaxAggregateOutputType | null
  }

  export type RedeemCodeRecordAvgAggregateOutputType = {
    id: number | null
    userProfileId: number | null
  }

  export type RedeemCodeRecordSumAggregateOutputType = {
    id: number | null
    userProfileId: number | null
  }

  export type RedeemCodeRecordMinAggregateOutputType = {
    id: number | null
    redeemCodeId: string | null
    userProfileId: number | null
    redeemedAt: Date | null
  }

  export type RedeemCodeRecordMaxAggregateOutputType = {
    id: number | null
    redeemCodeId: string | null
    userProfileId: number | null
    redeemedAt: Date | null
  }

  export type RedeemCodeRecordCountAggregateOutputType = {
    id: number
    redeemCodeId: number
    userProfileId: number
    redeemedAt: number
    _all: number
  }


  export type RedeemCodeRecordAvgAggregateInputType = {
    id?: true
    userProfileId?: true
  }

  export type RedeemCodeRecordSumAggregateInputType = {
    id?: true
    userProfileId?: true
  }

  export type RedeemCodeRecordMinAggregateInputType = {
    id?: true
    redeemCodeId?: true
    userProfileId?: true
    redeemedAt?: true
  }

  export type RedeemCodeRecordMaxAggregateInputType = {
    id?: true
    redeemCodeId?: true
    userProfileId?: true
    redeemedAt?: true
  }

  export type RedeemCodeRecordCountAggregateInputType = {
    id?: true
    redeemCodeId?: true
    userProfileId?: true
    redeemedAt?: true
    _all?: true
  }

  export type RedeemCodeRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCodeRecord to aggregate.
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodeRecords to fetch.
     */
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedeemCodeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedeemCodeRecords
    **/
    _count?: true | RedeemCodeRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemCodeRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemCodeRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemCodeRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemCodeRecordMaxAggregateInputType
  }

  export type GetRedeemCodeRecordAggregateType<T extends RedeemCodeRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemCodeRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemCodeRecord[P]>
      : GetScalarType<T[P], AggregateRedeemCodeRecord[P]>
  }




  export type RedeemCodeRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeRecordWhereInput
    orderBy?: RedeemCodeRecordOrderByWithAggregationInput | RedeemCodeRecordOrderByWithAggregationInput[]
    by: RedeemCodeRecordScalarFieldEnum[] | RedeemCodeRecordScalarFieldEnum
    having?: RedeemCodeRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemCodeRecordCountAggregateInputType | true
    _avg?: RedeemCodeRecordAvgAggregateInputType
    _sum?: RedeemCodeRecordSumAggregateInputType
    _min?: RedeemCodeRecordMinAggregateInputType
    _max?: RedeemCodeRecordMaxAggregateInputType
  }

  export type RedeemCodeRecordGroupByOutputType = {
    id: number
    redeemCodeId: string
    userProfileId: number
    redeemedAt: Date
    _count: RedeemCodeRecordCountAggregateOutputType | null
    _avg: RedeemCodeRecordAvgAggregateOutputType | null
    _sum: RedeemCodeRecordSumAggregateOutputType | null
    _min: RedeemCodeRecordMinAggregateOutputType | null
    _max: RedeemCodeRecordMaxAggregateOutputType | null
  }

  type GetRedeemCodeRecordGroupByPayload<T extends RedeemCodeRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemCodeRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemCodeRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemCodeRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemCodeRecordGroupByOutputType[P]>
        }
      >
    >


  export type RedeemCodeRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    redeemCodeId?: boolean
    userProfileId?: boolean
    redeemedAt?: boolean
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCodeRecord"]>

  export type RedeemCodeRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    redeemCodeId?: boolean
    userProfileId?: boolean
    redeemedAt?: boolean
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCodeRecord"]>

  export type RedeemCodeRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    redeemCodeId?: boolean
    userProfileId?: boolean
    redeemedAt?: boolean
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCodeRecord"]>

  export type RedeemCodeRecordSelectScalar = {
    id?: boolean
    redeemCodeId?: boolean
    userProfileId?: boolean
    redeemedAt?: boolean
  }

  export type RedeemCodeRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "redeemCodeId" | "userProfileId" | "redeemedAt", ExtArgs["result"]["redeemCodeRecord"]>
  export type RedeemCodeRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type RedeemCodeRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type RedeemCodeRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemCode?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $RedeemCodeRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedeemCodeRecord"
    objects: {
      redeemCode: Prisma.$RedeemCodePayload<ExtArgs>
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      redeemCodeId: string
      userProfileId: number
      redeemedAt: Date
    }, ExtArgs["result"]["redeemCodeRecord"]>
    composites: {}
  }

  type RedeemCodeRecordGetPayload<S extends boolean | null | undefined | RedeemCodeRecordDefaultArgs> = $Result.GetResult<Prisma.$RedeemCodeRecordPayload, S>

  type RedeemCodeRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedeemCodeRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemCodeRecordCountAggregateInputType | true
    }

  export interface RedeemCodeRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedeemCodeRecord'], meta: { name: 'RedeemCodeRecord' } }
    /**
     * Find zero or one RedeemCodeRecord that matches the filter.
     * @param {RedeemCodeRecordFindUniqueArgs} args - Arguments to find a RedeemCodeRecord
     * @example
     * // Get one RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedeemCodeRecordFindUniqueArgs>(args: SelectSubset<T, RedeemCodeRecordFindUniqueArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RedeemCodeRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedeemCodeRecordFindUniqueOrThrowArgs} args - Arguments to find a RedeemCodeRecord
     * @example
     * // Get one RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedeemCodeRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RedeemCodeRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCodeRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordFindFirstArgs} args - Arguments to find a RedeemCodeRecord
     * @example
     * // Get one RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedeemCodeRecordFindFirstArgs>(args?: SelectSubset<T, RedeemCodeRecordFindFirstArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCodeRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordFindFirstOrThrowArgs} args - Arguments to find a RedeemCodeRecord
     * @example
     * // Get one RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedeemCodeRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RedeemCodeRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RedeemCodeRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedeemCodeRecords
     * const redeemCodeRecords = await prisma.redeemCodeRecord.findMany()
     * 
     * // Get first 10 RedeemCodeRecords
     * const redeemCodeRecords = await prisma.redeemCodeRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemCodeRecordWithIdOnly = await prisma.redeemCodeRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedeemCodeRecordFindManyArgs>(args?: SelectSubset<T, RedeemCodeRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RedeemCodeRecord.
     * @param {RedeemCodeRecordCreateArgs} args - Arguments to create a RedeemCodeRecord.
     * @example
     * // Create one RedeemCodeRecord
     * const RedeemCodeRecord = await prisma.redeemCodeRecord.create({
     *   data: {
     *     // ... data to create a RedeemCodeRecord
     *   }
     * })
     * 
     */
    create<T extends RedeemCodeRecordCreateArgs>(args: SelectSubset<T, RedeemCodeRecordCreateArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RedeemCodeRecords.
     * @param {RedeemCodeRecordCreateManyArgs} args - Arguments to create many RedeemCodeRecords.
     * @example
     * // Create many RedeemCodeRecords
     * const redeemCodeRecord = await prisma.redeemCodeRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedeemCodeRecordCreateManyArgs>(args?: SelectSubset<T, RedeemCodeRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedeemCodeRecords and returns the data saved in the database.
     * @param {RedeemCodeRecordCreateManyAndReturnArgs} args - Arguments to create many RedeemCodeRecords.
     * @example
     * // Create many RedeemCodeRecords
     * const redeemCodeRecord = await prisma.redeemCodeRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedeemCodeRecords and only return the `id`
     * const redeemCodeRecordWithIdOnly = await prisma.redeemCodeRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedeemCodeRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RedeemCodeRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RedeemCodeRecord.
     * @param {RedeemCodeRecordDeleteArgs} args - Arguments to delete one RedeemCodeRecord.
     * @example
     * // Delete one RedeemCodeRecord
     * const RedeemCodeRecord = await prisma.redeemCodeRecord.delete({
     *   where: {
     *     // ... filter to delete one RedeemCodeRecord
     *   }
     * })
     * 
     */
    delete<T extends RedeemCodeRecordDeleteArgs>(args: SelectSubset<T, RedeemCodeRecordDeleteArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RedeemCodeRecord.
     * @param {RedeemCodeRecordUpdateArgs} args - Arguments to update one RedeemCodeRecord.
     * @example
     * // Update one RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedeemCodeRecordUpdateArgs>(args: SelectSubset<T, RedeemCodeRecordUpdateArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RedeemCodeRecords.
     * @param {RedeemCodeRecordDeleteManyArgs} args - Arguments to filter RedeemCodeRecords to delete.
     * @example
     * // Delete a few RedeemCodeRecords
     * const { count } = await prisma.redeemCodeRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedeemCodeRecordDeleteManyArgs>(args?: SelectSubset<T, RedeemCodeRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedeemCodeRecords
     * const redeemCodeRecord = await prisma.redeemCodeRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedeemCodeRecordUpdateManyArgs>(args: SelectSubset<T, RedeemCodeRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodeRecords and returns the data updated in the database.
     * @param {RedeemCodeRecordUpdateManyAndReturnArgs} args - Arguments to update many RedeemCodeRecords.
     * @example
     * // Update many RedeemCodeRecords
     * const redeemCodeRecord = await prisma.redeemCodeRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RedeemCodeRecords and only return the `id`
     * const redeemCodeRecordWithIdOnly = await prisma.redeemCodeRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedeemCodeRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, RedeemCodeRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RedeemCodeRecord.
     * @param {RedeemCodeRecordUpsertArgs} args - Arguments to update or create a RedeemCodeRecord.
     * @example
     * // Update or create a RedeemCodeRecord
     * const redeemCodeRecord = await prisma.redeemCodeRecord.upsert({
     *   create: {
     *     // ... data to create a RedeemCodeRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedeemCodeRecord we want to update
     *   }
     * })
     */
    upsert<T extends RedeemCodeRecordUpsertArgs>(args: SelectSubset<T, RedeemCodeRecordUpsertArgs<ExtArgs>>): Prisma__RedeemCodeRecordClient<$Result.GetResult<Prisma.$RedeemCodeRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RedeemCodeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordCountArgs} args - Arguments to filter RedeemCodeRecords to count.
     * @example
     * // Count the number of RedeemCodeRecords
     * const count = await prisma.redeemCodeRecord.count({
     *   where: {
     *     // ... the filter for the RedeemCodeRecords we want to count
     *   }
     * })
    **/
    count<T extends RedeemCodeRecordCountArgs>(
      args?: Subset<T, RedeemCodeRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemCodeRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedeemCodeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemCodeRecordAggregateArgs>(args: Subset<T, RedeemCodeRecordAggregateArgs>): Prisma.PrismaPromise<GetRedeemCodeRecordAggregateType<T>>

    /**
     * Group by RedeemCodeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedeemCodeRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedeemCodeRecordGroupByArgs['orderBy'] }
        : { orderBy?: RedeemCodeRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedeemCodeRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemCodeRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedeemCodeRecord model
   */
  readonly fields: RedeemCodeRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedeemCodeRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedeemCodeRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redeemCode<T extends RedeemCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCodeDefaultArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedeemCodeRecord model
   */
  interface RedeemCodeRecordFieldRefs {
    readonly id: FieldRef<"RedeemCodeRecord", 'Int'>
    readonly redeemCodeId: FieldRef<"RedeemCodeRecord", 'String'>
    readonly userProfileId: FieldRef<"RedeemCodeRecord", 'Int'>
    readonly redeemedAt: FieldRef<"RedeemCodeRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RedeemCodeRecord findUnique
   */
  export type RedeemCodeRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodeRecord to fetch.
     */
    where: RedeemCodeRecordWhereUniqueInput
  }

  /**
   * RedeemCodeRecord findUniqueOrThrow
   */
  export type RedeemCodeRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodeRecord to fetch.
     */
    where: RedeemCodeRecordWhereUniqueInput
  }

  /**
   * RedeemCodeRecord findFirst
   */
  export type RedeemCodeRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodeRecord to fetch.
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodeRecords to fetch.
     */
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodeRecords.
     */
    cursor?: RedeemCodeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodeRecords.
     */
    distinct?: RedeemCodeRecordScalarFieldEnum | RedeemCodeRecordScalarFieldEnum[]
  }

  /**
   * RedeemCodeRecord findFirstOrThrow
   */
  export type RedeemCodeRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodeRecord to fetch.
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodeRecords to fetch.
     */
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodeRecords.
     */
    cursor?: RedeemCodeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodeRecords.
     */
    distinct?: RedeemCodeRecordScalarFieldEnum | RedeemCodeRecordScalarFieldEnum[]
  }

  /**
   * RedeemCodeRecord findMany
   */
  export type RedeemCodeRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodeRecords to fetch.
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodeRecords to fetch.
     */
    orderBy?: RedeemCodeRecordOrderByWithRelationInput | RedeemCodeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedeemCodeRecords.
     */
    cursor?: RedeemCodeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodeRecords.
     */
    skip?: number
    distinct?: RedeemCodeRecordScalarFieldEnum | RedeemCodeRecordScalarFieldEnum[]
  }

  /**
   * RedeemCodeRecord create
   */
  export type RedeemCodeRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a RedeemCodeRecord.
     */
    data: XOR<RedeemCodeRecordCreateInput, RedeemCodeRecordUncheckedCreateInput>
  }

  /**
   * RedeemCodeRecord createMany
   */
  export type RedeemCodeRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedeemCodeRecords.
     */
    data: RedeemCodeRecordCreateManyInput | RedeemCodeRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemCodeRecord createManyAndReturn
   */
  export type RedeemCodeRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * The data used to create many RedeemCodeRecords.
     */
    data: RedeemCodeRecordCreateManyInput | RedeemCodeRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCodeRecord update
   */
  export type RedeemCodeRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a RedeemCodeRecord.
     */
    data: XOR<RedeemCodeRecordUpdateInput, RedeemCodeRecordUncheckedUpdateInput>
    /**
     * Choose, which RedeemCodeRecord to update.
     */
    where: RedeemCodeRecordWhereUniqueInput
  }

  /**
   * RedeemCodeRecord updateMany
   */
  export type RedeemCodeRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedeemCodeRecords.
     */
    data: XOR<RedeemCodeRecordUpdateManyMutationInput, RedeemCodeRecordUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodeRecords to update
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * Limit how many RedeemCodeRecords to update.
     */
    limit?: number
  }

  /**
   * RedeemCodeRecord updateManyAndReturn
   */
  export type RedeemCodeRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * The data used to update RedeemCodeRecords.
     */
    data: XOR<RedeemCodeRecordUpdateManyMutationInput, RedeemCodeRecordUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodeRecords to update
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * Limit how many RedeemCodeRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCodeRecord upsert
   */
  export type RedeemCodeRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the RedeemCodeRecord to update in case it exists.
     */
    where: RedeemCodeRecordWhereUniqueInput
    /**
     * In case the RedeemCodeRecord found by the `where` argument doesn't exist, create a new RedeemCodeRecord with this data.
     */
    create: XOR<RedeemCodeRecordCreateInput, RedeemCodeRecordUncheckedCreateInput>
    /**
     * In case the RedeemCodeRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedeemCodeRecordUpdateInput, RedeemCodeRecordUncheckedUpdateInput>
  }

  /**
   * RedeemCodeRecord delete
   */
  export type RedeemCodeRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
    /**
     * Filter which RedeemCodeRecord to delete.
     */
    where: RedeemCodeRecordWhereUniqueInput
  }

  /**
   * RedeemCodeRecord deleteMany
   */
  export type RedeemCodeRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCodeRecords to delete
     */
    where?: RedeemCodeRecordWhereInput
    /**
     * Limit how many RedeemCodeRecords to delete.
     */
    limit?: number
  }

  /**
   * RedeemCodeRecord without action
   */
  export type RedeemCodeRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeRecord
     */
    select?: RedeemCodeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCodeRecord
     */
    omit?: RedeemCodeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeRecordInclude<ExtArgs> | null
  }


  /**
   * Model AdRewardMilestone
   */

  export type AggregateAdRewardMilestone = {
    _count: AdRewardMilestoneCountAggregateOutputType | null
    _avg: AdRewardMilestoneAvgAggregateOutputType | null
    _sum: AdRewardMilestoneSumAggregateOutputType | null
    _min: AdRewardMilestoneMinAggregateOutputType | null
    _max: AdRewardMilestoneMaxAggregateOutputType | null
  }

  export type AdRewardMilestoneAvgAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    totalAdsWatched: number | null
    adsWatchedToday: number | null
  }

  export type AdRewardMilestoneSumAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    totalAdsWatched: number | null
    adsWatchedToday: number | null
  }

  export type AdRewardMilestoneMinAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    totalAdsWatched: number | null
    adsWatchedToday: number | null
    lastAdWatchedAt: Date | null
  }

  export type AdRewardMilestoneMaxAggregateOutputType = {
    id: number | null
    userProfileId: number | null
    totalAdsWatched: number | null
    adsWatchedToday: number | null
    lastAdWatchedAt: Date | null
  }

  export type AdRewardMilestoneCountAggregateOutputType = {
    id: number
    userProfileId: number
    totalAdsWatched: number
    adsWatchedToday: number
    lastAdWatchedAt: number
    _all: number
  }


  export type AdRewardMilestoneAvgAggregateInputType = {
    id?: true
    userProfileId?: true
    totalAdsWatched?: true
    adsWatchedToday?: true
  }

  export type AdRewardMilestoneSumAggregateInputType = {
    id?: true
    userProfileId?: true
    totalAdsWatched?: true
    adsWatchedToday?: true
  }

  export type AdRewardMilestoneMinAggregateInputType = {
    id?: true
    userProfileId?: true
    totalAdsWatched?: true
    adsWatchedToday?: true
    lastAdWatchedAt?: true
  }

  export type AdRewardMilestoneMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    totalAdsWatched?: true
    adsWatchedToday?: true
    lastAdWatchedAt?: true
  }

  export type AdRewardMilestoneCountAggregateInputType = {
    id?: true
    userProfileId?: true
    totalAdsWatched?: true
    adsWatchedToday?: true
    lastAdWatchedAt?: true
    _all?: true
  }

  export type AdRewardMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdRewardMilestone to aggregate.
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRewardMilestones to fetch.
     */
    orderBy?: AdRewardMilestoneOrderByWithRelationInput | AdRewardMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdRewardMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRewardMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRewardMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdRewardMilestones
    **/
    _count?: true | AdRewardMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdRewardMilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdRewardMilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdRewardMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdRewardMilestoneMaxAggregateInputType
  }

  export type GetAdRewardMilestoneAggregateType<T extends AdRewardMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateAdRewardMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdRewardMilestone[P]>
      : GetScalarType<T[P], AggregateAdRewardMilestone[P]>
  }




  export type AdRewardMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdRewardMilestoneWhereInput
    orderBy?: AdRewardMilestoneOrderByWithAggregationInput | AdRewardMilestoneOrderByWithAggregationInput[]
    by: AdRewardMilestoneScalarFieldEnum[] | AdRewardMilestoneScalarFieldEnum
    having?: AdRewardMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdRewardMilestoneCountAggregateInputType | true
    _avg?: AdRewardMilestoneAvgAggregateInputType
    _sum?: AdRewardMilestoneSumAggregateInputType
    _min?: AdRewardMilestoneMinAggregateInputType
    _max?: AdRewardMilestoneMaxAggregateInputType
  }

  export type AdRewardMilestoneGroupByOutputType = {
    id: number
    userProfileId: number
    totalAdsWatched: number
    adsWatchedToday: number
    lastAdWatchedAt: Date | null
    _count: AdRewardMilestoneCountAggregateOutputType | null
    _avg: AdRewardMilestoneAvgAggregateOutputType | null
    _sum: AdRewardMilestoneSumAggregateOutputType | null
    _min: AdRewardMilestoneMinAggregateOutputType | null
    _max: AdRewardMilestoneMaxAggregateOutputType | null
  }

  type GetAdRewardMilestoneGroupByPayload<T extends AdRewardMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdRewardMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdRewardMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdRewardMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], AdRewardMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type AdRewardMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    totalAdsWatched?: boolean
    adsWatchedToday?: boolean
    lastAdWatchedAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adRewardMilestone"]>

  export type AdRewardMilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    totalAdsWatched?: boolean
    adsWatchedToday?: boolean
    lastAdWatchedAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adRewardMilestone"]>

  export type AdRewardMilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    totalAdsWatched?: boolean
    adsWatchedToday?: boolean
    lastAdWatchedAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adRewardMilestone"]>

  export type AdRewardMilestoneSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    totalAdsWatched?: boolean
    adsWatchedToday?: boolean
    lastAdWatchedAt?: boolean
  }

  export type AdRewardMilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "totalAdsWatched" | "adsWatchedToday" | "lastAdWatchedAt", ExtArgs["result"]["adRewardMilestone"]>
  export type AdRewardMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type AdRewardMilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type AdRewardMilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $AdRewardMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdRewardMilestone"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userProfileId: number
      totalAdsWatched: number
      adsWatchedToday: number
      lastAdWatchedAt: Date | null
    }, ExtArgs["result"]["adRewardMilestone"]>
    composites: {}
  }

  type AdRewardMilestoneGetPayload<S extends boolean | null | undefined | AdRewardMilestoneDefaultArgs> = $Result.GetResult<Prisma.$AdRewardMilestonePayload, S>

  type AdRewardMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdRewardMilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdRewardMilestoneCountAggregateInputType | true
    }

  export interface AdRewardMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdRewardMilestone'], meta: { name: 'AdRewardMilestone' } }
    /**
     * Find zero or one AdRewardMilestone that matches the filter.
     * @param {AdRewardMilestoneFindUniqueArgs} args - Arguments to find a AdRewardMilestone
     * @example
     * // Get one AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdRewardMilestoneFindUniqueArgs>(args: SelectSubset<T, AdRewardMilestoneFindUniqueArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdRewardMilestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdRewardMilestoneFindUniqueOrThrowArgs} args - Arguments to find a AdRewardMilestone
     * @example
     * // Get one AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdRewardMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, AdRewardMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdRewardMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneFindFirstArgs} args - Arguments to find a AdRewardMilestone
     * @example
     * // Get one AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdRewardMilestoneFindFirstArgs>(args?: SelectSubset<T, AdRewardMilestoneFindFirstArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdRewardMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneFindFirstOrThrowArgs} args - Arguments to find a AdRewardMilestone
     * @example
     * // Get one AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdRewardMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, AdRewardMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdRewardMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdRewardMilestones
     * const adRewardMilestones = await prisma.adRewardMilestone.findMany()
     * 
     * // Get first 10 AdRewardMilestones
     * const adRewardMilestones = await prisma.adRewardMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adRewardMilestoneWithIdOnly = await prisma.adRewardMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdRewardMilestoneFindManyArgs>(args?: SelectSubset<T, AdRewardMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdRewardMilestone.
     * @param {AdRewardMilestoneCreateArgs} args - Arguments to create a AdRewardMilestone.
     * @example
     * // Create one AdRewardMilestone
     * const AdRewardMilestone = await prisma.adRewardMilestone.create({
     *   data: {
     *     // ... data to create a AdRewardMilestone
     *   }
     * })
     * 
     */
    create<T extends AdRewardMilestoneCreateArgs>(args: SelectSubset<T, AdRewardMilestoneCreateArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdRewardMilestones.
     * @param {AdRewardMilestoneCreateManyArgs} args - Arguments to create many AdRewardMilestones.
     * @example
     * // Create many AdRewardMilestones
     * const adRewardMilestone = await prisma.adRewardMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdRewardMilestoneCreateManyArgs>(args?: SelectSubset<T, AdRewardMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdRewardMilestones and returns the data saved in the database.
     * @param {AdRewardMilestoneCreateManyAndReturnArgs} args - Arguments to create many AdRewardMilestones.
     * @example
     * // Create many AdRewardMilestones
     * const adRewardMilestone = await prisma.adRewardMilestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdRewardMilestones and only return the `id`
     * const adRewardMilestoneWithIdOnly = await prisma.adRewardMilestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdRewardMilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, AdRewardMilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdRewardMilestone.
     * @param {AdRewardMilestoneDeleteArgs} args - Arguments to delete one AdRewardMilestone.
     * @example
     * // Delete one AdRewardMilestone
     * const AdRewardMilestone = await prisma.adRewardMilestone.delete({
     *   where: {
     *     // ... filter to delete one AdRewardMilestone
     *   }
     * })
     * 
     */
    delete<T extends AdRewardMilestoneDeleteArgs>(args: SelectSubset<T, AdRewardMilestoneDeleteArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdRewardMilestone.
     * @param {AdRewardMilestoneUpdateArgs} args - Arguments to update one AdRewardMilestone.
     * @example
     * // Update one AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdRewardMilestoneUpdateArgs>(args: SelectSubset<T, AdRewardMilestoneUpdateArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdRewardMilestones.
     * @param {AdRewardMilestoneDeleteManyArgs} args - Arguments to filter AdRewardMilestones to delete.
     * @example
     * // Delete a few AdRewardMilestones
     * const { count } = await prisma.adRewardMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdRewardMilestoneDeleteManyArgs>(args?: SelectSubset<T, AdRewardMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdRewardMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdRewardMilestones
     * const adRewardMilestone = await prisma.adRewardMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdRewardMilestoneUpdateManyArgs>(args: SelectSubset<T, AdRewardMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdRewardMilestones and returns the data updated in the database.
     * @param {AdRewardMilestoneUpdateManyAndReturnArgs} args - Arguments to update many AdRewardMilestones.
     * @example
     * // Update many AdRewardMilestones
     * const adRewardMilestone = await prisma.adRewardMilestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdRewardMilestones and only return the `id`
     * const adRewardMilestoneWithIdOnly = await prisma.adRewardMilestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdRewardMilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, AdRewardMilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdRewardMilestone.
     * @param {AdRewardMilestoneUpsertArgs} args - Arguments to update or create a AdRewardMilestone.
     * @example
     * // Update or create a AdRewardMilestone
     * const adRewardMilestone = await prisma.adRewardMilestone.upsert({
     *   create: {
     *     // ... data to create a AdRewardMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdRewardMilestone we want to update
     *   }
     * })
     */
    upsert<T extends AdRewardMilestoneUpsertArgs>(args: SelectSubset<T, AdRewardMilestoneUpsertArgs<ExtArgs>>): Prisma__AdRewardMilestoneClient<$Result.GetResult<Prisma.$AdRewardMilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdRewardMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneCountArgs} args - Arguments to filter AdRewardMilestones to count.
     * @example
     * // Count the number of AdRewardMilestones
     * const count = await prisma.adRewardMilestone.count({
     *   where: {
     *     // ... the filter for the AdRewardMilestones we want to count
     *   }
     * })
    **/
    count<T extends AdRewardMilestoneCountArgs>(
      args?: Subset<T, AdRewardMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdRewardMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdRewardMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdRewardMilestoneAggregateArgs>(args: Subset<T, AdRewardMilestoneAggregateArgs>): Prisma.PrismaPromise<GetAdRewardMilestoneAggregateType<T>>

    /**
     * Group by AdRewardMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRewardMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdRewardMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdRewardMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: AdRewardMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdRewardMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdRewardMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdRewardMilestone model
   */
  readonly fields: AdRewardMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdRewardMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdRewardMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdRewardMilestone model
   */
  interface AdRewardMilestoneFieldRefs {
    readonly id: FieldRef<"AdRewardMilestone", 'Int'>
    readonly userProfileId: FieldRef<"AdRewardMilestone", 'Int'>
    readonly totalAdsWatched: FieldRef<"AdRewardMilestone", 'Int'>
    readonly adsWatchedToday: FieldRef<"AdRewardMilestone", 'Int'>
    readonly lastAdWatchedAt: FieldRef<"AdRewardMilestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdRewardMilestone findUnique
   */
  export type AdRewardMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AdRewardMilestone to fetch.
     */
    where: AdRewardMilestoneWhereUniqueInput
  }

  /**
   * AdRewardMilestone findUniqueOrThrow
   */
  export type AdRewardMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AdRewardMilestone to fetch.
     */
    where: AdRewardMilestoneWhereUniqueInput
  }

  /**
   * AdRewardMilestone findFirst
   */
  export type AdRewardMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AdRewardMilestone to fetch.
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRewardMilestones to fetch.
     */
    orderBy?: AdRewardMilestoneOrderByWithRelationInput | AdRewardMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdRewardMilestones.
     */
    cursor?: AdRewardMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRewardMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRewardMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdRewardMilestones.
     */
    distinct?: AdRewardMilestoneScalarFieldEnum | AdRewardMilestoneScalarFieldEnum[]
  }

  /**
   * AdRewardMilestone findFirstOrThrow
   */
  export type AdRewardMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AdRewardMilestone to fetch.
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRewardMilestones to fetch.
     */
    orderBy?: AdRewardMilestoneOrderByWithRelationInput | AdRewardMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdRewardMilestones.
     */
    cursor?: AdRewardMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRewardMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRewardMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdRewardMilestones.
     */
    distinct?: AdRewardMilestoneScalarFieldEnum | AdRewardMilestoneScalarFieldEnum[]
  }

  /**
   * AdRewardMilestone findMany
   */
  export type AdRewardMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AdRewardMilestones to fetch.
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRewardMilestones to fetch.
     */
    orderBy?: AdRewardMilestoneOrderByWithRelationInput | AdRewardMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdRewardMilestones.
     */
    cursor?: AdRewardMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRewardMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRewardMilestones.
     */
    skip?: number
    distinct?: AdRewardMilestoneScalarFieldEnum | AdRewardMilestoneScalarFieldEnum[]
  }

  /**
   * AdRewardMilestone create
   */
  export type AdRewardMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a AdRewardMilestone.
     */
    data: XOR<AdRewardMilestoneCreateInput, AdRewardMilestoneUncheckedCreateInput>
  }

  /**
   * AdRewardMilestone createMany
   */
  export type AdRewardMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdRewardMilestones.
     */
    data: AdRewardMilestoneCreateManyInput | AdRewardMilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdRewardMilestone createManyAndReturn
   */
  export type AdRewardMilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many AdRewardMilestones.
     */
    data: AdRewardMilestoneCreateManyInput | AdRewardMilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdRewardMilestone update
   */
  export type AdRewardMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a AdRewardMilestone.
     */
    data: XOR<AdRewardMilestoneUpdateInput, AdRewardMilestoneUncheckedUpdateInput>
    /**
     * Choose, which AdRewardMilestone to update.
     */
    where: AdRewardMilestoneWhereUniqueInput
  }

  /**
   * AdRewardMilestone updateMany
   */
  export type AdRewardMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdRewardMilestones.
     */
    data: XOR<AdRewardMilestoneUpdateManyMutationInput, AdRewardMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which AdRewardMilestones to update
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * Limit how many AdRewardMilestones to update.
     */
    limit?: number
  }

  /**
   * AdRewardMilestone updateManyAndReturn
   */
  export type AdRewardMilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * The data used to update AdRewardMilestones.
     */
    data: XOR<AdRewardMilestoneUpdateManyMutationInput, AdRewardMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which AdRewardMilestones to update
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * Limit how many AdRewardMilestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdRewardMilestone upsert
   */
  export type AdRewardMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the AdRewardMilestone to update in case it exists.
     */
    where: AdRewardMilestoneWhereUniqueInput
    /**
     * In case the AdRewardMilestone found by the `where` argument doesn't exist, create a new AdRewardMilestone with this data.
     */
    create: XOR<AdRewardMilestoneCreateInput, AdRewardMilestoneUncheckedCreateInput>
    /**
     * In case the AdRewardMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdRewardMilestoneUpdateInput, AdRewardMilestoneUncheckedUpdateInput>
  }

  /**
   * AdRewardMilestone delete
   */
  export type AdRewardMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
    /**
     * Filter which AdRewardMilestone to delete.
     */
    where: AdRewardMilestoneWhereUniqueInput
  }

  /**
   * AdRewardMilestone deleteMany
   */
  export type AdRewardMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdRewardMilestones to delete
     */
    where?: AdRewardMilestoneWhereInput
    /**
     * Limit how many AdRewardMilestones to delete.
     */
    limit?: number
  }

  /**
   * AdRewardMilestone without action
   */
  export type AdRewardMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRewardMilestone
     */
    select?: AdRewardMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdRewardMilestone
     */
    omit?: AdRewardMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRewardMilestoneInclude<ExtArgs> | null
  }


  /**
   * Model PremiumBoxReward
   */

  export type AggregatePremiumBoxReward = {
    _count: PremiumBoxRewardCountAggregateOutputType | null
    _avg: PremiumBoxRewardAvgAggregateOutputType | null
    _sum: PremiumBoxRewardSumAggregateOutputType | null
    _min: PremiumBoxRewardMinAggregateOutputType | null
    _max: PremiumBoxRewardMaxAggregateOutputType | null
  }

  export type PremiumBoxRewardAvgAggregateOutputType = {
    id: number | null
    weight: number | null
  }

  export type PremiumBoxRewardSumAggregateOutputType = {
    id: number | null
    weight: number | null
  }

  export type PremiumBoxRewardMinAggregateOutputType = {
    id: number | null
    category: string | null
    rewardType: $Enums.RewardType | null
    weight: number | null
  }

  export type PremiumBoxRewardMaxAggregateOutputType = {
    id: number | null
    category: string | null
    rewardType: $Enums.RewardType | null
    weight: number | null
  }

  export type PremiumBoxRewardCountAggregateOutputType = {
    id: number
    category: number
    rewardType: number
    rewardValue: number
    weight: number
    _all: number
  }


  export type PremiumBoxRewardAvgAggregateInputType = {
    id?: true
    weight?: true
  }

  export type PremiumBoxRewardSumAggregateInputType = {
    id?: true
    weight?: true
  }

  export type PremiumBoxRewardMinAggregateInputType = {
    id?: true
    category?: true
    rewardType?: true
    weight?: true
  }

  export type PremiumBoxRewardMaxAggregateInputType = {
    id?: true
    category?: true
    rewardType?: true
    weight?: true
  }

  export type PremiumBoxRewardCountAggregateInputType = {
    id?: true
    category?: true
    rewardType?: true
    rewardValue?: true
    weight?: true
    _all?: true
  }

  export type PremiumBoxRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PremiumBoxReward to aggregate.
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PremiumBoxRewards to fetch.
     */
    orderBy?: PremiumBoxRewardOrderByWithRelationInput | PremiumBoxRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PremiumBoxRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PremiumBoxRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PremiumBoxRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PremiumBoxRewards
    **/
    _count?: true | PremiumBoxRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PremiumBoxRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PremiumBoxRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PremiumBoxRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PremiumBoxRewardMaxAggregateInputType
  }

  export type GetPremiumBoxRewardAggregateType<T extends PremiumBoxRewardAggregateArgs> = {
        [P in keyof T & keyof AggregatePremiumBoxReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePremiumBoxReward[P]>
      : GetScalarType<T[P], AggregatePremiumBoxReward[P]>
  }




  export type PremiumBoxRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PremiumBoxRewardWhereInput
    orderBy?: PremiumBoxRewardOrderByWithAggregationInput | PremiumBoxRewardOrderByWithAggregationInput[]
    by: PremiumBoxRewardScalarFieldEnum[] | PremiumBoxRewardScalarFieldEnum
    having?: PremiumBoxRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PremiumBoxRewardCountAggregateInputType | true
    _avg?: PremiumBoxRewardAvgAggregateInputType
    _sum?: PremiumBoxRewardSumAggregateInputType
    _min?: PremiumBoxRewardMinAggregateInputType
    _max?: PremiumBoxRewardMaxAggregateInputType
  }

  export type PremiumBoxRewardGroupByOutputType = {
    id: number
    category: string
    rewardType: $Enums.RewardType
    rewardValue: JsonValue
    weight: number
    _count: PremiumBoxRewardCountAggregateOutputType | null
    _avg: PremiumBoxRewardAvgAggregateOutputType | null
    _sum: PremiumBoxRewardSumAggregateOutputType | null
    _min: PremiumBoxRewardMinAggregateOutputType | null
    _max: PremiumBoxRewardMaxAggregateOutputType | null
  }

  type GetPremiumBoxRewardGroupByPayload<T extends PremiumBoxRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PremiumBoxRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PremiumBoxRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PremiumBoxRewardGroupByOutputType[P]>
            : GetScalarType<T[P], PremiumBoxRewardGroupByOutputType[P]>
        }
      >
    >


  export type PremiumBoxRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    weight?: boolean
  }, ExtArgs["result"]["premiumBoxReward"]>

  export type PremiumBoxRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    weight?: boolean
  }, ExtArgs["result"]["premiumBoxReward"]>

  export type PremiumBoxRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    weight?: boolean
  }, ExtArgs["result"]["premiumBoxReward"]>

  export type PremiumBoxRewardSelectScalar = {
    id?: boolean
    category?: boolean
    rewardType?: boolean
    rewardValue?: boolean
    weight?: boolean
  }

  export type PremiumBoxRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "rewardType" | "rewardValue" | "weight", ExtArgs["result"]["premiumBoxReward"]>

  export type $PremiumBoxRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PremiumBoxReward"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      rewardType: $Enums.RewardType
      rewardValue: Prisma.JsonValue
      weight: number
    }, ExtArgs["result"]["premiumBoxReward"]>
    composites: {}
  }

  type PremiumBoxRewardGetPayload<S extends boolean | null | undefined | PremiumBoxRewardDefaultArgs> = $Result.GetResult<Prisma.$PremiumBoxRewardPayload, S>

  type PremiumBoxRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PremiumBoxRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PremiumBoxRewardCountAggregateInputType | true
    }

  export interface PremiumBoxRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PremiumBoxReward'], meta: { name: 'PremiumBoxReward' } }
    /**
     * Find zero or one PremiumBoxReward that matches the filter.
     * @param {PremiumBoxRewardFindUniqueArgs} args - Arguments to find a PremiumBoxReward
     * @example
     * // Get one PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PremiumBoxRewardFindUniqueArgs>(args: SelectSubset<T, PremiumBoxRewardFindUniqueArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PremiumBoxReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PremiumBoxRewardFindUniqueOrThrowArgs} args - Arguments to find a PremiumBoxReward
     * @example
     * // Get one PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PremiumBoxRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, PremiumBoxRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PremiumBoxReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardFindFirstArgs} args - Arguments to find a PremiumBoxReward
     * @example
     * // Get one PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PremiumBoxRewardFindFirstArgs>(args?: SelectSubset<T, PremiumBoxRewardFindFirstArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PremiumBoxReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardFindFirstOrThrowArgs} args - Arguments to find a PremiumBoxReward
     * @example
     * // Get one PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PremiumBoxRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, PremiumBoxRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PremiumBoxRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PremiumBoxRewards
     * const premiumBoxRewards = await prisma.premiumBoxReward.findMany()
     * 
     * // Get first 10 PremiumBoxRewards
     * const premiumBoxRewards = await prisma.premiumBoxReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const premiumBoxRewardWithIdOnly = await prisma.premiumBoxReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PremiumBoxRewardFindManyArgs>(args?: SelectSubset<T, PremiumBoxRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PremiumBoxReward.
     * @param {PremiumBoxRewardCreateArgs} args - Arguments to create a PremiumBoxReward.
     * @example
     * // Create one PremiumBoxReward
     * const PremiumBoxReward = await prisma.premiumBoxReward.create({
     *   data: {
     *     // ... data to create a PremiumBoxReward
     *   }
     * })
     * 
     */
    create<T extends PremiumBoxRewardCreateArgs>(args: SelectSubset<T, PremiumBoxRewardCreateArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PremiumBoxRewards.
     * @param {PremiumBoxRewardCreateManyArgs} args - Arguments to create many PremiumBoxRewards.
     * @example
     * // Create many PremiumBoxRewards
     * const premiumBoxReward = await prisma.premiumBoxReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PremiumBoxRewardCreateManyArgs>(args?: SelectSubset<T, PremiumBoxRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PremiumBoxRewards and returns the data saved in the database.
     * @param {PremiumBoxRewardCreateManyAndReturnArgs} args - Arguments to create many PremiumBoxRewards.
     * @example
     * // Create many PremiumBoxRewards
     * const premiumBoxReward = await prisma.premiumBoxReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PremiumBoxRewards and only return the `id`
     * const premiumBoxRewardWithIdOnly = await prisma.premiumBoxReward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PremiumBoxRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, PremiumBoxRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PremiumBoxReward.
     * @param {PremiumBoxRewardDeleteArgs} args - Arguments to delete one PremiumBoxReward.
     * @example
     * // Delete one PremiumBoxReward
     * const PremiumBoxReward = await prisma.premiumBoxReward.delete({
     *   where: {
     *     // ... filter to delete one PremiumBoxReward
     *   }
     * })
     * 
     */
    delete<T extends PremiumBoxRewardDeleteArgs>(args: SelectSubset<T, PremiumBoxRewardDeleteArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PremiumBoxReward.
     * @param {PremiumBoxRewardUpdateArgs} args - Arguments to update one PremiumBoxReward.
     * @example
     * // Update one PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PremiumBoxRewardUpdateArgs>(args: SelectSubset<T, PremiumBoxRewardUpdateArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PremiumBoxRewards.
     * @param {PremiumBoxRewardDeleteManyArgs} args - Arguments to filter PremiumBoxRewards to delete.
     * @example
     * // Delete a few PremiumBoxRewards
     * const { count } = await prisma.premiumBoxReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PremiumBoxRewardDeleteManyArgs>(args?: SelectSubset<T, PremiumBoxRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PremiumBoxRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PremiumBoxRewards
     * const premiumBoxReward = await prisma.premiumBoxReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PremiumBoxRewardUpdateManyArgs>(args: SelectSubset<T, PremiumBoxRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PremiumBoxRewards and returns the data updated in the database.
     * @param {PremiumBoxRewardUpdateManyAndReturnArgs} args - Arguments to update many PremiumBoxRewards.
     * @example
     * // Update many PremiumBoxRewards
     * const premiumBoxReward = await prisma.premiumBoxReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PremiumBoxRewards and only return the `id`
     * const premiumBoxRewardWithIdOnly = await prisma.premiumBoxReward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PremiumBoxRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, PremiumBoxRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PremiumBoxReward.
     * @param {PremiumBoxRewardUpsertArgs} args - Arguments to update or create a PremiumBoxReward.
     * @example
     * // Update or create a PremiumBoxReward
     * const premiumBoxReward = await prisma.premiumBoxReward.upsert({
     *   create: {
     *     // ... data to create a PremiumBoxReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PremiumBoxReward we want to update
     *   }
     * })
     */
    upsert<T extends PremiumBoxRewardUpsertArgs>(args: SelectSubset<T, PremiumBoxRewardUpsertArgs<ExtArgs>>): Prisma__PremiumBoxRewardClient<$Result.GetResult<Prisma.$PremiumBoxRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PremiumBoxRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardCountArgs} args - Arguments to filter PremiumBoxRewards to count.
     * @example
     * // Count the number of PremiumBoxRewards
     * const count = await prisma.premiumBoxReward.count({
     *   where: {
     *     // ... the filter for the PremiumBoxRewards we want to count
     *   }
     * })
    **/
    count<T extends PremiumBoxRewardCountArgs>(
      args?: Subset<T, PremiumBoxRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PremiumBoxRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PremiumBoxReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PremiumBoxRewardAggregateArgs>(args: Subset<T, PremiumBoxRewardAggregateArgs>): Prisma.PrismaPromise<GetPremiumBoxRewardAggregateType<T>>

    /**
     * Group by PremiumBoxReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiumBoxRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PremiumBoxRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PremiumBoxRewardGroupByArgs['orderBy'] }
        : { orderBy?: PremiumBoxRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PremiumBoxRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPremiumBoxRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PremiumBoxReward model
   */
  readonly fields: PremiumBoxRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PremiumBoxReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PremiumBoxRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PremiumBoxReward model
   */
  interface PremiumBoxRewardFieldRefs {
    readonly id: FieldRef<"PremiumBoxReward", 'Int'>
    readonly category: FieldRef<"PremiumBoxReward", 'String'>
    readonly rewardType: FieldRef<"PremiumBoxReward", 'RewardType'>
    readonly rewardValue: FieldRef<"PremiumBoxReward", 'Json'>
    readonly weight: FieldRef<"PremiumBoxReward", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PremiumBoxReward findUnique
   */
  export type PremiumBoxRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter, which PremiumBoxReward to fetch.
     */
    where: PremiumBoxRewardWhereUniqueInput
  }

  /**
   * PremiumBoxReward findUniqueOrThrow
   */
  export type PremiumBoxRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter, which PremiumBoxReward to fetch.
     */
    where: PremiumBoxRewardWhereUniqueInput
  }

  /**
   * PremiumBoxReward findFirst
   */
  export type PremiumBoxRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter, which PremiumBoxReward to fetch.
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PremiumBoxRewards to fetch.
     */
    orderBy?: PremiumBoxRewardOrderByWithRelationInput | PremiumBoxRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PremiumBoxRewards.
     */
    cursor?: PremiumBoxRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PremiumBoxRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PremiumBoxRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PremiumBoxRewards.
     */
    distinct?: PremiumBoxRewardScalarFieldEnum | PremiumBoxRewardScalarFieldEnum[]
  }

  /**
   * PremiumBoxReward findFirstOrThrow
   */
  export type PremiumBoxRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter, which PremiumBoxReward to fetch.
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PremiumBoxRewards to fetch.
     */
    orderBy?: PremiumBoxRewardOrderByWithRelationInput | PremiumBoxRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PremiumBoxRewards.
     */
    cursor?: PremiumBoxRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PremiumBoxRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PremiumBoxRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PremiumBoxRewards.
     */
    distinct?: PremiumBoxRewardScalarFieldEnum | PremiumBoxRewardScalarFieldEnum[]
  }

  /**
   * PremiumBoxReward findMany
   */
  export type PremiumBoxRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter, which PremiumBoxRewards to fetch.
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PremiumBoxRewards to fetch.
     */
    orderBy?: PremiumBoxRewardOrderByWithRelationInput | PremiumBoxRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PremiumBoxRewards.
     */
    cursor?: PremiumBoxRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PremiumBoxRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PremiumBoxRewards.
     */
    skip?: number
    distinct?: PremiumBoxRewardScalarFieldEnum | PremiumBoxRewardScalarFieldEnum[]
  }

  /**
   * PremiumBoxReward create
   */
  export type PremiumBoxRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * The data needed to create a PremiumBoxReward.
     */
    data: XOR<PremiumBoxRewardCreateInput, PremiumBoxRewardUncheckedCreateInput>
  }

  /**
   * PremiumBoxReward createMany
   */
  export type PremiumBoxRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PremiumBoxRewards.
     */
    data: PremiumBoxRewardCreateManyInput | PremiumBoxRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PremiumBoxReward createManyAndReturn
   */
  export type PremiumBoxRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * The data used to create many PremiumBoxRewards.
     */
    data: PremiumBoxRewardCreateManyInput | PremiumBoxRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PremiumBoxReward update
   */
  export type PremiumBoxRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * The data needed to update a PremiumBoxReward.
     */
    data: XOR<PremiumBoxRewardUpdateInput, PremiumBoxRewardUncheckedUpdateInput>
    /**
     * Choose, which PremiumBoxReward to update.
     */
    where: PremiumBoxRewardWhereUniqueInput
  }

  /**
   * PremiumBoxReward updateMany
   */
  export type PremiumBoxRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PremiumBoxRewards.
     */
    data: XOR<PremiumBoxRewardUpdateManyMutationInput, PremiumBoxRewardUncheckedUpdateManyInput>
    /**
     * Filter which PremiumBoxRewards to update
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * Limit how many PremiumBoxRewards to update.
     */
    limit?: number
  }

  /**
   * PremiumBoxReward updateManyAndReturn
   */
  export type PremiumBoxRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * The data used to update PremiumBoxRewards.
     */
    data: XOR<PremiumBoxRewardUpdateManyMutationInput, PremiumBoxRewardUncheckedUpdateManyInput>
    /**
     * Filter which PremiumBoxRewards to update
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * Limit how many PremiumBoxRewards to update.
     */
    limit?: number
  }

  /**
   * PremiumBoxReward upsert
   */
  export type PremiumBoxRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * The filter to search for the PremiumBoxReward to update in case it exists.
     */
    where: PremiumBoxRewardWhereUniqueInput
    /**
     * In case the PremiumBoxReward found by the `where` argument doesn't exist, create a new PremiumBoxReward with this data.
     */
    create: XOR<PremiumBoxRewardCreateInput, PremiumBoxRewardUncheckedCreateInput>
    /**
     * In case the PremiumBoxReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PremiumBoxRewardUpdateInput, PremiumBoxRewardUncheckedUpdateInput>
  }

  /**
   * PremiumBoxReward delete
   */
  export type PremiumBoxRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
    /**
     * Filter which PremiumBoxReward to delete.
     */
    where: PremiumBoxRewardWhereUniqueInput
  }

  /**
   * PremiumBoxReward deleteMany
   */
  export type PremiumBoxRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PremiumBoxRewards to delete
     */
    where?: PremiumBoxRewardWhereInput
    /**
     * Limit how many PremiumBoxRewards to delete.
     */
    limit?: number
  }

  /**
   * PremiumBoxReward without action
   */
  export type PremiumBoxRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PremiumBoxReward
     */
    select?: PremiumBoxRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PremiumBoxReward
     */
    omit?: PremiumBoxRewardOmit<ExtArgs> | null
  }


  /**
   * Model EquipmentReward
   */

  export type AggregateEquipmentReward = {
    _count: EquipmentRewardCountAggregateOutputType | null
    _avg: EquipmentRewardAvgAggregateOutputType | null
    _sum: EquipmentRewardSumAggregateOutputType | null
    _min: EquipmentRewardMinAggregateOutputType | null
    _max: EquipmentRewardMaxAggregateOutputType | null
  }

  export type EquipmentRewardAvgAggregateOutputType = {
    id: number | null
    boxId: number | null
    itemId: number | null
    weight: number | null
  }

  export type EquipmentRewardSumAggregateOutputType = {
    id: number | null
    boxId: number | null
    itemId: number | null
    weight: number | null
  }

  export type EquipmentRewardMinAggregateOutputType = {
    id: number | null
    boxId: number | null
    itemId: number | null
    rarity: $Enums.ItemRarity | null
    weight: number | null
  }

  export type EquipmentRewardMaxAggregateOutputType = {
    id: number | null
    boxId: number | null
    itemId: number | null
    rarity: $Enums.ItemRarity | null
    weight: number | null
  }

  export type EquipmentRewardCountAggregateOutputType = {
    id: number
    boxId: number
    itemId: number
    rarity: number
    weight: number
    _all: number
  }


  export type EquipmentRewardAvgAggregateInputType = {
    id?: true
    boxId?: true
    itemId?: true
    weight?: true
  }

  export type EquipmentRewardSumAggregateInputType = {
    id?: true
    boxId?: true
    itemId?: true
    weight?: true
  }

  export type EquipmentRewardMinAggregateInputType = {
    id?: true
    boxId?: true
    itemId?: true
    rarity?: true
    weight?: true
  }

  export type EquipmentRewardMaxAggregateInputType = {
    id?: true
    boxId?: true
    itemId?: true
    rarity?: true
    weight?: true
  }

  export type EquipmentRewardCountAggregateInputType = {
    id?: true
    boxId?: true
    itemId?: true
    rarity?: true
    weight?: true
    _all?: true
  }

  export type EquipmentRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentReward to aggregate.
     */
    where?: EquipmentRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRewards to fetch.
     */
    orderBy?: EquipmentRewardOrderByWithRelationInput | EquipmentRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentRewards
    **/
    _count?: true | EquipmentRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentRewardMaxAggregateInputType
  }

  export type GetEquipmentRewardAggregateType<T extends EquipmentRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentReward[P]>
      : GetScalarType<T[P], AggregateEquipmentReward[P]>
  }




  export type EquipmentRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentRewardWhereInput
    orderBy?: EquipmentRewardOrderByWithAggregationInput | EquipmentRewardOrderByWithAggregationInput[]
    by: EquipmentRewardScalarFieldEnum[] | EquipmentRewardScalarFieldEnum
    having?: EquipmentRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentRewardCountAggregateInputType | true
    _avg?: EquipmentRewardAvgAggregateInputType
    _sum?: EquipmentRewardSumAggregateInputType
    _min?: EquipmentRewardMinAggregateInputType
    _max?: EquipmentRewardMaxAggregateInputType
  }

  export type EquipmentRewardGroupByOutputType = {
    id: number
    boxId: number
    itemId: number
    rarity: $Enums.ItemRarity
    weight: number
    _count: EquipmentRewardCountAggregateOutputType | null
    _avg: EquipmentRewardAvgAggregateOutputType | null
    _sum: EquipmentRewardSumAggregateOutputType | null
    _min: EquipmentRewardMinAggregateOutputType | null
    _max: EquipmentRewardMaxAggregateOutputType | null
  }

  type GetEquipmentRewardGroupByPayload<T extends EquipmentRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentRewardGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentRewardGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boxId?: boolean
    itemId?: boolean
    rarity?: boolean
    weight?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentReward"]>

  export type EquipmentRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boxId?: boolean
    itemId?: boolean
    rarity?: boolean
    weight?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentReward"]>

  export type EquipmentRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boxId?: boolean
    itemId?: boolean
    rarity?: boolean
    weight?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentReward"]>

  export type EquipmentRewardSelectScalar = {
    id?: boolean
    boxId?: boolean
    itemId?: boolean
    rarity?: boolean
    weight?: boolean
  }

  export type EquipmentRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boxId" | "itemId" | "rarity" | "weight", ExtArgs["result"]["equipmentReward"]>
  export type EquipmentRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type EquipmentRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type EquipmentRewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $EquipmentRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentReward"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      boxId: number
      itemId: number
      rarity: $Enums.ItemRarity
      weight: number
    }, ExtArgs["result"]["equipmentReward"]>
    composites: {}
  }

  type EquipmentRewardGetPayload<S extends boolean | null | undefined | EquipmentRewardDefaultArgs> = $Result.GetResult<Prisma.$EquipmentRewardPayload, S>

  type EquipmentRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentRewardCountAggregateInputType | true
    }

  export interface EquipmentRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentReward'], meta: { name: 'EquipmentReward' } }
    /**
     * Find zero or one EquipmentReward that matches the filter.
     * @param {EquipmentRewardFindUniqueArgs} args - Arguments to find a EquipmentReward
     * @example
     * // Get one EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentRewardFindUniqueArgs>(args: SelectSubset<T, EquipmentRewardFindUniqueArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentRewardFindUniqueOrThrowArgs} args - Arguments to find a EquipmentReward
     * @example
     * // Get one EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardFindFirstArgs} args - Arguments to find a EquipmentReward
     * @example
     * // Get one EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentRewardFindFirstArgs>(args?: SelectSubset<T, EquipmentRewardFindFirstArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardFindFirstOrThrowArgs} args - Arguments to find a EquipmentReward
     * @example
     * // Get one EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentRewards
     * const equipmentRewards = await prisma.equipmentReward.findMany()
     * 
     * // Get first 10 EquipmentRewards
     * const equipmentRewards = await prisma.equipmentReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentRewardWithIdOnly = await prisma.equipmentReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentRewardFindManyArgs>(args?: SelectSubset<T, EquipmentRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentReward.
     * @param {EquipmentRewardCreateArgs} args - Arguments to create a EquipmentReward.
     * @example
     * // Create one EquipmentReward
     * const EquipmentReward = await prisma.equipmentReward.create({
     *   data: {
     *     // ... data to create a EquipmentReward
     *   }
     * })
     * 
     */
    create<T extends EquipmentRewardCreateArgs>(args: SelectSubset<T, EquipmentRewardCreateArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentRewards.
     * @param {EquipmentRewardCreateManyArgs} args - Arguments to create many EquipmentRewards.
     * @example
     * // Create many EquipmentRewards
     * const equipmentReward = await prisma.equipmentReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentRewardCreateManyArgs>(args?: SelectSubset<T, EquipmentRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentRewards and returns the data saved in the database.
     * @param {EquipmentRewardCreateManyAndReturnArgs} args - Arguments to create many EquipmentRewards.
     * @example
     * // Create many EquipmentRewards
     * const equipmentReward = await prisma.equipmentReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentRewards and only return the `id`
     * const equipmentRewardWithIdOnly = await prisma.equipmentReward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentReward.
     * @param {EquipmentRewardDeleteArgs} args - Arguments to delete one EquipmentReward.
     * @example
     * // Delete one EquipmentReward
     * const EquipmentReward = await prisma.equipmentReward.delete({
     *   where: {
     *     // ... filter to delete one EquipmentReward
     *   }
     * })
     * 
     */
    delete<T extends EquipmentRewardDeleteArgs>(args: SelectSubset<T, EquipmentRewardDeleteArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentReward.
     * @param {EquipmentRewardUpdateArgs} args - Arguments to update one EquipmentReward.
     * @example
     * // Update one EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentRewardUpdateArgs>(args: SelectSubset<T, EquipmentRewardUpdateArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentRewards.
     * @param {EquipmentRewardDeleteManyArgs} args - Arguments to filter EquipmentRewards to delete.
     * @example
     * // Delete a few EquipmentRewards
     * const { count } = await prisma.equipmentReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentRewardDeleteManyArgs>(args?: SelectSubset<T, EquipmentRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentRewards
     * const equipmentReward = await prisma.equipmentReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentRewardUpdateManyArgs>(args: SelectSubset<T, EquipmentRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentRewards and returns the data updated in the database.
     * @param {EquipmentRewardUpdateManyAndReturnArgs} args - Arguments to update many EquipmentRewards.
     * @example
     * // Update many EquipmentRewards
     * const equipmentReward = await prisma.equipmentReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentRewards and only return the `id`
     * const equipmentRewardWithIdOnly = await prisma.equipmentReward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentReward.
     * @param {EquipmentRewardUpsertArgs} args - Arguments to update or create a EquipmentReward.
     * @example
     * // Update or create a EquipmentReward
     * const equipmentReward = await prisma.equipmentReward.upsert({
     *   create: {
     *     // ... data to create a EquipmentReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentReward we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentRewardUpsertArgs>(args: SelectSubset<T, EquipmentRewardUpsertArgs<ExtArgs>>): Prisma__EquipmentRewardClient<$Result.GetResult<Prisma.$EquipmentRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardCountArgs} args - Arguments to filter EquipmentRewards to count.
     * @example
     * // Count the number of EquipmentRewards
     * const count = await prisma.equipmentReward.count({
     *   where: {
     *     // ... the filter for the EquipmentRewards we want to count
     *   }
     * })
    **/
    count<T extends EquipmentRewardCountArgs>(
      args?: Subset<T, EquipmentRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentRewardAggregateArgs>(args: Subset<T, EquipmentRewardAggregateArgs>): Prisma.PrismaPromise<GetEquipmentRewardAggregateType<T>>

    /**
     * Group by EquipmentReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentRewardGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentReward model
   */
  readonly fields: EquipmentRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentReward model
   */
  interface EquipmentRewardFieldRefs {
    readonly id: FieldRef<"EquipmentReward", 'Int'>
    readonly boxId: FieldRef<"EquipmentReward", 'Int'>
    readonly itemId: FieldRef<"EquipmentReward", 'Int'>
    readonly rarity: FieldRef<"EquipmentReward", 'ItemRarity'>
    readonly weight: FieldRef<"EquipmentReward", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentReward findUnique
   */
  export type EquipmentRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentReward to fetch.
     */
    where: EquipmentRewardWhereUniqueInput
  }

  /**
   * EquipmentReward findUniqueOrThrow
   */
  export type EquipmentRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentReward to fetch.
     */
    where: EquipmentRewardWhereUniqueInput
  }

  /**
   * EquipmentReward findFirst
   */
  export type EquipmentRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentReward to fetch.
     */
    where?: EquipmentRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRewards to fetch.
     */
    orderBy?: EquipmentRewardOrderByWithRelationInput | EquipmentRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentRewards.
     */
    cursor?: EquipmentRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentRewards.
     */
    distinct?: EquipmentRewardScalarFieldEnum | EquipmentRewardScalarFieldEnum[]
  }

  /**
   * EquipmentReward findFirstOrThrow
   */
  export type EquipmentRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentReward to fetch.
     */
    where?: EquipmentRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRewards to fetch.
     */
    orderBy?: EquipmentRewardOrderByWithRelationInput | EquipmentRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentRewards.
     */
    cursor?: EquipmentRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentRewards.
     */
    distinct?: EquipmentRewardScalarFieldEnum | EquipmentRewardScalarFieldEnum[]
  }

  /**
   * EquipmentReward findMany
   */
  export type EquipmentRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentRewards to fetch.
     */
    where?: EquipmentRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRewards to fetch.
     */
    orderBy?: EquipmentRewardOrderByWithRelationInput | EquipmentRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentRewards.
     */
    cursor?: EquipmentRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRewards.
     */
    skip?: number
    distinct?: EquipmentRewardScalarFieldEnum | EquipmentRewardScalarFieldEnum[]
  }

  /**
   * EquipmentReward create
   */
  export type EquipmentRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentReward.
     */
    data: XOR<EquipmentRewardCreateInput, EquipmentRewardUncheckedCreateInput>
  }

  /**
   * EquipmentReward createMany
   */
  export type EquipmentRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentRewards.
     */
    data: EquipmentRewardCreateManyInput | EquipmentRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentReward createManyAndReturn
   */
  export type EquipmentRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentRewards.
     */
    data: EquipmentRewardCreateManyInput | EquipmentRewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentReward update
   */
  export type EquipmentRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentReward.
     */
    data: XOR<EquipmentRewardUpdateInput, EquipmentRewardUncheckedUpdateInput>
    /**
     * Choose, which EquipmentReward to update.
     */
    where: EquipmentRewardWhereUniqueInput
  }

  /**
   * EquipmentReward updateMany
   */
  export type EquipmentRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentRewards.
     */
    data: XOR<EquipmentRewardUpdateManyMutationInput, EquipmentRewardUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentRewards to update
     */
    where?: EquipmentRewardWhereInput
    /**
     * Limit how many EquipmentRewards to update.
     */
    limit?: number
  }

  /**
   * EquipmentReward updateManyAndReturn
   */
  export type EquipmentRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentRewards.
     */
    data: XOR<EquipmentRewardUpdateManyMutationInput, EquipmentRewardUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentRewards to update
     */
    where?: EquipmentRewardWhereInput
    /**
     * Limit how many EquipmentRewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentReward upsert
   */
  export type EquipmentRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentReward to update in case it exists.
     */
    where: EquipmentRewardWhereUniqueInput
    /**
     * In case the EquipmentReward found by the `where` argument doesn't exist, create a new EquipmentReward with this data.
     */
    create: XOR<EquipmentRewardCreateInput, EquipmentRewardUncheckedCreateInput>
    /**
     * In case the EquipmentReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentRewardUpdateInput, EquipmentRewardUncheckedUpdateInput>
  }

  /**
   * EquipmentReward delete
   */
  export type EquipmentRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
    /**
     * Filter which EquipmentReward to delete.
     */
    where: EquipmentRewardWhereUniqueInput
  }

  /**
   * EquipmentReward deleteMany
   */
  export type EquipmentRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentRewards to delete
     */
    where?: EquipmentRewardWhereInput
    /**
     * Limit how many EquipmentRewards to delete.
     */
    limit?: number
  }

  /**
   * EquipmentReward without action
   */
  export type EquipmentRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentReward
     */
    select?: EquipmentRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentReward
     */
    omit?: EquipmentRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentRewardInclude<ExtArgs> | null
  }


  /**
   * Model Tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    id: number | null
    division: number | null
    entryFeeCredits: number | null
    entryFeeGems: number | null
    entryFeeItemId: number | null
    seasonDay: number | null
  }

  export type TournamentSumAggregateOutputType = {
    id: number | null
    division: number | null
    entryFeeCredits: bigint | null
    entryFeeGems: number | null
    entryFeeItemId: number | null
    seasonDay: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: number | null
    name: string | null
    tournamentId: string | null
    type: $Enums.TournamentType | null
    division: number | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    registrationEndTime: Date | null
    endTime: Date | null
    entryFeeCredits: bigint | null
    entryFeeGems: number | null
    entryFeeItemId: number | null
    seasonDay: number | null
    createdAt: Date | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tournamentId: string | null
    type: $Enums.TournamentType | null
    division: number | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    registrationEndTime: Date | null
    endTime: Date | null
    entryFeeCredits: bigint | null
    entryFeeGems: number | null
    entryFeeItemId: number | null
    seasonDay: number | null
    createdAt: Date | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    name: number
    tournamentId: number
    type: number
    division: number
    status: number
    startTime: number
    registrationEndTime: number
    endTime: number
    entryFeeCredits: number
    entryFeeGems: number
    entryFeeItemId: number
    prizePoolJson: number
    seasonDay: number
    createdAt: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    id?: true
    division?: true
    entryFeeCredits?: true
    entryFeeGems?: true
    entryFeeItemId?: true
    seasonDay?: true
  }

  export type TournamentSumAggregateInputType = {
    id?: true
    division?: true
    entryFeeCredits?: true
    entryFeeGems?: true
    entryFeeItemId?: true
    seasonDay?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    tournamentId?: true
    type?: true
    division?: true
    status?: true
    startTime?: true
    registrationEndTime?: true
    endTime?: true
    entryFeeCredits?: true
    entryFeeGems?: true
    entryFeeItemId?: true
    seasonDay?: true
    createdAt?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    tournamentId?: true
    type?: true
    division?: true
    status?: true
    startTime?: true
    registrationEndTime?: true
    endTime?: true
    entryFeeCredits?: true
    entryFeeGems?: true
    entryFeeItemId?: true
    seasonDay?: true
    createdAt?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    tournamentId?: true
    type?: true
    division?: true
    status?: true
    startTime?: true
    registrationEndTime?: true
    endTime?: true
    entryFeeCredits?: true
    entryFeeGems?: true
    entryFeeItemId?: true
    prizePoolJson?: true
    seasonDay?: true
    createdAt?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournament to aggregate.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type TournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithAggregationInput | TournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: TournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: number
    name: string
    tournamentId: string | null
    type: $Enums.TournamentType
    division: number | null
    status: $Enums.TournamentStatus
    startTime: Date
    registrationEndTime: Date | null
    endTime: Date | null
    entryFeeCredits: bigint | null
    entryFeeGems: number | null
    entryFeeItemId: number | null
    prizePoolJson: JsonValue
    seasonDay: number | null
    createdAt: Date
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends TournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type TournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tournamentId?: boolean
    type?: boolean
    division?: boolean
    status?: boolean
    startTime?: boolean
    registrationEndTime?: boolean
    endTime?: boolean
    entryFeeCredits?: boolean
    entryFeeGems?: boolean
    entryFeeItemId?: boolean
    prizePoolJson?: boolean
    seasonDay?: boolean
    createdAt?: boolean
    games?: boolean | Tournament$gamesArgs<ExtArgs>
    entries?: boolean | Tournament$entriesArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tournamentId?: boolean
    type?: boolean
    division?: boolean
    status?: boolean
    startTime?: boolean
    registrationEndTime?: boolean
    endTime?: boolean
    entryFeeCredits?: boolean
    entryFeeGems?: boolean
    entryFeeItemId?: boolean
    prizePoolJson?: boolean
    seasonDay?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tournamentId?: boolean
    type?: boolean
    division?: boolean
    status?: boolean
    startTime?: boolean
    registrationEndTime?: boolean
    endTime?: boolean
    entryFeeCredits?: boolean
    entryFeeGems?: boolean
    entryFeeItemId?: boolean
    prizePoolJson?: boolean
    seasonDay?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectScalar = {
    id?: boolean
    name?: boolean
    tournamentId?: boolean
    type?: boolean
    division?: boolean
    status?: boolean
    startTime?: boolean
    registrationEndTime?: boolean
    endTime?: boolean
    entryFeeCredits?: boolean
    entryFeeGems?: boolean
    entryFeeItemId?: boolean
    prizePoolJson?: boolean
    seasonDay?: boolean
    createdAt?: boolean
  }

  export type TournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tournamentId" | "type" | "division" | "status" | "startTime" | "registrationEndTime" | "endTime" | "entryFeeCredits" | "entryFeeGems" | "entryFeeItemId" | "prizePoolJson" | "seasonDay" | "createdAt", ExtArgs["result"]["tournament"]>
  export type TournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Tournament$gamesArgs<ExtArgs>
    entries?: boolean | Tournament$entriesArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournament"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
      entries: Prisma.$TournamentEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tournamentId: string | null
      type: $Enums.TournamentType
      division: number | null
      status: $Enums.TournamentStatus
      startTime: Date
      registrationEndTime: Date | null
      endTime: Date | null
      entryFeeCredits: bigint | null
      entryFeeGems: number | null
      entryFeeItemId: number | null
      prizePoolJson: Prisma.JsonValue
      seasonDay: number | null
      createdAt: Date
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type TournamentGetPayload<S extends boolean | null | undefined | TournamentDefaultArgs> = $Result.GetResult<Prisma.$TournamentPayload, S>

  type TournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface TournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournament'], meta: { name: 'Tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentFindUniqueArgs>(args: SelectSubset<T, TournamentFindUniqueArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentFindFirstArgs>(args?: SelectSubset<T, TournamentFindFirstArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentFindManyArgs>(args?: SelectSubset<T, TournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends TournamentCreateArgs>(args: SelectSubset<T, TournamentCreateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {TournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentCreateManyArgs>(args?: SelectSubset<T, TournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {TournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends TournamentDeleteArgs>(args: SelectSubset<T, TournamentDeleteArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUpdateArgs>(args: SelectSubset<T, TournamentUpdateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentDeleteManyArgs>(args?: SelectSubset<T, TournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUpdateManyArgs>(args: SelectSubset<T, TournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {TournamentUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUpsertArgs>(args: SelectSubset<T, TournamentUpsertArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentGroupByArgs['orderBy'] }
        : { orderBy?: TournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournament model
   */
  readonly fields: TournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Tournament$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries<T extends Tournament$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournament model
   */
  interface TournamentFieldRefs {
    readonly id: FieldRef<"Tournament", 'Int'>
    readonly name: FieldRef<"Tournament", 'String'>
    readonly tournamentId: FieldRef<"Tournament", 'String'>
    readonly type: FieldRef<"Tournament", 'TournamentType'>
    readonly division: FieldRef<"Tournament", 'Int'>
    readonly status: FieldRef<"Tournament", 'TournamentStatus'>
    readonly startTime: FieldRef<"Tournament", 'DateTime'>
    readonly registrationEndTime: FieldRef<"Tournament", 'DateTime'>
    readonly endTime: FieldRef<"Tournament", 'DateTime'>
    readonly entryFeeCredits: FieldRef<"Tournament", 'BigInt'>
    readonly entryFeeGems: FieldRef<"Tournament", 'Int'>
    readonly entryFeeItemId: FieldRef<"Tournament", 'Int'>
    readonly prizePoolJson: FieldRef<"Tournament", 'Json'>
    readonly seasonDay: FieldRef<"Tournament", 'Int'>
    readonly createdAt: FieldRef<"Tournament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findUniqueOrThrow
   */
  export type TournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findFirstOrThrow
   */
  export type TournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournaments to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament create
   */
  export type TournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournament.
     */
    data: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
  }

  /**
   * Tournament createMany
   */
  export type TournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament createManyAndReturn
   */
  export type TournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament update
   */
  export type TournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournament.
     */
    data: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
    /**
     * Choose, which Tournament to update.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
  }

  /**
   * Tournament updateManyAndReturn
   */
  export type TournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
  }

  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournament to update in case it exists.
     */
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
     */
    create: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
  }

  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter which Tournament to delete.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournaments to delete
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to delete.
     */
    limit?: number
  }

  /**
   * Tournament.games
   */
  export type Tournament$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Tournament.entries
   */
  export type Tournament$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    where?: TournamentEntryWhereInput
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    cursor?: TournamentEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentEntryScalarFieldEnum | TournamentEntryScalarFieldEnum[]
  }

  /**
   * Tournament without action
   */
  export type TournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
  }


  /**
   * Model TournamentEntry
   */

  export type AggregateTournamentEntry = {
    _count: TournamentEntryCountAggregateOutputType | null
    _avg: TournamentEntryAvgAggregateOutputType | null
    _sum: TournamentEntrySumAggregateOutputType | null
    _min: TournamentEntryMinAggregateOutputType | null
    _max: TournamentEntryMaxAggregateOutputType | null
  }

  export type TournamentEntryAvgAggregateOutputType = {
    id: number | null
    tournamentId: number | null
    teamId: number | null
    finalRank: number | null
  }

  export type TournamentEntrySumAggregateOutputType = {
    id: number | null
    tournamentId: number | null
    teamId: number | null
    finalRank: number | null
  }

  export type TournamentEntryMinAggregateOutputType = {
    id: number | null
    tournamentId: number | null
    teamId: number | null
    registeredAt: Date | null
    finalRank: number | null
    rewardsClaimed: boolean | null
  }

  export type TournamentEntryMaxAggregateOutputType = {
    id: number | null
    tournamentId: number | null
    teamId: number | null
    registeredAt: Date | null
    finalRank: number | null
    rewardsClaimed: boolean | null
  }

  export type TournamentEntryCountAggregateOutputType = {
    id: number
    tournamentId: number
    teamId: number
    registeredAt: number
    finalRank: number
    rewardsClaimed: number
    _all: number
  }


  export type TournamentEntryAvgAggregateInputType = {
    id?: true
    tournamentId?: true
    teamId?: true
    finalRank?: true
  }

  export type TournamentEntrySumAggregateInputType = {
    id?: true
    tournamentId?: true
    teamId?: true
    finalRank?: true
  }

  export type TournamentEntryMinAggregateInputType = {
    id?: true
    tournamentId?: true
    teamId?: true
    registeredAt?: true
    finalRank?: true
    rewardsClaimed?: true
  }

  export type TournamentEntryMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    teamId?: true
    registeredAt?: true
    finalRank?: true
    rewardsClaimed?: true
  }

  export type TournamentEntryCountAggregateInputType = {
    id?: true
    tournamentId?: true
    teamId?: true
    registeredAt?: true
    finalRank?: true
    rewardsClaimed?: true
    _all?: true
  }

  export type TournamentEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentEntry to aggregate.
     */
    where?: TournamentEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentEntries to fetch.
     */
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentEntries
    **/
    _count?: true | TournamentEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentEntryMaxAggregateInputType
  }

  export type GetTournamentEntryAggregateType<T extends TournamentEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentEntry[P]>
      : GetScalarType<T[P], AggregateTournamentEntry[P]>
  }




  export type TournamentEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentEntryWhereInput
    orderBy?: TournamentEntryOrderByWithAggregationInput | TournamentEntryOrderByWithAggregationInput[]
    by: TournamentEntryScalarFieldEnum[] | TournamentEntryScalarFieldEnum
    having?: TournamentEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentEntryCountAggregateInputType | true
    _avg?: TournamentEntryAvgAggregateInputType
    _sum?: TournamentEntrySumAggregateInputType
    _min?: TournamentEntryMinAggregateInputType
    _max?: TournamentEntryMaxAggregateInputType
  }

  export type TournamentEntryGroupByOutputType = {
    id: number
    tournamentId: number
    teamId: number
    registeredAt: Date
    finalRank: number | null
    rewardsClaimed: boolean
    _count: TournamentEntryCountAggregateOutputType | null
    _avg: TournamentEntryAvgAggregateOutputType | null
    _sum: TournamentEntrySumAggregateOutputType | null
    _min: TournamentEntryMinAggregateOutputType | null
    _max: TournamentEntryMaxAggregateOutputType | null
  }

  type GetTournamentEntryGroupByPayload<T extends TournamentEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentEntryGroupByOutputType[P]>
        }
      >
    >


  export type TournamentEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    teamId?: boolean
    registeredAt?: boolean
    finalRank?: boolean
    rewardsClaimed?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentEntry"]>

  export type TournamentEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    teamId?: boolean
    registeredAt?: boolean
    finalRank?: boolean
    rewardsClaimed?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentEntry"]>

  export type TournamentEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    teamId?: boolean
    registeredAt?: boolean
    finalRank?: boolean
    rewardsClaimed?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentEntry"]>

  export type TournamentEntrySelectScalar = {
    id?: boolean
    tournamentId?: boolean
    teamId?: boolean
    registeredAt?: boolean
    finalRank?: boolean
    rewardsClaimed?: boolean
  }

  export type TournamentEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tournamentId" | "teamId" | "registeredAt" | "finalRank" | "rewardsClaimed", ExtArgs["result"]["tournamentEntry"]>
  export type TournamentEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TournamentEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TournamentEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TournamentEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentEntry"
    objects: {
      tournament: Prisma.$TournamentPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tournamentId: number
      teamId: number
      registeredAt: Date
      finalRank: number | null
      rewardsClaimed: boolean
    }, ExtArgs["result"]["tournamentEntry"]>
    composites: {}
  }

  type TournamentEntryGetPayload<S extends boolean | null | undefined | TournamentEntryDefaultArgs> = $Result.GetResult<Prisma.$TournamentEntryPayload, S>

  type TournamentEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentEntryCountAggregateInputType | true
    }

  export interface TournamentEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentEntry'], meta: { name: 'TournamentEntry' } }
    /**
     * Find zero or one TournamentEntry that matches the filter.
     * @param {TournamentEntryFindUniqueArgs} args - Arguments to find a TournamentEntry
     * @example
     * // Get one TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentEntryFindUniqueArgs>(args: SelectSubset<T, TournamentEntryFindUniqueArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TournamentEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentEntryFindUniqueOrThrowArgs} args - Arguments to find a TournamentEntry
     * @example
     * // Get one TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryFindFirstArgs} args - Arguments to find a TournamentEntry
     * @example
     * // Get one TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentEntryFindFirstArgs>(args?: SelectSubset<T, TournamentEntryFindFirstArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryFindFirstOrThrowArgs} args - Arguments to find a TournamentEntry
     * @example
     * // Get one TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TournamentEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentEntries
     * const tournamentEntries = await prisma.tournamentEntry.findMany()
     * 
     * // Get first 10 TournamentEntries
     * const tournamentEntries = await prisma.tournamentEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentEntryWithIdOnly = await prisma.tournamentEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentEntryFindManyArgs>(args?: SelectSubset<T, TournamentEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TournamentEntry.
     * @param {TournamentEntryCreateArgs} args - Arguments to create a TournamentEntry.
     * @example
     * // Create one TournamentEntry
     * const TournamentEntry = await prisma.tournamentEntry.create({
     *   data: {
     *     // ... data to create a TournamentEntry
     *   }
     * })
     * 
     */
    create<T extends TournamentEntryCreateArgs>(args: SelectSubset<T, TournamentEntryCreateArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TournamentEntries.
     * @param {TournamentEntryCreateManyArgs} args - Arguments to create many TournamentEntries.
     * @example
     * // Create many TournamentEntries
     * const tournamentEntry = await prisma.tournamentEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentEntryCreateManyArgs>(args?: SelectSubset<T, TournamentEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentEntries and returns the data saved in the database.
     * @param {TournamentEntryCreateManyAndReturnArgs} args - Arguments to create many TournamentEntries.
     * @example
     * // Create many TournamentEntries
     * const tournamentEntry = await prisma.tournamentEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentEntries and only return the `id`
     * const tournamentEntryWithIdOnly = await prisma.tournamentEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TournamentEntry.
     * @param {TournamentEntryDeleteArgs} args - Arguments to delete one TournamentEntry.
     * @example
     * // Delete one TournamentEntry
     * const TournamentEntry = await prisma.tournamentEntry.delete({
     *   where: {
     *     // ... filter to delete one TournamentEntry
     *   }
     * })
     * 
     */
    delete<T extends TournamentEntryDeleteArgs>(args: SelectSubset<T, TournamentEntryDeleteArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TournamentEntry.
     * @param {TournamentEntryUpdateArgs} args - Arguments to update one TournamentEntry.
     * @example
     * // Update one TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentEntryUpdateArgs>(args: SelectSubset<T, TournamentEntryUpdateArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TournamentEntries.
     * @param {TournamentEntryDeleteManyArgs} args - Arguments to filter TournamentEntries to delete.
     * @example
     * // Delete a few TournamentEntries
     * const { count } = await prisma.tournamentEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentEntryDeleteManyArgs>(args?: SelectSubset<T, TournamentEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentEntries
     * const tournamentEntry = await prisma.tournamentEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentEntryUpdateManyArgs>(args: SelectSubset<T, TournamentEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentEntries and returns the data updated in the database.
     * @param {TournamentEntryUpdateManyAndReturnArgs} args - Arguments to update many TournamentEntries.
     * @example
     * // Update many TournamentEntries
     * const tournamentEntry = await prisma.tournamentEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TournamentEntries and only return the `id`
     * const tournamentEntryWithIdOnly = await prisma.tournamentEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TournamentEntry.
     * @param {TournamentEntryUpsertArgs} args - Arguments to update or create a TournamentEntry.
     * @example
     * // Update or create a TournamentEntry
     * const tournamentEntry = await prisma.tournamentEntry.upsert({
     *   create: {
     *     // ... data to create a TournamentEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentEntry we want to update
     *   }
     * })
     */
    upsert<T extends TournamentEntryUpsertArgs>(args: SelectSubset<T, TournamentEntryUpsertArgs<ExtArgs>>): Prisma__TournamentEntryClient<$Result.GetResult<Prisma.$TournamentEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TournamentEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryCountArgs} args - Arguments to filter TournamentEntries to count.
     * @example
     * // Count the number of TournamentEntries
     * const count = await prisma.tournamentEntry.count({
     *   where: {
     *     // ... the filter for the TournamentEntries we want to count
     *   }
     * })
    **/
    count<T extends TournamentEntryCountArgs>(
      args?: Subset<T, TournamentEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentEntryAggregateArgs>(args: Subset<T, TournamentEntryAggregateArgs>): Prisma.PrismaPromise<GetTournamentEntryAggregateType<T>>

    /**
     * Group by TournamentEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentEntryGroupByArgs['orderBy'] }
        : { orderBy?: TournamentEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentEntry model
   */
  readonly fields: TournamentEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentEntry model
   */
  interface TournamentEntryFieldRefs {
    readonly id: FieldRef<"TournamentEntry", 'Int'>
    readonly tournamentId: FieldRef<"TournamentEntry", 'Int'>
    readonly teamId: FieldRef<"TournamentEntry", 'Int'>
    readonly registeredAt: FieldRef<"TournamentEntry", 'DateTime'>
    readonly finalRank: FieldRef<"TournamentEntry", 'Int'>
    readonly rewardsClaimed: FieldRef<"TournamentEntry", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TournamentEntry findUnique
   */
  export type TournamentEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter, which TournamentEntry to fetch.
     */
    where: TournamentEntryWhereUniqueInput
  }

  /**
   * TournamentEntry findUniqueOrThrow
   */
  export type TournamentEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter, which TournamentEntry to fetch.
     */
    where: TournamentEntryWhereUniqueInput
  }

  /**
   * TournamentEntry findFirst
   */
  export type TournamentEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter, which TournamentEntry to fetch.
     */
    where?: TournamentEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentEntries to fetch.
     */
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentEntries.
     */
    cursor?: TournamentEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentEntries.
     */
    distinct?: TournamentEntryScalarFieldEnum | TournamentEntryScalarFieldEnum[]
  }

  /**
   * TournamentEntry findFirstOrThrow
   */
  export type TournamentEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter, which TournamentEntry to fetch.
     */
    where?: TournamentEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentEntries to fetch.
     */
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentEntries.
     */
    cursor?: TournamentEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentEntries.
     */
    distinct?: TournamentEntryScalarFieldEnum | TournamentEntryScalarFieldEnum[]
  }

  /**
   * TournamentEntry findMany
   */
  export type TournamentEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter, which TournamentEntries to fetch.
     */
    where?: TournamentEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentEntries to fetch.
     */
    orderBy?: TournamentEntryOrderByWithRelationInput | TournamentEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentEntries.
     */
    cursor?: TournamentEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentEntries.
     */
    skip?: number
    distinct?: TournamentEntryScalarFieldEnum | TournamentEntryScalarFieldEnum[]
  }

  /**
   * TournamentEntry create
   */
  export type TournamentEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentEntry.
     */
    data: XOR<TournamentEntryCreateInput, TournamentEntryUncheckedCreateInput>
  }

  /**
   * TournamentEntry createMany
   */
  export type TournamentEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentEntries.
     */
    data: TournamentEntryCreateManyInput | TournamentEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TournamentEntry createManyAndReturn
   */
  export type TournamentEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * The data used to create many TournamentEntries.
     */
    data: TournamentEntryCreateManyInput | TournamentEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentEntry update
   */
  export type TournamentEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentEntry.
     */
    data: XOR<TournamentEntryUpdateInput, TournamentEntryUncheckedUpdateInput>
    /**
     * Choose, which TournamentEntry to update.
     */
    where: TournamentEntryWhereUniqueInput
  }

  /**
   * TournamentEntry updateMany
   */
  export type TournamentEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentEntries.
     */
    data: XOR<TournamentEntryUpdateManyMutationInput, TournamentEntryUncheckedUpdateManyInput>
    /**
     * Filter which TournamentEntries to update
     */
    where?: TournamentEntryWhereInput
    /**
     * Limit how many TournamentEntries to update.
     */
    limit?: number
  }

  /**
   * TournamentEntry updateManyAndReturn
   */
  export type TournamentEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * The data used to update TournamentEntries.
     */
    data: XOR<TournamentEntryUpdateManyMutationInput, TournamentEntryUncheckedUpdateManyInput>
    /**
     * Filter which TournamentEntries to update
     */
    where?: TournamentEntryWhereInput
    /**
     * Limit how many TournamentEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentEntry upsert
   */
  export type TournamentEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentEntry to update in case it exists.
     */
    where: TournamentEntryWhereUniqueInput
    /**
     * In case the TournamentEntry found by the `where` argument doesn't exist, create a new TournamentEntry with this data.
     */
    create: XOR<TournamentEntryCreateInput, TournamentEntryUncheckedCreateInput>
    /**
     * In case the TournamentEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentEntryUpdateInput, TournamentEntryUncheckedUpdateInput>
  }

  /**
   * TournamentEntry delete
   */
  export type TournamentEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
    /**
     * Filter which TournamentEntry to delete.
     */
    where: TournamentEntryWhereUniqueInput
  }

  /**
   * TournamentEntry deleteMany
   */
  export type TournamentEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentEntries to delete
     */
    where?: TournamentEntryWhereInput
    /**
     * Limit how many TournamentEntries to delete.
     */
    limit?: number
  }

  /**
   * TournamentEntry without action
   */
  export type TournamentEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentEntry
     */
    select?: TournamentEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentEntry
     */
    omit?: TournamentEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentEntryInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    creditsAmount: number | null
    gemsAmount: number | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    creditsAmount: bigint | null
    gemsAmount: number | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: number | null
    userId: string | null
    teamId: number | null
    transactionType: string | null
    itemName: string | null
    itemType: string | null
    creditsAmount: bigint | null
    gemsAmount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    teamId: number | null
    transactionType: string | null
    itemName: string | null
    itemType: string | null
    creditsAmount: bigint | null
    gemsAmount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    userId: number
    teamId: number
    transactionType: number
    itemName: number
    itemType: number
    creditsAmount: number
    gemsAmount: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    id?: true
    teamId?: true
    creditsAmount?: true
    gemsAmount?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    id?: true
    teamId?: true
    creditsAmount?: true
    gemsAmount?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    transactionType?: true
    itemName?: true
    itemType?: true
    creditsAmount?: true
    gemsAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    transactionType?: true
    itemName?: true
    itemType?: true
    creditsAmount?: true
    gemsAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    transactionType?: true
    itemName?: true
    itemType?: true
    creditsAmount?: true
    gemsAmount?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: number
    userId: string
    teamId: number
    transactionType: string
    itemName: string
    itemType: string
    creditsAmount: bigint
    gemsAmount: number
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    transactionType?: boolean
    itemName?: boolean
    itemType?: boolean
    creditsAmount?: boolean
    gemsAmount?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    transactionType?: boolean
    itemName?: boolean
    itemType?: boolean
    creditsAmount?: boolean
    gemsAmount?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    transactionType?: boolean
    itemName?: boolean
    itemType?: boolean
    creditsAmount?: boolean
    gemsAmount?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    teamId?: boolean
    transactionType?: boolean
    itemName?: boolean
    itemType?: boolean
    creditsAmount?: boolean
    gemsAmount?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "teamId" | "transactionType" | "itemName" | "itemType" | "creditsAmount" | "gemsAmount" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentTransaction"]>

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      teamId: number
      transactionType: string
      itemName: string
      itemType: string
      creditsAmount: bigint
      gemsAmount: number
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions and returns the data updated in the database.
     * @param {PaymentTransactionUpdateManyAndReturnArgs} args - Arguments to update many PaymentTransactions.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'Int'>
    readonly userId: FieldRef<"PaymentTransaction", 'String'>
    readonly teamId: FieldRef<"PaymentTransaction", 'Int'>
    readonly transactionType: FieldRef<"PaymentTransaction", 'String'>
    readonly itemName: FieldRef<"PaymentTransaction", 'String'>
    readonly itemType: FieldRef<"PaymentTransaction", 'String'>
    readonly creditsAmount: FieldRef<"PaymentTransaction", 'BigInt'>
    readonly gemsAmount: FieldRef<"PaymentTransaction", 'Int'>
    readonly status: FieldRef<"PaymentTransaction", 'String'>
    readonly metadata: FieldRef<"PaymentTransaction", 'Json'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction updateManyAndReturn
   */
  export type PaymentTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to delete.
     */
    limit?: number
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImageUrl: 'profileImageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referralCode: 'referralCode',
    referredBy: 'referredBy',
    ndaAccepted: 'ndaAccepted',
    ndaAcceptedAt: 'ndaAcceptedAt',
    ndaVersion: 'ndaVersion'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sid: 'sid',
    sess: 'sess',
    expire: 'expire'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    name: 'name',
    logoUrl: 'logoUrl',
    isAI: 'isAI',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    camaraderie: 'camaraderie',
    fanLoyalty: 'fanLoyalty',
    homeField: 'homeField',
    tacticalFocus: 'tacticalFocus',
    leagueId: 'leagueId',
    division: 'division',
    subdivision: 'subdivision',
    wins: 'wins',
    losses: 'losses',
    points: 'points'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    firstName: 'firstName',
    lastName: 'lastName',
    race: 'race',
    age: 'age',
    role: 'role',
    speed: 'speed',
    power: 'power',
    throwing: 'throwing',
    catching: 'catching',
    kicking: 'kicking',
    staminaAttribute: 'staminaAttribute',
    leadership: 'leadership',
    agility: 'agility',
    potentialRating: 'potentialRating',
    dailyStaminaLevel: 'dailyStaminaLevel',
    injuryStatus: 'injuryStatus',
    injuryRecoveryPointsNeeded: 'injuryRecoveryPointsNeeded',
    injuryRecoveryPointsCurrent: 'injuryRecoveryPointsCurrent',
    dailyItemsUsed: 'dailyItemsUsed',
    careerInjuries: 'careerInjuries',
    gamesPlayedLastSeason: 'gamesPlayedLastSeason',
    seasonMinutesLeague: 'seasonMinutesLeague',
    seasonMinutesTournament: 'seasonMinutesTournament',
    seasonMinutesExhibition: 'seasonMinutesExhibition',
    seasonMinutesTotal: 'seasonMinutesTotal',
    isOnMarket: 'isOnMarket',
    isRetired: 'isRetired',
    camaraderieScore: 'camaraderieScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const PlayerEquipmentScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    itemId: 'itemId',
    equippedAt: 'equippedAt'
  };

  export type PlayerEquipmentScalarFieldEnum = (typeof PlayerEquipmentScalarFieldEnum)[keyof typeof PlayerEquipmentScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    staffId: 'staffId',
    salary: 'salary',
    length: 'length',
    signingBonus: 'signingBonus',
    startDate: 'startDate'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    tiers: 'tiers'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const PlayerSkillLinkScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    skillId: 'skillId',
    currentTier: 'currentTier',
    acquiredAt: 'acquiredAt'
  };

  export type PlayerSkillLinkScalarFieldEnum = (typeof PlayerSkillLinkScalarFieldEnum)[keyof typeof PlayerSkillLinkScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    type: 'type',
    name: 'name',
    level: 'level',
    motivation: 'motivation',
    development: 'development',
    teaching: 'teaching',
    physiology: 'physiology',
    talentIdentification: 'talentIdentification',
    potentialAssessment: 'potentialAssessment',
    tactics: 'tactics',
    age: 'age',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const TeamFinancesScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    credits: 'credits',
    gems: 'gems',
    escrowCredits: 'escrowCredits',
    escrowGems: 'escrowGems',
    projectedIncome: 'projectedIncome',
    projectedExpenses: 'projectedExpenses',
    lastSeasonRevenue: 'lastSeasonRevenue',
    lastSeasonExpenses: 'lastSeasonExpenses',
    facilitiesMaintenanceCost: 'facilitiesMaintenanceCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamFinancesScalarFieldEnum = (typeof TeamFinancesScalarFieldEnum)[keyof typeof TeamFinancesScalarFieldEnum]


  export const StadiumScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    capacity: 'capacity',
    concessionsLevel: 'concessionsLevel',
    parkingLevel: 'parkingLevel',
    vipSuitesLevel: 'vipSuitesLevel',
    merchandisingLevel: 'merchandisingLevel',
    lightingScreensLevel: 'lightingScreensLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StadiumScalarFieldEnum = (typeof StadiumScalarFieldEnum)[keyof typeof StadiumScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    slot: 'slot',
    raceRestriction: 'raceRestriction',
    statEffects: 'statEffects',
    rarity: 'rarity',
    creditPrice: 'creditPrice',
    gemPrice: 'gemPrice',
    effectValue: 'effectValue'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    itemId: 'itemId',
    quantity: 'quantity',
    acquiredAt: 'acquiredAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const ActiveBoostScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    playerId: 'playerId',
    itemId: 'itemId',
    matchType: 'matchType',
    isActive: 'isActive',
    appliedAt: 'appliedAt'
  };

  export type ActiveBoostScalarFieldEnum = (typeof ActiveBoostScalarFieldEnum)[keyof typeof ActiveBoostScalarFieldEnum]


  export const MarketplaceListingScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    sellerTeamId: 'sellerTeamId',
    startBid: 'startBid',
    buyNowPrice: 'buyNowPrice',
    minBuyNowPrice: 'minBuyNowPrice',
    currentBid: 'currentBid',
    currentHighBidderTeamId: 'currentHighBidderTeamId',
    expiryTimestamp: 'expiryTimestamp',
    originalExpiryTimestamp: 'originalExpiryTimestamp',
    auctionExtensions: 'auctionExtensions',
    listingFee: 'listingFee',
    marketTaxRate: 'marketTaxRate',
    escrowAmount: 'escrowAmount',
    listingStatus: 'listingStatus',
    isOffSeasonConverted: 'isOffSeasonConverted',
    autoDelistAt: 'autoDelistAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceListingScalarFieldEnum = (typeof MarketplaceListingScalarFieldEnum)[keyof typeof MarketplaceListingScalarFieldEnum]


  export const BidScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    bidderTeamId: 'bidderTeamId',
    bidAmount: 'bidAmount',
    escrowAmount: 'escrowAmount',
    isWinningBid: 'isWinningBid',
    isRefunded: 'isRefunded',
    placedAt: 'placedAt'
  };

  export type BidScalarFieldEnum = (typeof BidScalarFieldEnum)[keyof typeof BidScalarFieldEnum]


  export const ListingHistoryScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    actionType: 'actionType',
    teamId: 'teamId',
    amount: 'amount',
    oldValue: 'oldValue',
    newValue: 'newValue',
    description: 'description',
    timestamp: 'timestamp'
  };

  export type ListingHistoryScalarFieldEnum = (typeof ListingHistoryScalarFieldEnum)[keyof typeof ListingHistoryScalarFieldEnum]


  export const PlayerMarketValueScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    carRating: 'carRating',
    potential: 'potential',
    minBuyNow: 'minBuyNow',
    marketValue: 'marketValue',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt'
  };

  export type PlayerMarketValueScalarFieldEnum = (typeof PlayerMarketValueScalarFieldEnum)[keyof typeof PlayerMarketValueScalarFieldEnum]


  export const StrategyScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    formationJson: 'formationJson',
    substitutionJson: 'substitutionJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StrategyScalarFieldEnum = (typeof StrategyScalarFieldEnum)[keyof typeof StrategyScalarFieldEnum]


  export const LeagueScalarFieldEnum: {
    id: 'id',
    division: 'division',
    name: 'name',
    seasonId: 'seasonId'
  };

  export type LeagueScalarFieldEnum = (typeof LeagueScalarFieldEnum)[keyof typeof LeagueScalarFieldEnum]


  export const LeagueStandingScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    teamId: 'teamId',
    teamName: 'teamName',
    wins: 'wins',
    losses: 'losses',
    ties: 'ties',
    pointsFor: 'pointsFor',
    pointsAgainst: 'pointsAgainst',
    pointDifferential: 'pointDifferential',
    streak: 'streak',
    rank: 'rank',
    updatedAt: 'updatedAt'
  };

  export type LeagueStandingScalarFieldEnum = (typeof LeagueStandingScalarFieldEnum)[keyof typeof LeagueStandingScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    homeScore: 'homeScore',
    awayScore: 'awayScore',
    gameDate: 'gameDate',
    simulated: 'simulated',
    simulationLog: 'simulationLog',
    matchType: 'matchType',
    tournamentId: 'tournamentId',
    round: 'round',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    seasonNumber: 'seasonNumber',
    startDate: 'startDate',
    endDate: 'endDate',
    currentDay: 'currentDay',
    phase: 'phase',
    createdAt: 'createdAt'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    linkTo: 'linkTo',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const TryoutPackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    creditCost: 'creditCost',
    gemCost: 'gemCost',
    numPlayers: 'numPlayers',
    qualityTier: 'qualityTier'
  };

  export type TryoutPackScalarFieldEnum = (typeof TryoutPackScalarFieldEnum)[keyof typeof TryoutPackScalarFieldEnum]


  export const TryoutHistoryScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    seasonId: 'seasonId',
    tryoutType: 'tryoutType',
    cost: 'cost',
    playersAdded: 'playersAdded',
    conductedAt: 'conductedAt',
    playerId: 'playerId'
  };

  export type TryoutHistoryScalarFieldEnum = (typeof TryoutHistoryScalarFieldEnum)[keyof typeof TryoutHistoryScalarFieldEnum]


  export const GemPackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gemAmount: 'gemAmount',
    usdPrice: 'usdPrice',
    productId: 'productId'
  };

  export type GemPackScalarFieldEnum = (typeof GemPackScalarFieldEnum)[keyof typeof GemPackScalarFieldEnum]


  export const CreditExchangeRateScalarFieldEnum: {
    id: 'id',
    gems: 'gems',
    credits: 'credits',
    bonusPercentage: 'bonusPercentage'
  };

  export type CreditExchangeRateScalarFieldEnum = (typeof CreditExchangeRateScalarFieldEnum)[keyof typeof CreditExchangeRateScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerUserId: 'referrerUserId',
    referredUserId: 'referredUserId',
    rewardGiven: 'rewardGiven',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const RedeemCodeScalarFieldEnum: {
    id: 'id',
    description: 'description',
    rewardType: 'rewardType',
    rewardValue: 'rewardValue',
    maxUses: 'maxUses',
    currentUses: 'currentUses',
    isActive: 'isActive',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt'
  };

  export type RedeemCodeScalarFieldEnum = (typeof RedeemCodeScalarFieldEnum)[keyof typeof RedeemCodeScalarFieldEnum]


  export const RedeemCodeRecordScalarFieldEnum: {
    id: 'id',
    redeemCodeId: 'redeemCodeId',
    userProfileId: 'userProfileId',
    redeemedAt: 'redeemedAt'
  };

  export type RedeemCodeRecordScalarFieldEnum = (typeof RedeemCodeRecordScalarFieldEnum)[keyof typeof RedeemCodeRecordScalarFieldEnum]


  export const AdRewardMilestoneScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    totalAdsWatched: 'totalAdsWatched',
    adsWatchedToday: 'adsWatchedToday',
    lastAdWatchedAt: 'lastAdWatchedAt'
  };

  export type AdRewardMilestoneScalarFieldEnum = (typeof AdRewardMilestoneScalarFieldEnum)[keyof typeof AdRewardMilestoneScalarFieldEnum]


  export const PremiumBoxRewardScalarFieldEnum: {
    id: 'id',
    category: 'category',
    rewardType: 'rewardType',
    rewardValue: 'rewardValue',
    weight: 'weight'
  };

  export type PremiumBoxRewardScalarFieldEnum = (typeof PremiumBoxRewardScalarFieldEnum)[keyof typeof PremiumBoxRewardScalarFieldEnum]


  export const EquipmentRewardScalarFieldEnum: {
    id: 'id',
    boxId: 'boxId',
    itemId: 'itemId',
    rarity: 'rarity',
    weight: 'weight'
  };

  export type EquipmentRewardScalarFieldEnum = (typeof EquipmentRewardScalarFieldEnum)[keyof typeof EquipmentRewardScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tournamentId: 'tournamentId',
    type: 'type',
    division: 'division',
    status: 'status',
    startTime: 'startTime',
    registrationEndTime: 'registrationEndTime',
    endTime: 'endTime',
    entryFeeCredits: 'entryFeeCredits',
    entryFeeGems: 'entryFeeGems',
    entryFeeItemId: 'entryFeeItemId',
    prizePoolJson: 'prizePoolJson',
    seasonDay: 'seasonDay',
    createdAt: 'createdAt'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamentEntryScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    teamId: 'teamId',
    registeredAt: 'registeredAt',
    finalRank: 'finalRank',
    rewardsClaimed: 'rewardsClaimed'
  };

  export type TournamentEntryScalarFieldEnum = (typeof TournamentEntryScalarFieldEnum)[keyof typeof TournamentEntryScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamId: 'teamId',
    transactionType: 'transactionType',
    itemName: 'itemName',
    itemType: 'itemType',
    creditsAmount: 'creditsAmount',
    gemsAmount: 'gemsAmount',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FieldSize'
   */
  export type EnumFieldSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldSize'>
    


  /**
   * Reference to a field of type 'FieldSize[]'
   */
  export type ListEnumFieldSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldSize[]'>
    


  /**
   * Reference to a field of type 'TacticalFocus'
   */
  export type EnumTacticalFocusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TacticalFocus'>
    


  /**
   * Reference to a field of type 'TacticalFocus[]'
   */
  export type ListEnumTacticalFocusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TacticalFocus[]'>
    


  /**
   * Reference to a field of type 'Race'
   */
  export type EnumRaceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Race'>
    


  /**
   * Reference to a field of type 'Race[]'
   */
  export type ListEnumRaceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Race[]'>
    


  /**
   * Reference to a field of type 'PlayerRole'
   */
  export type EnumPlayerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerRole'>
    


  /**
   * Reference to a field of type 'PlayerRole[]'
   */
  export type ListEnumPlayerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerRole[]'>
    


  /**
   * Reference to a field of type 'InjuryStatus'
   */
  export type EnumInjuryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryStatus'>
    


  /**
   * Reference to a field of type 'InjuryStatus[]'
   */
  export type ListEnumInjuryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryStatus[]'>
    


  /**
   * Reference to a field of type 'SkillType'
   */
  export type EnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType'>
    


  /**
   * Reference to a field of type 'SkillType[]'
   */
  export type ListEnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType[]'>
    


  /**
   * Reference to a field of type 'SkillCategory'
   */
  export type EnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory'>
    


  /**
   * Reference to a field of type 'SkillCategory[]'
   */
  export type ListEnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory[]'>
    


  /**
   * Reference to a field of type 'StaffType'
   */
  export type EnumStaffTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffType'>
    


  /**
   * Reference to a field of type 'StaffType[]'
   */
  export type ListEnumStaffTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'EquipmentSlot'
   */
  export type EnumEquipmentSlotFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentSlot'>
    


  /**
   * Reference to a field of type 'EquipmentSlot[]'
   */
  export type ListEnumEquipmentSlotFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentSlot[]'>
    


  /**
   * Reference to a field of type 'ItemRarity'
   */
  export type EnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity'>
    


  /**
   * Reference to a field of type 'ItemRarity[]'
   */
  export type ListEnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity[]'>
    


  /**
   * Reference to a field of type 'MatchType'
   */
  export type EnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType'>
    


  /**
   * Reference to a field of type 'MatchType[]'
   */
  export type ListEnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType[]'>
    


  /**
   * Reference to a field of type 'MarketplaceStatus'
   */
  export type EnumMarketplaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceStatus'>
    


  /**
   * Reference to a field of type 'MarketplaceStatus[]'
   */
  export type ListEnumMarketplaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceStatus[]'>
    


  /**
   * Reference to a field of type 'ListingActionType'
   */
  export type EnumListingActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingActionType'>
    


  /**
   * Reference to a field of type 'ListingActionType[]'
   */
  export type ListEnumListingActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingActionType[]'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'SeasonPhase'
   */
  export type EnumSeasonPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeasonPhase'>
    


  /**
   * Reference to a field of type 'SeasonPhase[]'
   */
  export type ListEnumSeasonPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeasonPhase[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'RewardType'
   */
  export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType'>
    


  /**
   * Reference to a field of type 'RewardType[]'
   */
  export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType[]'>
    


  /**
   * Reference to a field of type 'TournamentType'
   */
  export type EnumTournamentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentType'>
    


  /**
   * Reference to a field of type 'TournamentType[]'
   */
  export type ListEnumTournamentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentType[]'>
    


  /**
   * Reference to a field of type 'TournamentStatus'
   */
  export type EnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus'>
    


  /**
   * Reference to a field of type 'TournamentStatus[]'
   */
  export type ListEnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: IntFilter<"UserProfile"> | number
    userId?: StringFilter<"UserProfile"> | string
    email?: StringNullableFilter<"UserProfile"> | string | null
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    referralCode?: StringNullableFilter<"UserProfile"> | string | null
    referredBy?: StringNullableFilter<"UserProfile"> | string | null
    ndaAccepted?: BoolFilter<"UserProfile"> | boolean
    ndaAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    ndaVersion?: StringNullableFilter<"UserProfile"> | string | null
    Team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    redeemedCodes?: RedeemCodeRecordListRelationFilter
    adRewardMilestone?: XOR<AdRewardMilestoneNullableScalarRelationFilter, AdRewardMilestoneWhereInput> | null
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    ndaAccepted?: SortOrder
    ndaAcceptedAt?: SortOrderInput | SortOrder
    ndaVersion?: SortOrderInput | SortOrder
    Team?: TeamOrderByWithRelationInput
    redeemedCodes?: RedeemCodeRecordOrderByRelationAggregateInput
    adRewardMilestone?: AdRewardMilestoneOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    email?: string
    referralCode?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    referredBy?: StringNullableFilter<"UserProfile"> | string | null
    ndaAccepted?: BoolFilter<"UserProfile"> | boolean
    ndaAcceptedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    ndaVersion?: StringNullableFilter<"UserProfile"> | string | null
    Team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    redeemedCodes?: RedeemCodeRecordListRelationFilter
    adRewardMilestone?: XOR<AdRewardMilestoneNullableScalarRelationFilter, AdRewardMilestoneWhereInput> | null
  }, "id" | "userId" | "email" | "referralCode">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    ndaAccepted?: SortOrder
    ndaAcceptedAt?: SortOrderInput | SortOrder
    ndaVersion?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserProfile"> | number
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    email?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    referralCode?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    referredBy?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    ndaAccepted?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    ndaAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    ndaVersion?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sid?: StringFilter<"Session"> | string
    sess?: JsonFilter<"Session">
    expire?: DateTimeFilter<"Session"> | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sid?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sess?: JsonFilter<"Session">
    expire?: DateTimeFilter<"Session"> | Date | string
  }, "sid" | "sid">

  export type SessionOrderByWithAggregationInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sid?: StringWithAggregatesFilter<"Session"> | string
    sess?: JsonWithAggregatesFilter<"Session">
    expire?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    userProfileId?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    isAI?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    camaraderie?: FloatFilter<"Team"> | number
    fanLoyalty?: FloatFilter<"Team"> | number
    homeField?: EnumFieldSizeFilter<"Team"> | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFilter<"Team"> | $Enums.TacticalFocus
    leagueId?: IntNullableFilter<"Team"> | number | null
    division?: IntNullableFilter<"Team"> | number | null
    subdivision?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    points?: IntFilter<"Team"> | number
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    players?: PlayerListRelationFilter
    staff?: StaffListRelationFilter
    finances?: XOR<TeamFinancesNullableScalarRelationFilter, TeamFinancesWhereInput> | null
    stadium?: XOR<StadiumNullableScalarRelationFilter, StadiumWhereInput> | null
    inventoryItems?: InventoryItemListRelationFilter
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    activeBoosts?: ActiveBoostListRelationFilter
    strategy?: XOR<StrategyNullableScalarRelationFilter, StrategyWhereInput> | null
    marketplaceListings?: MarketplaceListingListRelationFilter
    bids?: BidListRelationFilter
    highBidderOnListings?: MarketplaceListingListRelationFilter
    listingHistory?: ListingHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    tournamentEntries?: TournamentEntryListRelationFilter
    tryoutHistory?: TryoutHistoryListRelationFilter
    homeTeamGames?: GameListRelationFilter
    awayTeamGames?: GameListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isAI?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    homeField?: SortOrder
    tacticalFocus?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    subdivision?: SortOrderInput | SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    players?: PlayerOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
    finances?: TeamFinancesOrderByWithRelationInput
    stadium?: StadiumOrderByWithRelationInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    league?: LeagueOrderByWithRelationInput
    activeBoosts?: ActiveBoostOrderByRelationAggregateInput
    strategy?: StrategyOrderByWithRelationInput
    marketplaceListings?: MarketplaceListingOrderByRelationAggregateInput
    bids?: BidOrderByRelationAggregateInput
    highBidderOnListings?: MarketplaceListingOrderByRelationAggregateInput
    listingHistory?: ListingHistoryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    tournamentEntries?: TournamentEntryOrderByRelationAggregateInput
    tryoutHistory?: TryoutHistoryOrderByRelationAggregateInput
    homeTeamGames?: GameOrderByRelationAggregateInput
    awayTeamGames?: GameOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userProfileId?: number
    name?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    logoUrl?: StringNullableFilter<"Team"> | string | null
    isAI?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    camaraderie?: FloatFilter<"Team"> | number
    fanLoyalty?: FloatFilter<"Team"> | number
    homeField?: EnumFieldSizeFilter<"Team"> | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFilter<"Team"> | $Enums.TacticalFocus
    leagueId?: IntNullableFilter<"Team"> | number | null
    division?: IntNullableFilter<"Team"> | number | null
    subdivision?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    points?: IntFilter<"Team"> | number
    user?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    players?: PlayerListRelationFilter
    staff?: StaffListRelationFilter
    finances?: XOR<TeamFinancesNullableScalarRelationFilter, TeamFinancesWhereInput> | null
    stadium?: XOR<StadiumNullableScalarRelationFilter, StadiumWhereInput> | null
    inventoryItems?: InventoryItemListRelationFilter
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    activeBoosts?: ActiveBoostListRelationFilter
    strategy?: XOR<StrategyNullableScalarRelationFilter, StrategyWhereInput> | null
    marketplaceListings?: MarketplaceListingListRelationFilter
    bids?: BidListRelationFilter
    highBidderOnListings?: MarketplaceListingListRelationFilter
    listingHistory?: ListingHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    tournamentEntries?: TournamentEntryListRelationFilter
    tryoutHistory?: TryoutHistoryListRelationFilter
    homeTeamGames?: GameListRelationFilter
    awayTeamGames?: GameListRelationFilter
  }, "id" | "userProfileId" | "name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isAI?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    homeField?: SortOrder
    tacticalFocus?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    division?: SortOrderInput | SortOrder
    subdivision?: SortOrderInput | SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    userProfileId?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    isAI?: BoolWithAggregatesFilter<"Team"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    camaraderie?: FloatWithAggregatesFilter<"Team"> | number
    fanLoyalty?: FloatWithAggregatesFilter<"Team"> | number
    homeField?: EnumFieldSizeWithAggregatesFilter<"Team"> | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusWithAggregatesFilter<"Team"> | $Enums.TacticalFocus
    leagueId?: IntNullableWithAggregatesFilter<"Team"> | number | null
    division?: IntNullableWithAggregatesFilter<"Team"> | number | null
    subdivision?: StringNullableWithAggregatesFilter<"Team"> | string | null
    wins?: IntWithAggregatesFilter<"Team"> | number
    losses?: IntWithAggregatesFilter<"Team"> | number
    points?: IntWithAggregatesFilter<"Team"> | number
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: IntFilter<"Player"> | number
    teamId?: IntFilter<"Player"> | number
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    race?: EnumRaceFilter<"Player"> | $Enums.Race
    age?: IntFilter<"Player"> | number
    role?: EnumPlayerRoleFilter<"Player"> | $Enums.PlayerRole
    speed?: IntFilter<"Player"> | number
    power?: IntFilter<"Player"> | number
    throwing?: IntFilter<"Player"> | number
    catching?: IntFilter<"Player"> | number
    kicking?: IntFilter<"Player"> | number
    staminaAttribute?: IntFilter<"Player"> | number
    leadership?: IntFilter<"Player"> | number
    agility?: IntFilter<"Player"> | number
    potentialRating?: FloatFilter<"Player"> | number
    dailyStaminaLevel?: IntFilter<"Player"> | number
    injuryStatus?: EnumInjuryStatusFilter<"Player"> | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFilter<"Player"> | number
    injuryRecoveryPointsCurrent?: IntFilter<"Player"> | number
    dailyItemsUsed?: IntFilter<"Player"> | number
    careerInjuries?: IntFilter<"Player"> | number
    gamesPlayedLastSeason?: IntFilter<"Player"> | number
    seasonMinutesLeague?: FloatFilter<"Player"> | number
    seasonMinutesTournament?: FloatFilter<"Player"> | number
    seasonMinutesExhibition?: FloatFilter<"Player"> | number
    seasonMinutesTotal?: FloatFilter<"Player"> | number
    isOnMarket?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    camaraderieScore?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    skills?: PlayerSkillLinkListRelationFilter
    MarketplaceListing?: XOR<MarketplaceListingNullableScalarRelationFilter, MarketplaceListingWhereInput> | null
    marketValue?: XOR<PlayerMarketValueNullableScalarRelationFilter, PlayerMarketValueWhereInput> | null
    tryoutHistory?: TryoutHistoryListRelationFilter
    activeBoosts?: ActiveBoostListRelationFilter
    currentEquipment?: PlayerEquipmentListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    race?: SortOrder
    age?: SortOrder
    role?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryStatus?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    isOnMarket?: SortOrder
    isRetired?: SortOrder
    camaraderieScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
    skills?: PlayerSkillLinkOrderByRelationAggregateInput
    MarketplaceListing?: MarketplaceListingOrderByWithRelationInput
    marketValue?: PlayerMarketValueOrderByWithRelationInput
    tryoutHistory?: TryoutHistoryOrderByRelationAggregateInput
    activeBoosts?: ActiveBoostOrderByRelationAggregateInput
    currentEquipment?: PlayerEquipmentOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    teamId?: IntFilter<"Player"> | number
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    race?: EnumRaceFilter<"Player"> | $Enums.Race
    age?: IntFilter<"Player"> | number
    role?: EnumPlayerRoleFilter<"Player"> | $Enums.PlayerRole
    speed?: IntFilter<"Player"> | number
    power?: IntFilter<"Player"> | number
    throwing?: IntFilter<"Player"> | number
    catching?: IntFilter<"Player"> | number
    kicking?: IntFilter<"Player"> | number
    staminaAttribute?: IntFilter<"Player"> | number
    leadership?: IntFilter<"Player"> | number
    agility?: IntFilter<"Player"> | number
    potentialRating?: FloatFilter<"Player"> | number
    dailyStaminaLevel?: IntFilter<"Player"> | number
    injuryStatus?: EnumInjuryStatusFilter<"Player"> | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFilter<"Player"> | number
    injuryRecoveryPointsCurrent?: IntFilter<"Player"> | number
    dailyItemsUsed?: IntFilter<"Player"> | number
    careerInjuries?: IntFilter<"Player"> | number
    gamesPlayedLastSeason?: IntFilter<"Player"> | number
    seasonMinutesLeague?: FloatFilter<"Player"> | number
    seasonMinutesTournament?: FloatFilter<"Player"> | number
    seasonMinutesExhibition?: FloatFilter<"Player"> | number
    seasonMinutesTotal?: FloatFilter<"Player"> | number
    isOnMarket?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    camaraderieScore?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    skills?: PlayerSkillLinkListRelationFilter
    MarketplaceListing?: XOR<MarketplaceListingNullableScalarRelationFilter, MarketplaceListingWhereInput> | null
    marketValue?: XOR<PlayerMarketValueNullableScalarRelationFilter, PlayerMarketValueWhereInput> | null
    tryoutHistory?: TryoutHistoryListRelationFilter
    activeBoosts?: ActiveBoostListRelationFilter
    currentEquipment?: PlayerEquipmentListRelationFilter
  }, "id">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    race?: SortOrder
    age?: SortOrder
    role?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryStatus?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    isOnMarket?: SortOrder
    isRetired?: SortOrder
    camaraderieScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Player"> | number
    teamId?: IntWithAggregatesFilter<"Player"> | number
    firstName?: StringWithAggregatesFilter<"Player"> | string
    lastName?: StringWithAggregatesFilter<"Player"> | string
    race?: EnumRaceWithAggregatesFilter<"Player"> | $Enums.Race
    age?: IntWithAggregatesFilter<"Player"> | number
    role?: EnumPlayerRoleWithAggregatesFilter<"Player"> | $Enums.PlayerRole
    speed?: IntWithAggregatesFilter<"Player"> | number
    power?: IntWithAggregatesFilter<"Player"> | number
    throwing?: IntWithAggregatesFilter<"Player"> | number
    catching?: IntWithAggregatesFilter<"Player"> | number
    kicking?: IntWithAggregatesFilter<"Player"> | number
    staminaAttribute?: IntWithAggregatesFilter<"Player"> | number
    leadership?: IntWithAggregatesFilter<"Player"> | number
    agility?: IntWithAggregatesFilter<"Player"> | number
    potentialRating?: FloatWithAggregatesFilter<"Player"> | number
    dailyStaminaLevel?: IntWithAggregatesFilter<"Player"> | number
    injuryStatus?: EnumInjuryStatusWithAggregatesFilter<"Player"> | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntWithAggregatesFilter<"Player"> | number
    injuryRecoveryPointsCurrent?: IntWithAggregatesFilter<"Player"> | number
    dailyItemsUsed?: IntWithAggregatesFilter<"Player"> | number
    careerInjuries?: IntWithAggregatesFilter<"Player"> | number
    gamesPlayedLastSeason?: IntWithAggregatesFilter<"Player"> | number
    seasonMinutesLeague?: FloatWithAggregatesFilter<"Player"> | number
    seasonMinutesTournament?: FloatWithAggregatesFilter<"Player"> | number
    seasonMinutesExhibition?: FloatWithAggregatesFilter<"Player"> | number
    seasonMinutesTotal?: FloatWithAggregatesFilter<"Player"> | number
    isOnMarket?: BoolWithAggregatesFilter<"Player"> | boolean
    isRetired?: BoolWithAggregatesFilter<"Player"> | boolean
    camaraderieScore?: FloatWithAggregatesFilter<"Player"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type PlayerEquipmentWhereInput = {
    AND?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    OR?: PlayerEquipmentWhereInput[]
    NOT?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    id?: IntFilter<"PlayerEquipment"> | number
    playerId?: IntFilter<"PlayerEquipment"> | number
    itemId?: IntFilter<"PlayerEquipment"> | number
    equippedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type PlayerEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    equippedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PlayerEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId_itemId?: PlayerEquipmentPlayerIdItemIdCompoundUniqueInput
    AND?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    OR?: PlayerEquipmentWhereInput[]
    NOT?: PlayerEquipmentWhereInput | PlayerEquipmentWhereInput[]
    playerId?: IntFilter<"PlayerEquipment"> | number
    itemId?: IntFilter<"PlayerEquipment"> | number
    equippedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id" | "playerId_itemId">

  export type PlayerEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    equippedAt?: SortOrder
    _count?: PlayerEquipmentCountOrderByAggregateInput
    _avg?: PlayerEquipmentAvgOrderByAggregateInput
    _max?: PlayerEquipmentMaxOrderByAggregateInput
    _min?: PlayerEquipmentMinOrderByAggregateInput
    _sum?: PlayerEquipmentSumOrderByAggregateInput
  }

  export type PlayerEquipmentScalarWhereWithAggregatesInput = {
    AND?: PlayerEquipmentScalarWhereWithAggregatesInput | PlayerEquipmentScalarWhereWithAggregatesInput[]
    OR?: PlayerEquipmentScalarWhereWithAggregatesInput[]
    NOT?: PlayerEquipmentScalarWhereWithAggregatesInput | PlayerEquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerEquipment"> | number
    playerId?: IntWithAggregatesFilter<"PlayerEquipment"> | number
    itemId?: IntWithAggregatesFilter<"PlayerEquipment"> | number
    equippedAt?: DateTimeWithAggregatesFilter<"PlayerEquipment"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    playerId?: IntNullableFilter<"Contract"> | number | null
    staffId?: IntNullableFilter<"Contract"> | number | null
    salary?: IntFilter<"Contract"> | number
    length?: IntFilter<"Contract"> | number
    signingBonus?: IntFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
    startDate?: SortOrder
    player?: PlayerOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId?: number
    staffId?: number
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    salary?: IntFilter<"Contract"> | number
    length?: IntFilter<"Contract"> | number
    signingBonus?: IntFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
  }, "id" | "playerId" | "staffId">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
    startDate?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    playerId?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    staffId?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    salary?: IntWithAggregatesFilter<"Contract"> | number
    length?: IntWithAggregatesFilter<"Contract"> | number
    signingBonus?: IntWithAggregatesFilter<"Contract"> | number
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    description?: StringFilter<"Skill"> | string
    type?: EnumSkillTypeFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    tiers?: JsonFilter<"Skill">
    playerLinks?: PlayerSkillLinkListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tiers?: SortOrder
    playerLinks?: PlayerSkillLinkOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    description?: StringFilter<"Skill"> | string
    type?: EnumSkillTypeFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    tiers?: JsonFilter<"Skill">
    playerLinks?: PlayerSkillLinkListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tiers?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    name?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringWithAggregatesFilter<"Skill"> | string
    type?: EnumSkillTypeWithAggregatesFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryWithAggregatesFilter<"Skill"> | $Enums.SkillCategory
    tiers?: JsonWithAggregatesFilter<"Skill">
  }

  export type PlayerSkillLinkWhereInput = {
    AND?: PlayerSkillLinkWhereInput | PlayerSkillLinkWhereInput[]
    OR?: PlayerSkillLinkWhereInput[]
    NOT?: PlayerSkillLinkWhereInput | PlayerSkillLinkWhereInput[]
    id?: IntFilter<"PlayerSkillLink"> | number
    playerId?: IntFilter<"PlayerSkillLink"> | number
    skillId?: IntFilter<"PlayerSkillLink"> | number
    currentTier?: IntFilter<"PlayerSkillLink"> | number
    acquiredAt?: DateTimeFilter<"PlayerSkillLink"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type PlayerSkillLinkOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
    acquiredAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type PlayerSkillLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId_skillId?: PlayerSkillLinkPlayerIdSkillIdCompoundUniqueInput
    AND?: PlayerSkillLinkWhereInput | PlayerSkillLinkWhereInput[]
    OR?: PlayerSkillLinkWhereInput[]
    NOT?: PlayerSkillLinkWhereInput | PlayerSkillLinkWhereInput[]
    playerId?: IntFilter<"PlayerSkillLink"> | number
    skillId?: IntFilter<"PlayerSkillLink"> | number
    currentTier?: IntFilter<"PlayerSkillLink"> | number
    acquiredAt?: DateTimeFilter<"PlayerSkillLink"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "playerId_skillId">

  export type PlayerSkillLinkOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
    acquiredAt?: SortOrder
    _count?: PlayerSkillLinkCountOrderByAggregateInput
    _avg?: PlayerSkillLinkAvgOrderByAggregateInput
    _max?: PlayerSkillLinkMaxOrderByAggregateInput
    _min?: PlayerSkillLinkMinOrderByAggregateInput
    _sum?: PlayerSkillLinkSumOrderByAggregateInput
  }

  export type PlayerSkillLinkScalarWhereWithAggregatesInput = {
    AND?: PlayerSkillLinkScalarWhereWithAggregatesInput | PlayerSkillLinkScalarWhereWithAggregatesInput[]
    OR?: PlayerSkillLinkScalarWhereWithAggregatesInput[]
    NOT?: PlayerSkillLinkScalarWhereWithAggregatesInput | PlayerSkillLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerSkillLink"> | number
    playerId?: IntWithAggregatesFilter<"PlayerSkillLink"> | number
    skillId?: IntWithAggregatesFilter<"PlayerSkillLink"> | number
    currentTier?: IntWithAggregatesFilter<"PlayerSkillLink"> | number
    acquiredAt?: DateTimeWithAggregatesFilter<"PlayerSkillLink"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: IntFilter<"Staff"> | number
    teamId?: IntFilter<"Staff"> | number
    type?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType
    name?: StringFilter<"Staff"> | string
    level?: IntFilter<"Staff"> | number
    motivation?: IntFilter<"Staff"> | number
    development?: IntFilter<"Staff"> | number
    teaching?: IntFilter<"Staff"> | number
    physiology?: IntFilter<"Staff"> | number
    talentIdentification?: IntFilter<"Staff"> | number
    potentialAssessment?: IntFilter<"Staff"> | number
    tactics?: IntFilter<"Staff"> | number
    age?: IntFilter<"Staff"> | number
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    teamId?: IntFilter<"Staff"> | number
    type?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType
    name?: StringFilter<"Staff"> | string
    level?: IntFilter<"Staff"> | number
    motivation?: IntFilter<"Staff"> | number
    development?: IntFilter<"Staff"> | number
    teaching?: IntFilter<"Staff"> | number
    physiology?: IntFilter<"Staff"> | number
    talentIdentification?: IntFilter<"Staff"> | number
    potentialAssessment?: IntFilter<"Staff"> | number
    tactics?: IntFilter<"Staff"> | number
    age?: IntFilter<"Staff"> | number
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
  }, "id">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _avg?: StaffAvgOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
    _sum?: StaffSumOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Staff"> | number
    teamId?: IntWithAggregatesFilter<"Staff"> | number
    type?: EnumStaffTypeWithAggregatesFilter<"Staff"> | $Enums.StaffType
    name?: StringWithAggregatesFilter<"Staff"> | string
    level?: IntWithAggregatesFilter<"Staff"> | number
    motivation?: IntWithAggregatesFilter<"Staff"> | number
    development?: IntWithAggregatesFilter<"Staff"> | number
    teaching?: IntWithAggregatesFilter<"Staff"> | number
    physiology?: IntWithAggregatesFilter<"Staff"> | number
    talentIdentification?: IntWithAggregatesFilter<"Staff"> | number
    potentialAssessment?: IntWithAggregatesFilter<"Staff"> | number
    tactics?: IntWithAggregatesFilter<"Staff"> | number
    age?: IntWithAggregatesFilter<"Staff"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type TeamFinancesWhereInput = {
    AND?: TeamFinancesWhereInput | TeamFinancesWhereInput[]
    OR?: TeamFinancesWhereInput[]
    NOT?: TeamFinancesWhereInput | TeamFinancesWhereInput[]
    id?: IntFilter<"TeamFinances"> | number
    teamId?: IntFilter<"TeamFinances"> | number
    credits?: BigIntFilter<"TeamFinances"> | bigint | number
    gems?: IntFilter<"TeamFinances"> | number
    escrowCredits?: BigIntFilter<"TeamFinances"> | bigint | number
    escrowGems?: IntFilter<"TeamFinances"> | number
    projectedIncome?: BigIntFilter<"TeamFinances"> | bigint | number
    projectedExpenses?: BigIntFilter<"TeamFinances"> | bigint | number
    lastSeasonRevenue?: BigIntFilter<"TeamFinances"> | bigint | number
    lastSeasonExpenses?: BigIntFilter<"TeamFinances"> | bigint | number
    facilitiesMaintenanceCost?: BigIntFilter<"TeamFinances"> | bigint | number
    createdAt?: DateTimeFilter<"TeamFinances"> | Date | string
    updatedAt?: DateTimeFilter<"TeamFinances"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TeamFinancesOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type TeamFinancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId?: number
    AND?: TeamFinancesWhereInput | TeamFinancesWhereInput[]
    OR?: TeamFinancesWhereInput[]
    NOT?: TeamFinancesWhereInput | TeamFinancesWhereInput[]
    credits?: BigIntFilter<"TeamFinances"> | bigint | number
    gems?: IntFilter<"TeamFinances"> | number
    escrowCredits?: BigIntFilter<"TeamFinances"> | bigint | number
    escrowGems?: IntFilter<"TeamFinances"> | number
    projectedIncome?: BigIntFilter<"TeamFinances"> | bigint | number
    projectedExpenses?: BigIntFilter<"TeamFinances"> | bigint | number
    lastSeasonRevenue?: BigIntFilter<"TeamFinances"> | bigint | number
    lastSeasonExpenses?: BigIntFilter<"TeamFinances"> | bigint | number
    facilitiesMaintenanceCost?: BigIntFilter<"TeamFinances"> | bigint | number
    createdAt?: DateTimeFilter<"TeamFinances"> | Date | string
    updatedAt?: DateTimeFilter<"TeamFinances"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamId">

  export type TeamFinancesOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamFinancesCountOrderByAggregateInput
    _avg?: TeamFinancesAvgOrderByAggregateInput
    _max?: TeamFinancesMaxOrderByAggregateInput
    _min?: TeamFinancesMinOrderByAggregateInput
    _sum?: TeamFinancesSumOrderByAggregateInput
  }

  export type TeamFinancesScalarWhereWithAggregatesInput = {
    AND?: TeamFinancesScalarWhereWithAggregatesInput | TeamFinancesScalarWhereWithAggregatesInput[]
    OR?: TeamFinancesScalarWhereWithAggregatesInput[]
    NOT?: TeamFinancesScalarWhereWithAggregatesInput | TeamFinancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamFinances"> | number
    teamId?: IntWithAggregatesFilter<"TeamFinances"> | number
    credits?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    gems?: IntWithAggregatesFilter<"TeamFinances"> | number
    escrowCredits?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    escrowGems?: IntWithAggregatesFilter<"TeamFinances"> | number
    projectedIncome?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    projectedExpenses?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    lastSeasonRevenue?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    lastSeasonExpenses?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    facilitiesMaintenanceCost?: BigIntWithAggregatesFilter<"TeamFinances"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"TeamFinances"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamFinances"> | Date | string
  }

  export type StadiumWhereInput = {
    AND?: StadiumWhereInput | StadiumWhereInput[]
    OR?: StadiumWhereInput[]
    NOT?: StadiumWhereInput | StadiumWhereInput[]
    id?: IntFilter<"Stadium"> | number
    teamId?: IntFilter<"Stadium"> | number
    capacity?: IntFilter<"Stadium"> | number
    concessionsLevel?: IntFilter<"Stadium"> | number
    parkingLevel?: IntFilter<"Stadium"> | number
    vipSuitesLevel?: IntFilter<"Stadium"> | number
    merchandisingLevel?: IntFilter<"Stadium"> | number
    lightingScreensLevel?: IntFilter<"Stadium"> | number
    createdAt?: DateTimeFilter<"Stadium"> | Date | string
    updatedAt?: DateTimeFilter<"Stadium"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type StadiumOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type StadiumWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId?: number
    AND?: StadiumWhereInput | StadiumWhereInput[]
    OR?: StadiumWhereInput[]
    NOT?: StadiumWhereInput | StadiumWhereInput[]
    capacity?: IntFilter<"Stadium"> | number
    concessionsLevel?: IntFilter<"Stadium"> | number
    parkingLevel?: IntFilter<"Stadium"> | number
    vipSuitesLevel?: IntFilter<"Stadium"> | number
    merchandisingLevel?: IntFilter<"Stadium"> | number
    lightingScreensLevel?: IntFilter<"Stadium"> | number
    createdAt?: DateTimeFilter<"Stadium"> | Date | string
    updatedAt?: DateTimeFilter<"Stadium"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamId">

  export type StadiumOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StadiumCountOrderByAggregateInput
    _avg?: StadiumAvgOrderByAggregateInput
    _max?: StadiumMaxOrderByAggregateInput
    _min?: StadiumMinOrderByAggregateInput
    _sum?: StadiumSumOrderByAggregateInput
  }

  export type StadiumScalarWhereWithAggregatesInput = {
    AND?: StadiumScalarWhereWithAggregatesInput | StadiumScalarWhereWithAggregatesInput[]
    OR?: StadiumScalarWhereWithAggregatesInput[]
    NOT?: StadiumScalarWhereWithAggregatesInput | StadiumScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stadium"> | number
    teamId?: IntWithAggregatesFilter<"Stadium"> | number
    capacity?: IntWithAggregatesFilter<"Stadium"> | number
    concessionsLevel?: IntWithAggregatesFilter<"Stadium"> | number
    parkingLevel?: IntWithAggregatesFilter<"Stadium"> | number
    vipSuitesLevel?: IntWithAggregatesFilter<"Stadium"> | number
    merchandisingLevel?: IntWithAggregatesFilter<"Stadium"> | number
    lightingScreensLevel?: IntWithAggregatesFilter<"Stadium"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Stadium"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stadium"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    slot?: EnumEquipmentSlotNullableFilter<"Item"> | $Enums.EquipmentSlot | null
    raceRestriction?: EnumRaceNullableFilter<"Item"> | $Enums.Race | null
    statEffects?: JsonNullableFilter<"Item">
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    creditPrice?: BigIntNullableFilter<"Item"> | bigint | number | null
    gemPrice?: IntNullableFilter<"Item"> | number | null
    effectValue?: JsonNullableFilter<"Item">
    inventoryItems?: InventoryItemListRelationFilter
    activeBoosts?: ActiveBoostListRelationFilter
    PlayerEquipment?: PlayerEquipmentListRelationFilter
    PremiumBoxRewards?: EquipmentRewardListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    slot?: SortOrderInput | SortOrder
    raceRestriction?: SortOrderInput | SortOrder
    statEffects?: SortOrderInput | SortOrder
    rarity?: SortOrder
    creditPrice?: SortOrderInput | SortOrder
    gemPrice?: SortOrderInput | SortOrder
    effectValue?: SortOrderInput | SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    activeBoosts?: ActiveBoostOrderByRelationAggregateInput
    PlayerEquipment?: PlayerEquipmentOrderByRelationAggregateInput
    PremiumBoxRewards?: EquipmentRewardOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    description?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    slot?: EnumEquipmentSlotNullableFilter<"Item"> | $Enums.EquipmentSlot | null
    raceRestriction?: EnumRaceNullableFilter<"Item"> | $Enums.Race | null
    statEffects?: JsonNullableFilter<"Item">
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    creditPrice?: BigIntNullableFilter<"Item"> | bigint | number | null
    gemPrice?: IntNullableFilter<"Item"> | number | null
    effectValue?: JsonNullableFilter<"Item">
    inventoryItems?: InventoryItemListRelationFilter
    activeBoosts?: ActiveBoostListRelationFilter
    PlayerEquipment?: PlayerEquipmentListRelationFilter
    PremiumBoxRewards?: EquipmentRewardListRelationFilter
  }, "id" | "name">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    slot?: SortOrderInput | SortOrder
    raceRestriction?: SortOrderInput | SortOrder
    statEffects?: SortOrderInput | SortOrder
    rarity?: SortOrder
    creditPrice?: SortOrderInput | SortOrder
    gemPrice?: SortOrderInput | SortOrder
    effectValue?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringWithAggregatesFilter<"Item"> | string
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    slot?: EnumEquipmentSlotNullableWithAggregatesFilter<"Item"> | $Enums.EquipmentSlot | null
    raceRestriction?: EnumRaceNullableWithAggregatesFilter<"Item"> | $Enums.Race | null
    statEffects?: JsonNullableWithAggregatesFilter<"Item">
    rarity?: EnumItemRarityWithAggregatesFilter<"Item"> | $Enums.ItemRarity
    creditPrice?: BigIntNullableWithAggregatesFilter<"Item"> | bigint | number | null
    gemPrice?: IntNullableWithAggregatesFilter<"Item"> | number | null
    effectValue?: JsonNullableWithAggregatesFilter<"Item">
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    teamId?: IntFilter<"InventoryItem"> | number
    itemId?: IntFilter<"InventoryItem"> | number
    quantity?: IntFilter<"InventoryItem"> | number
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_itemId?: InventoryItemTeamIdItemIdCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    teamId?: IntFilter<"InventoryItem"> | number
    itemId?: IntFilter<"InventoryItem"> | number
    quantity?: IntFilter<"InventoryItem"> | number
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id" | "teamId_itemId">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryItem"> | number
    teamId?: IntWithAggregatesFilter<"InventoryItem"> | number
    itemId?: IntWithAggregatesFilter<"InventoryItem"> | number
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    acquiredAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type ActiveBoostWhereInput = {
    AND?: ActiveBoostWhereInput | ActiveBoostWhereInput[]
    OR?: ActiveBoostWhereInput[]
    NOT?: ActiveBoostWhereInput | ActiveBoostWhereInput[]
    id?: IntFilter<"ActiveBoost"> | number
    teamId?: IntFilter<"ActiveBoost"> | number
    playerId?: IntNullableFilter<"ActiveBoost"> | number | null
    itemId?: IntFilter<"ActiveBoost"> | number
    matchType?: EnumMatchTypeFilter<"ActiveBoost"> | $Enums.MatchType
    isActive?: BoolFilter<"ActiveBoost"> | boolean
    appliedAt?: DateTimeFilter<"ActiveBoost"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ActiveBoostOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    itemId?: SortOrder
    matchType?: SortOrder
    isActive?: SortOrder
    appliedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ActiveBoostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActiveBoostWhereInput | ActiveBoostWhereInput[]
    OR?: ActiveBoostWhereInput[]
    NOT?: ActiveBoostWhereInput | ActiveBoostWhereInput[]
    teamId?: IntFilter<"ActiveBoost"> | number
    playerId?: IntNullableFilter<"ActiveBoost"> | number | null
    itemId?: IntFilter<"ActiveBoost"> | number
    matchType?: EnumMatchTypeFilter<"ActiveBoost"> | $Enums.MatchType
    isActive?: BoolFilter<"ActiveBoost"> | boolean
    appliedAt?: DateTimeFilter<"ActiveBoost"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ActiveBoostOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    itemId?: SortOrder
    matchType?: SortOrder
    isActive?: SortOrder
    appliedAt?: SortOrder
    _count?: ActiveBoostCountOrderByAggregateInput
    _avg?: ActiveBoostAvgOrderByAggregateInput
    _max?: ActiveBoostMaxOrderByAggregateInput
    _min?: ActiveBoostMinOrderByAggregateInput
    _sum?: ActiveBoostSumOrderByAggregateInput
  }

  export type ActiveBoostScalarWhereWithAggregatesInput = {
    AND?: ActiveBoostScalarWhereWithAggregatesInput | ActiveBoostScalarWhereWithAggregatesInput[]
    OR?: ActiveBoostScalarWhereWithAggregatesInput[]
    NOT?: ActiveBoostScalarWhereWithAggregatesInput | ActiveBoostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActiveBoost"> | number
    teamId?: IntWithAggregatesFilter<"ActiveBoost"> | number
    playerId?: IntNullableWithAggregatesFilter<"ActiveBoost"> | number | null
    itemId?: IntWithAggregatesFilter<"ActiveBoost"> | number
    matchType?: EnumMatchTypeWithAggregatesFilter<"ActiveBoost"> | $Enums.MatchType
    isActive?: BoolWithAggregatesFilter<"ActiveBoost"> | boolean
    appliedAt?: DateTimeWithAggregatesFilter<"ActiveBoost"> | Date | string
  }

  export type MarketplaceListingWhereInput = {
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    id?: IntFilter<"MarketplaceListing"> | number
    playerId?: IntFilter<"MarketplaceListing"> | number
    sellerTeamId?: IntFilter<"MarketplaceListing"> | number
    startBid?: BigIntFilter<"MarketplaceListing"> | bigint | number
    buyNowPrice?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    minBuyNowPrice?: BigIntFilter<"MarketplaceListing"> | bigint | number
    currentBid?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    currentHighBidderTeamId?: IntNullableFilter<"MarketplaceListing"> | number | null
    expiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    originalExpiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    auctionExtensions?: IntFilter<"MarketplaceListing"> | number
    listingFee?: BigIntFilter<"MarketplaceListing"> | bigint | number
    marketTaxRate?: FloatFilter<"MarketplaceListing"> | number
    escrowAmount?: BigIntFilter<"MarketplaceListing"> | bigint | number
    listingStatus?: EnumMarketplaceStatusFilter<"MarketplaceListing"> | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFilter<"MarketplaceListing"> | boolean
    autoDelistAt?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    isActive?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    sellerTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    currentHighBidderTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    bids?: BidListRelationFilter
    history?: ListingHistoryListRelationFilter
  }

  export type MarketplaceListingOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrderInput | SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrderInput | SortOrder
    currentHighBidderTeamId?: SortOrderInput | SortOrder
    expiryTimestamp?: SortOrder
    originalExpiryTimestamp?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
    listingStatus?: SortOrder
    isOffSeasonConverted?: SortOrder
    autoDelistAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    sellerTeam?: TeamOrderByWithRelationInput
    currentHighBidderTeam?: TeamOrderByWithRelationInput
    bids?: BidOrderByRelationAggregateInput
    history?: ListingHistoryOrderByRelationAggregateInput
  }

  export type MarketplaceListingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId?: number
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    sellerTeamId?: IntFilter<"MarketplaceListing"> | number
    startBid?: BigIntFilter<"MarketplaceListing"> | bigint | number
    buyNowPrice?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    minBuyNowPrice?: BigIntFilter<"MarketplaceListing"> | bigint | number
    currentBid?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    currentHighBidderTeamId?: IntNullableFilter<"MarketplaceListing"> | number | null
    expiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    originalExpiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    auctionExtensions?: IntFilter<"MarketplaceListing"> | number
    listingFee?: BigIntFilter<"MarketplaceListing"> | bigint | number
    marketTaxRate?: FloatFilter<"MarketplaceListing"> | number
    escrowAmount?: BigIntFilter<"MarketplaceListing"> | bigint | number
    listingStatus?: EnumMarketplaceStatusFilter<"MarketplaceListing"> | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFilter<"MarketplaceListing"> | boolean
    autoDelistAt?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    isActive?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    sellerTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    currentHighBidderTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    bids?: BidListRelationFilter
    history?: ListingHistoryListRelationFilter
  }, "id" | "playerId">

  export type MarketplaceListingOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrderInput | SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrderInput | SortOrder
    currentHighBidderTeamId?: SortOrderInput | SortOrder
    expiryTimestamp?: SortOrder
    originalExpiryTimestamp?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
    listingStatus?: SortOrder
    isOffSeasonConverted?: SortOrder
    autoDelistAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceListingCountOrderByAggregateInput
    _avg?: MarketplaceListingAvgOrderByAggregateInput
    _max?: MarketplaceListingMaxOrderByAggregateInput
    _min?: MarketplaceListingMinOrderByAggregateInput
    _sum?: MarketplaceListingSumOrderByAggregateInput
  }

  export type MarketplaceListingScalarWhereWithAggregatesInput = {
    AND?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    OR?: MarketplaceListingScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketplaceListing"> | number
    playerId?: IntWithAggregatesFilter<"MarketplaceListing"> | number
    sellerTeamId?: IntWithAggregatesFilter<"MarketplaceListing"> | number
    startBid?: BigIntWithAggregatesFilter<"MarketplaceListing"> | bigint | number
    buyNowPrice?: BigIntNullableWithAggregatesFilter<"MarketplaceListing"> | bigint | number | null
    minBuyNowPrice?: BigIntWithAggregatesFilter<"MarketplaceListing"> | bigint | number
    currentBid?: BigIntNullableWithAggregatesFilter<"MarketplaceListing"> | bigint | number | null
    currentHighBidderTeamId?: IntNullableWithAggregatesFilter<"MarketplaceListing"> | number | null
    expiryTimestamp?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    originalExpiryTimestamp?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    auctionExtensions?: IntWithAggregatesFilter<"MarketplaceListing"> | number
    listingFee?: BigIntWithAggregatesFilter<"MarketplaceListing"> | bigint | number
    marketTaxRate?: FloatWithAggregatesFilter<"MarketplaceListing"> | number
    escrowAmount?: BigIntWithAggregatesFilter<"MarketplaceListing"> | bigint | number
    listingStatus?: EnumMarketplaceStatusWithAggregatesFilter<"MarketplaceListing"> | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolWithAggregatesFilter<"MarketplaceListing"> | boolean
    autoDelistAt?: DateTimeNullableWithAggregatesFilter<"MarketplaceListing"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
  }

  export type BidWhereInput = {
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    id?: IntFilter<"Bid"> | number
    listingId?: IntFilter<"Bid"> | number
    bidderTeamId?: IntFilter<"Bid"> | number
    bidAmount?: BigIntFilter<"Bid"> | bigint | number
    escrowAmount?: BigIntFilter<"Bid"> | bigint | number
    isWinningBid?: BoolFilter<"Bid"> | boolean
    isRefunded?: BoolFilter<"Bid"> | boolean
    placedAt?: DateTimeFilter<"Bid"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    bidderTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type BidOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
    isWinningBid?: SortOrder
    isRefunded?: SortOrder
    placedAt?: SortOrder
    listing?: MarketplaceListingOrderByWithRelationInput
    bidderTeam?: TeamOrderByWithRelationInput
  }

  export type BidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    listingId?: IntFilter<"Bid"> | number
    bidderTeamId?: IntFilter<"Bid"> | number
    bidAmount?: BigIntFilter<"Bid"> | bigint | number
    escrowAmount?: BigIntFilter<"Bid"> | bigint | number
    isWinningBid?: BoolFilter<"Bid"> | boolean
    isRefunded?: BoolFilter<"Bid"> | boolean
    placedAt?: DateTimeFilter<"Bid"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    bidderTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id">

  export type BidOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
    isWinningBid?: SortOrder
    isRefunded?: SortOrder
    placedAt?: SortOrder
    _count?: BidCountOrderByAggregateInput
    _avg?: BidAvgOrderByAggregateInput
    _max?: BidMaxOrderByAggregateInput
    _min?: BidMinOrderByAggregateInput
    _sum?: BidSumOrderByAggregateInput
  }

  export type BidScalarWhereWithAggregatesInput = {
    AND?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    OR?: BidScalarWhereWithAggregatesInput[]
    NOT?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bid"> | number
    listingId?: IntWithAggregatesFilter<"Bid"> | number
    bidderTeamId?: IntWithAggregatesFilter<"Bid"> | number
    bidAmount?: BigIntWithAggregatesFilter<"Bid"> | bigint | number
    escrowAmount?: BigIntWithAggregatesFilter<"Bid"> | bigint | number
    isWinningBid?: BoolWithAggregatesFilter<"Bid"> | boolean
    isRefunded?: BoolWithAggregatesFilter<"Bid"> | boolean
    placedAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
  }

  export type ListingHistoryWhereInput = {
    AND?: ListingHistoryWhereInput | ListingHistoryWhereInput[]
    OR?: ListingHistoryWhereInput[]
    NOT?: ListingHistoryWhereInput | ListingHistoryWhereInput[]
    id?: IntFilter<"ListingHistory"> | number
    listingId?: IntFilter<"ListingHistory"> | number
    actionType?: EnumListingActionTypeFilter<"ListingHistory"> | $Enums.ListingActionType
    teamId?: IntNullableFilter<"ListingHistory"> | number | null
    amount?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    oldValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    newValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    description?: StringNullableFilter<"ListingHistory"> | string | null
    timestamp?: DateTimeFilter<"ListingHistory"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type ListingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    actionType?: SortOrder
    teamId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    listing?: MarketplaceListingOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type ListingHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ListingHistoryWhereInput | ListingHistoryWhereInput[]
    OR?: ListingHistoryWhereInput[]
    NOT?: ListingHistoryWhereInput | ListingHistoryWhereInput[]
    listingId?: IntFilter<"ListingHistory"> | number
    actionType?: EnumListingActionTypeFilter<"ListingHistory"> | $Enums.ListingActionType
    teamId?: IntNullableFilter<"ListingHistory"> | number | null
    amount?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    oldValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    newValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    description?: StringNullableFilter<"ListingHistory"> | string | null
    timestamp?: DateTimeFilter<"ListingHistory"> | Date | string
    listing?: XOR<MarketplaceListingScalarRelationFilter, MarketplaceListingWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "id">

  export type ListingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    actionType?: SortOrder
    teamId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: ListingHistoryCountOrderByAggregateInput
    _avg?: ListingHistoryAvgOrderByAggregateInput
    _max?: ListingHistoryMaxOrderByAggregateInput
    _min?: ListingHistoryMinOrderByAggregateInput
    _sum?: ListingHistorySumOrderByAggregateInput
  }

  export type ListingHistoryScalarWhereWithAggregatesInput = {
    AND?: ListingHistoryScalarWhereWithAggregatesInput | ListingHistoryScalarWhereWithAggregatesInput[]
    OR?: ListingHistoryScalarWhereWithAggregatesInput[]
    NOT?: ListingHistoryScalarWhereWithAggregatesInput | ListingHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ListingHistory"> | number
    listingId?: IntWithAggregatesFilter<"ListingHistory"> | number
    actionType?: EnumListingActionTypeWithAggregatesFilter<"ListingHistory"> | $Enums.ListingActionType
    teamId?: IntNullableWithAggregatesFilter<"ListingHistory"> | number | null
    amount?: BigIntNullableWithAggregatesFilter<"ListingHistory"> | bigint | number | null
    oldValue?: BigIntNullableWithAggregatesFilter<"ListingHistory"> | bigint | number | null
    newValue?: BigIntNullableWithAggregatesFilter<"ListingHistory"> | bigint | number | null
    description?: StringNullableWithAggregatesFilter<"ListingHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ListingHistory"> | Date | string
  }

  export type PlayerMarketValueWhereInput = {
    AND?: PlayerMarketValueWhereInput | PlayerMarketValueWhereInput[]
    OR?: PlayerMarketValueWhereInput[]
    NOT?: PlayerMarketValueWhereInput | PlayerMarketValueWhereInput[]
    id?: IntFilter<"PlayerMarketValue"> | number
    playerId?: IntFilter<"PlayerMarketValue"> | number
    carRating?: FloatFilter<"PlayerMarketValue"> | number
    potential?: FloatFilter<"PlayerMarketValue"> | number
    minBuyNow?: BigIntFilter<"PlayerMarketValue"> | bigint | number
    marketValue?: BigIntFilter<"PlayerMarketValue"> | bigint | number
    lastUpdated?: DateTimeFilter<"PlayerMarketValue"> | Date | string
    createdAt?: DateTimeFilter<"PlayerMarketValue"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type PlayerMarketValueOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type PlayerMarketValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    playerId?: number
    AND?: PlayerMarketValueWhereInput | PlayerMarketValueWhereInput[]
    OR?: PlayerMarketValueWhereInput[]
    NOT?: PlayerMarketValueWhereInput | PlayerMarketValueWhereInput[]
    carRating?: FloatFilter<"PlayerMarketValue"> | number
    potential?: FloatFilter<"PlayerMarketValue"> | number
    minBuyNow?: BigIntFilter<"PlayerMarketValue"> | bigint | number
    marketValue?: BigIntFilter<"PlayerMarketValue"> | bigint | number
    lastUpdated?: DateTimeFilter<"PlayerMarketValue"> | Date | string
    createdAt?: DateTimeFilter<"PlayerMarketValue"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId">

  export type PlayerMarketValueOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    _count?: PlayerMarketValueCountOrderByAggregateInput
    _avg?: PlayerMarketValueAvgOrderByAggregateInput
    _max?: PlayerMarketValueMaxOrderByAggregateInput
    _min?: PlayerMarketValueMinOrderByAggregateInput
    _sum?: PlayerMarketValueSumOrderByAggregateInput
  }

  export type PlayerMarketValueScalarWhereWithAggregatesInput = {
    AND?: PlayerMarketValueScalarWhereWithAggregatesInput | PlayerMarketValueScalarWhereWithAggregatesInput[]
    OR?: PlayerMarketValueScalarWhereWithAggregatesInput[]
    NOT?: PlayerMarketValueScalarWhereWithAggregatesInput | PlayerMarketValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerMarketValue"> | number
    playerId?: IntWithAggregatesFilter<"PlayerMarketValue"> | number
    carRating?: FloatWithAggregatesFilter<"PlayerMarketValue"> | number
    potential?: FloatWithAggregatesFilter<"PlayerMarketValue"> | number
    minBuyNow?: BigIntWithAggregatesFilter<"PlayerMarketValue"> | bigint | number
    marketValue?: BigIntWithAggregatesFilter<"PlayerMarketValue"> | bigint | number
    lastUpdated?: DateTimeWithAggregatesFilter<"PlayerMarketValue"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PlayerMarketValue"> | Date | string
  }

  export type StrategyWhereInput = {
    AND?: StrategyWhereInput | StrategyWhereInput[]
    OR?: StrategyWhereInput[]
    NOT?: StrategyWhereInput | StrategyWhereInput[]
    id?: IntFilter<"Strategy"> | number
    teamId?: IntFilter<"Strategy"> | number
    formationJson?: JsonNullableFilter<"Strategy">
    substitutionJson?: JsonNullableFilter<"Strategy">
    createdAt?: DateTimeFilter<"Strategy"> | Date | string
    updatedAt?: DateTimeFilter<"Strategy"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type StrategyOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    formationJson?: SortOrderInput | SortOrder
    substitutionJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type StrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId?: number
    AND?: StrategyWhereInput | StrategyWhereInput[]
    OR?: StrategyWhereInput[]
    NOT?: StrategyWhereInput | StrategyWhereInput[]
    formationJson?: JsonNullableFilter<"Strategy">
    substitutionJson?: JsonNullableFilter<"Strategy">
    createdAt?: DateTimeFilter<"Strategy"> | Date | string
    updatedAt?: DateTimeFilter<"Strategy"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamId">

  export type StrategyOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    formationJson?: SortOrderInput | SortOrder
    substitutionJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StrategyCountOrderByAggregateInput
    _avg?: StrategyAvgOrderByAggregateInput
    _max?: StrategyMaxOrderByAggregateInput
    _min?: StrategyMinOrderByAggregateInput
    _sum?: StrategySumOrderByAggregateInput
  }

  export type StrategyScalarWhereWithAggregatesInput = {
    AND?: StrategyScalarWhereWithAggregatesInput | StrategyScalarWhereWithAggregatesInput[]
    OR?: StrategyScalarWhereWithAggregatesInput[]
    NOT?: StrategyScalarWhereWithAggregatesInput | StrategyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Strategy"> | number
    teamId?: IntWithAggregatesFilter<"Strategy"> | number
    formationJson?: JsonNullableWithAggregatesFilter<"Strategy">
    substitutionJson?: JsonNullableWithAggregatesFilter<"Strategy">
    createdAt?: DateTimeWithAggregatesFilter<"Strategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Strategy"> | Date | string
  }

  export type LeagueWhereInput = {
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    id?: IntFilter<"League"> | number
    division?: IntFilter<"League"> | number
    name?: StringFilter<"League"> | string
    seasonId?: StringFilter<"League"> | string
    teams?: TeamListRelationFilter
    schedule?: GameListRelationFilter
    standings?: LeagueStandingListRelationFilter
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
  }

  export type LeagueOrderByWithRelationInput = {
    id?: SortOrder
    division?: SortOrder
    name?: SortOrder
    seasonId?: SortOrder
    teams?: TeamOrderByRelationAggregateInput
    schedule?: GameOrderByRelationAggregateInput
    standings?: LeagueStandingOrderByRelationAggregateInput
    season?: SeasonOrderByWithRelationInput
  }

  export type LeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_seasonId?: LeagueNameSeasonIdCompoundUniqueInput
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    division?: IntFilter<"League"> | number
    name?: StringFilter<"League"> | string
    seasonId?: StringFilter<"League"> | string
    teams?: TeamListRelationFilter
    schedule?: GameListRelationFilter
    standings?: LeagueStandingListRelationFilter
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
  }, "id" | "name_seasonId">

  export type LeagueOrderByWithAggregationInput = {
    id?: SortOrder
    division?: SortOrder
    name?: SortOrder
    seasonId?: SortOrder
    _count?: LeagueCountOrderByAggregateInput
    _avg?: LeagueAvgOrderByAggregateInput
    _max?: LeagueMaxOrderByAggregateInput
    _min?: LeagueMinOrderByAggregateInput
    _sum?: LeagueSumOrderByAggregateInput
  }

  export type LeagueScalarWhereWithAggregatesInput = {
    AND?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    OR?: LeagueScalarWhereWithAggregatesInput[]
    NOT?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"League"> | number
    division?: IntWithAggregatesFilter<"League"> | number
    name?: StringWithAggregatesFilter<"League"> | string
    seasonId?: StringWithAggregatesFilter<"League"> | string
  }

  export type LeagueStandingWhereInput = {
    AND?: LeagueStandingWhereInput | LeagueStandingWhereInput[]
    OR?: LeagueStandingWhereInput[]
    NOT?: LeagueStandingWhereInput | LeagueStandingWhereInput[]
    id?: IntFilter<"LeagueStanding"> | number
    leagueId?: IntFilter<"LeagueStanding"> | number
    teamId?: IntFilter<"LeagueStanding"> | number
    teamName?: StringFilter<"LeagueStanding"> | string
    wins?: IntFilter<"LeagueStanding"> | number
    losses?: IntFilter<"LeagueStanding"> | number
    ties?: IntFilter<"LeagueStanding"> | number
    pointsFor?: IntFilter<"LeagueStanding"> | number
    pointsAgainst?: IntFilter<"LeagueStanding"> | number
    pointDifferential?: IntFilter<"LeagueStanding"> | number
    streak?: StringFilter<"LeagueStanding"> | string
    rank?: IntFilter<"LeagueStanding"> | number
    updatedAt?: DateTimeFilter<"LeagueStanding"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }

  export type LeagueStandingOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    streak?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
  }

  export type LeagueStandingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    leagueId_teamId?: LeagueStandingLeagueIdTeamIdCompoundUniqueInput
    AND?: LeagueStandingWhereInput | LeagueStandingWhereInput[]
    OR?: LeagueStandingWhereInput[]
    NOT?: LeagueStandingWhereInput | LeagueStandingWhereInput[]
    leagueId?: IntFilter<"LeagueStanding"> | number
    teamId?: IntFilter<"LeagueStanding"> | number
    teamName?: StringFilter<"LeagueStanding"> | string
    wins?: IntFilter<"LeagueStanding"> | number
    losses?: IntFilter<"LeagueStanding"> | number
    ties?: IntFilter<"LeagueStanding"> | number
    pointsFor?: IntFilter<"LeagueStanding"> | number
    pointsAgainst?: IntFilter<"LeagueStanding"> | number
    pointDifferential?: IntFilter<"LeagueStanding"> | number
    streak?: StringFilter<"LeagueStanding"> | string
    rank?: IntFilter<"LeagueStanding"> | number
    updatedAt?: DateTimeFilter<"LeagueStanding"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }, "id" | "leagueId_teamId">

  export type LeagueStandingOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    streak?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
    _count?: LeagueStandingCountOrderByAggregateInput
    _avg?: LeagueStandingAvgOrderByAggregateInput
    _max?: LeagueStandingMaxOrderByAggregateInput
    _min?: LeagueStandingMinOrderByAggregateInput
    _sum?: LeagueStandingSumOrderByAggregateInput
  }

  export type LeagueStandingScalarWhereWithAggregatesInput = {
    AND?: LeagueStandingScalarWhereWithAggregatesInput | LeagueStandingScalarWhereWithAggregatesInput[]
    OR?: LeagueStandingScalarWhereWithAggregatesInput[]
    NOT?: LeagueStandingScalarWhereWithAggregatesInput | LeagueStandingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeagueStanding"> | number
    leagueId?: IntWithAggregatesFilter<"LeagueStanding"> | number
    teamId?: IntWithAggregatesFilter<"LeagueStanding"> | number
    teamName?: StringWithAggregatesFilter<"LeagueStanding"> | string
    wins?: IntWithAggregatesFilter<"LeagueStanding"> | number
    losses?: IntWithAggregatesFilter<"LeagueStanding"> | number
    ties?: IntWithAggregatesFilter<"LeagueStanding"> | number
    pointsFor?: IntWithAggregatesFilter<"LeagueStanding"> | number
    pointsAgainst?: IntWithAggregatesFilter<"LeagueStanding"> | number
    pointDifferential?: IntWithAggregatesFilter<"LeagueStanding"> | number
    streak?: StringWithAggregatesFilter<"LeagueStanding"> | string
    rank?: IntWithAggregatesFilter<"LeagueStanding"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"LeagueStanding"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: IntFilter<"Game"> | number
    leagueId?: IntNullableFilter<"Game"> | number | null
    homeTeamId?: IntFilter<"Game"> | number
    awayTeamId?: IntFilter<"Game"> | number
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    gameDate?: DateTimeFilter<"Game"> | Date | string
    simulated?: BoolFilter<"Game"> | boolean
    simulationLog?: JsonNullableFilter<"Game">
    matchType?: EnumMatchTypeFilter<"Game"> | $Enums.MatchType
    tournamentId?: IntNullableFilter<"Game"> | number | null
    round?: IntNullableFilter<"Game"> | number | null
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    createdAt?: DateTimeFilter<"Game"> | Date | string
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, TournamentWhereInput> | null
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrderInput | SortOrder
    awayScore?: SortOrderInput | SortOrder
    gameDate?: SortOrder
    simulated?: SortOrder
    simulationLog?: SortOrderInput | SortOrder
    matchType?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    round?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    homeTeam?: TeamOrderByWithRelationInput
    awayTeam?: TeamOrderByWithRelationInput
    tournament?: TournamentOrderByWithRelationInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    leagueId?: IntNullableFilter<"Game"> | number | null
    homeTeamId?: IntFilter<"Game"> | number
    awayTeamId?: IntFilter<"Game"> | number
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    gameDate?: DateTimeFilter<"Game"> | Date | string
    simulated?: BoolFilter<"Game"> | boolean
    simulationLog?: JsonNullableFilter<"Game">
    matchType?: EnumMatchTypeFilter<"Game"> | $Enums.MatchType
    tournamentId?: IntNullableFilter<"Game"> | number | null
    round?: IntNullableFilter<"Game"> | number | null
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    createdAt?: DateTimeFilter<"Game"> | Date | string
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, TournamentWhereInput> | null
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrderInput | SortOrder
    awayScore?: SortOrderInput | SortOrder
    gameDate?: SortOrder
    simulated?: SortOrder
    simulationLog?: SortOrderInput | SortOrder
    matchType?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    round?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Game"> | number
    leagueId?: IntNullableWithAggregatesFilter<"Game"> | number | null
    homeTeamId?: IntWithAggregatesFilter<"Game"> | number
    awayTeamId?: IntWithAggregatesFilter<"Game"> | number
    homeScore?: IntNullableWithAggregatesFilter<"Game"> | number | null
    awayScore?: IntNullableWithAggregatesFilter<"Game"> | number | null
    gameDate?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    simulated?: BoolWithAggregatesFilter<"Game"> | boolean
    simulationLog?: JsonNullableWithAggregatesFilter<"Game">
    matchType?: EnumMatchTypeWithAggregatesFilter<"Game"> | $Enums.MatchType
    tournamentId?: IntNullableWithAggregatesFilter<"Game"> | number | null
    round?: IntNullableWithAggregatesFilter<"Game"> | number | null
    status?: EnumGameStatusWithAggregatesFilter<"Game"> | $Enums.GameStatus
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    seasonNumber?: IntFilter<"Season"> | number
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    currentDay?: IntFilter<"Season"> | number
    phase?: EnumSeasonPhaseFilter<"Season"> | $Enums.SeasonPhase
    createdAt?: DateTimeFilter<"Season"> | Date | string
    leagues?: LeagueListRelationFilter
    tryoutHistory?: TryoutHistoryListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    seasonNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentDay?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    leagues?: LeagueOrderByRelationAggregateInput
    tryoutHistory?: TryoutHistoryOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seasonNumber?: number
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    currentDay?: IntFilter<"Season"> | number
    phase?: EnumSeasonPhaseFilter<"Season"> | $Enums.SeasonPhase
    createdAt?: DateTimeFilter<"Season"> | Date | string
    leagues?: LeagueListRelationFilter
    tryoutHistory?: TryoutHistoryListRelationFilter
  }, "id" | "id" | "seasonNumber">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    seasonNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentDay?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    seasonNumber?: IntWithAggregatesFilter<"Season"> | number
    startDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    currentDay?: IntWithAggregatesFilter<"Season"> | number
    phase?: EnumSeasonPhaseWithAggregatesFilter<"Season"> | $Enums.SeasonPhase
    createdAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    teamId?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    linkTo?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    linkTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    teamId?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    linkTo?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    linkTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    teamId?: IntWithAggregatesFilter<"Notification"> | number
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    linkTo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type TryoutPackWhereInput = {
    AND?: TryoutPackWhereInput | TryoutPackWhereInput[]
    OR?: TryoutPackWhereInput[]
    NOT?: TryoutPackWhereInput | TryoutPackWhereInput[]
    id?: IntFilter<"TryoutPack"> | number
    name?: StringFilter<"TryoutPack"> | string
    description?: StringFilter<"TryoutPack"> | string
    creditCost?: BigIntFilter<"TryoutPack"> | bigint | number
    gemCost?: IntNullableFilter<"TryoutPack"> | number | null
    numPlayers?: IntFilter<"TryoutPack"> | number
    qualityTier?: StringFilter<"TryoutPack"> | string
  }

  export type TryoutPackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrderInput | SortOrder
    numPlayers?: SortOrder
    qualityTier?: SortOrder
  }

  export type TryoutPackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TryoutPackWhereInput | TryoutPackWhereInput[]
    OR?: TryoutPackWhereInput[]
    NOT?: TryoutPackWhereInput | TryoutPackWhereInput[]
    description?: StringFilter<"TryoutPack"> | string
    creditCost?: BigIntFilter<"TryoutPack"> | bigint | number
    gemCost?: IntNullableFilter<"TryoutPack"> | number | null
    numPlayers?: IntFilter<"TryoutPack"> | number
    qualityTier?: StringFilter<"TryoutPack"> | string
  }, "id" | "name">

  export type TryoutPackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrderInput | SortOrder
    numPlayers?: SortOrder
    qualityTier?: SortOrder
    _count?: TryoutPackCountOrderByAggregateInput
    _avg?: TryoutPackAvgOrderByAggregateInput
    _max?: TryoutPackMaxOrderByAggregateInput
    _min?: TryoutPackMinOrderByAggregateInput
    _sum?: TryoutPackSumOrderByAggregateInput
  }

  export type TryoutPackScalarWhereWithAggregatesInput = {
    AND?: TryoutPackScalarWhereWithAggregatesInput | TryoutPackScalarWhereWithAggregatesInput[]
    OR?: TryoutPackScalarWhereWithAggregatesInput[]
    NOT?: TryoutPackScalarWhereWithAggregatesInput | TryoutPackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TryoutPack"> | number
    name?: StringWithAggregatesFilter<"TryoutPack"> | string
    description?: StringWithAggregatesFilter<"TryoutPack"> | string
    creditCost?: BigIntWithAggregatesFilter<"TryoutPack"> | bigint | number
    gemCost?: IntNullableWithAggregatesFilter<"TryoutPack"> | number | null
    numPlayers?: IntWithAggregatesFilter<"TryoutPack"> | number
    qualityTier?: StringWithAggregatesFilter<"TryoutPack"> | string
  }

  export type TryoutHistoryWhereInput = {
    AND?: TryoutHistoryWhereInput | TryoutHistoryWhereInput[]
    OR?: TryoutHistoryWhereInput[]
    NOT?: TryoutHistoryWhereInput | TryoutHistoryWhereInput[]
    id?: IntFilter<"TryoutHistory"> | number
    teamId?: IntFilter<"TryoutHistory"> | number
    seasonId?: StringFilter<"TryoutHistory"> | string
    tryoutType?: StringFilter<"TryoutHistory"> | string
    cost?: IntFilter<"TryoutHistory"> | number
    playersAdded?: IntFilter<"TryoutHistory"> | number
    conductedAt?: DateTimeFilter<"TryoutHistory"> | Date | string
    playerId?: IntNullableFilter<"TryoutHistory"> | number | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type TryoutHistoryOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    tryoutType?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    conductedAt?: SortOrder
    playerId?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type TryoutHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_seasonId?: TryoutHistoryTeamIdSeasonIdCompoundUniqueInput
    AND?: TryoutHistoryWhereInput | TryoutHistoryWhereInput[]
    OR?: TryoutHistoryWhereInput[]
    NOT?: TryoutHistoryWhereInput | TryoutHistoryWhereInput[]
    teamId?: IntFilter<"TryoutHistory"> | number
    seasonId?: StringFilter<"TryoutHistory"> | string
    tryoutType?: StringFilter<"TryoutHistory"> | string
    cost?: IntFilter<"TryoutHistory"> | number
    playersAdded?: IntFilter<"TryoutHistory"> | number
    conductedAt?: DateTimeFilter<"TryoutHistory"> | Date | string
    playerId?: IntNullableFilter<"TryoutHistory"> | number | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id" | "teamId_seasonId">

  export type TryoutHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    tryoutType?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    conductedAt?: SortOrder
    playerId?: SortOrderInput | SortOrder
    _count?: TryoutHistoryCountOrderByAggregateInput
    _avg?: TryoutHistoryAvgOrderByAggregateInput
    _max?: TryoutHistoryMaxOrderByAggregateInput
    _min?: TryoutHistoryMinOrderByAggregateInput
    _sum?: TryoutHistorySumOrderByAggregateInput
  }

  export type TryoutHistoryScalarWhereWithAggregatesInput = {
    AND?: TryoutHistoryScalarWhereWithAggregatesInput | TryoutHistoryScalarWhereWithAggregatesInput[]
    OR?: TryoutHistoryScalarWhereWithAggregatesInput[]
    NOT?: TryoutHistoryScalarWhereWithAggregatesInput | TryoutHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TryoutHistory"> | number
    teamId?: IntWithAggregatesFilter<"TryoutHistory"> | number
    seasonId?: StringWithAggregatesFilter<"TryoutHistory"> | string
    tryoutType?: StringWithAggregatesFilter<"TryoutHistory"> | string
    cost?: IntWithAggregatesFilter<"TryoutHistory"> | number
    playersAdded?: IntWithAggregatesFilter<"TryoutHistory"> | number
    conductedAt?: DateTimeWithAggregatesFilter<"TryoutHistory"> | Date | string
    playerId?: IntNullableWithAggregatesFilter<"TryoutHistory"> | number | null
  }

  export type GemPackWhereInput = {
    AND?: GemPackWhereInput | GemPackWhereInput[]
    OR?: GemPackWhereInput[]
    NOT?: GemPackWhereInput | GemPackWhereInput[]
    id?: IntFilter<"GemPack"> | number
    name?: StringFilter<"GemPack"> | string
    gemAmount?: IntFilter<"GemPack"> | number
    usdPrice?: FloatFilter<"GemPack"> | number
    productId?: StringFilter<"GemPack"> | string
  }

  export type GemPackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
    productId?: SortOrder
  }

  export type GemPackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    productId?: string
    AND?: GemPackWhereInput | GemPackWhereInput[]
    OR?: GemPackWhereInput[]
    NOT?: GemPackWhereInput | GemPackWhereInput[]
    gemAmount?: IntFilter<"GemPack"> | number
    usdPrice?: FloatFilter<"GemPack"> | number
  }, "id" | "name" | "productId">

  export type GemPackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
    productId?: SortOrder
    _count?: GemPackCountOrderByAggregateInput
    _avg?: GemPackAvgOrderByAggregateInput
    _max?: GemPackMaxOrderByAggregateInput
    _min?: GemPackMinOrderByAggregateInput
    _sum?: GemPackSumOrderByAggregateInput
  }

  export type GemPackScalarWhereWithAggregatesInput = {
    AND?: GemPackScalarWhereWithAggregatesInput | GemPackScalarWhereWithAggregatesInput[]
    OR?: GemPackScalarWhereWithAggregatesInput[]
    NOT?: GemPackScalarWhereWithAggregatesInput | GemPackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GemPack"> | number
    name?: StringWithAggregatesFilter<"GemPack"> | string
    gemAmount?: IntWithAggregatesFilter<"GemPack"> | number
    usdPrice?: FloatWithAggregatesFilter<"GemPack"> | number
    productId?: StringWithAggregatesFilter<"GemPack"> | string
  }

  export type CreditExchangeRateWhereInput = {
    AND?: CreditExchangeRateWhereInput | CreditExchangeRateWhereInput[]
    OR?: CreditExchangeRateWhereInput[]
    NOT?: CreditExchangeRateWhereInput | CreditExchangeRateWhereInput[]
    id?: IntFilter<"CreditExchangeRate"> | number
    gems?: IntFilter<"CreditExchangeRate"> | number
    credits?: BigIntFilter<"CreditExchangeRate"> | bigint | number
    bonusPercentage?: FloatFilter<"CreditExchangeRate"> | number
  }

  export type CreditExchangeRateOrderByWithRelationInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type CreditExchangeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    gems?: number
    AND?: CreditExchangeRateWhereInput | CreditExchangeRateWhereInput[]
    OR?: CreditExchangeRateWhereInput[]
    NOT?: CreditExchangeRateWhereInput | CreditExchangeRateWhereInput[]
    credits?: BigIntFilter<"CreditExchangeRate"> | bigint | number
    bonusPercentage?: FloatFilter<"CreditExchangeRate"> | number
  }, "id" | "gems">

  export type CreditExchangeRateOrderByWithAggregationInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
    _count?: CreditExchangeRateCountOrderByAggregateInput
    _avg?: CreditExchangeRateAvgOrderByAggregateInput
    _max?: CreditExchangeRateMaxOrderByAggregateInput
    _min?: CreditExchangeRateMinOrderByAggregateInput
    _sum?: CreditExchangeRateSumOrderByAggregateInput
  }

  export type CreditExchangeRateScalarWhereWithAggregatesInput = {
    AND?: CreditExchangeRateScalarWhereWithAggregatesInput | CreditExchangeRateScalarWhereWithAggregatesInput[]
    OR?: CreditExchangeRateScalarWhereWithAggregatesInput[]
    NOT?: CreditExchangeRateScalarWhereWithAggregatesInput | CreditExchangeRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreditExchangeRate"> | number
    gems?: IntWithAggregatesFilter<"CreditExchangeRate"> | number
    credits?: BigIntWithAggregatesFilter<"CreditExchangeRate"> | bigint | number
    bonusPercentage?: FloatWithAggregatesFilter<"CreditExchangeRate"> | number
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: IntFilter<"Referral"> | number
    referrerUserId?: StringFilter<"Referral"> | string
    referredUserId?: StringFilter<"Referral"> | string
    rewardGiven?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerUserId?: SortOrder
    referredUserId?: SortOrder
    rewardGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referrerUserId_referredUserId?: ReferralReferrerUserIdReferredUserIdCompoundUniqueInput
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerUserId?: StringFilter<"Referral"> | string
    referredUserId?: StringFilter<"Referral"> | string
    rewardGiven?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }, "id" | "referrerUserId_referredUserId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerUserId?: SortOrder
    referredUserId?: SortOrder
    rewardGiven?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Referral"> | number
    referrerUserId?: StringWithAggregatesFilter<"Referral"> | string
    referredUserId?: StringWithAggregatesFilter<"Referral"> | string
    rewardGiven?: BoolWithAggregatesFilter<"Referral"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type RedeemCodeWhereInput = {
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    id?: StringFilter<"RedeemCode"> | string
    description?: StringFilter<"RedeemCode"> | string
    rewardType?: EnumRewardTypeFilter<"RedeemCode"> | $Enums.RewardType
    rewardValue?: JsonFilter<"RedeemCode">
    maxUses?: IntNullableFilter<"RedeemCode"> | number | null
    currentUses?: IntFilter<"RedeemCode"> | number
    isActive?: BoolFilter<"RedeemCode"> | boolean
    expiryDate?: DateTimeNullableFilter<"RedeemCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    redeemedBy?: RedeemCodeRecordListRelationFilter
  }

  export type RedeemCodeOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    redeemedBy?: RedeemCodeRecordOrderByRelationAggregateInput
  }

  export type RedeemCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    description?: StringFilter<"RedeemCode"> | string
    rewardType?: EnumRewardTypeFilter<"RedeemCode"> | $Enums.RewardType
    rewardValue?: JsonFilter<"RedeemCode">
    maxUses?: IntNullableFilter<"RedeemCode"> | number | null
    currentUses?: IntFilter<"RedeemCode"> | number
    isActive?: BoolFilter<"RedeemCode"> | boolean
    expiryDate?: DateTimeNullableFilter<"RedeemCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    redeemedBy?: RedeemCodeRecordListRelationFilter
  }, "id" | "id">

  export type RedeemCodeOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RedeemCodeCountOrderByAggregateInput
    _avg?: RedeemCodeAvgOrderByAggregateInput
    _max?: RedeemCodeMaxOrderByAggregateInput
    _min?: RedeemCodeMinOrderByAggregateInput
    _sum?: RedeemCodeSumOrderByAggregateInput
  }

  export type RedeemCodeScalarWhereWithAggregatesInput = {
    AND?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    OR?: RedeemCodeScalarWhereWithAggregatesInput[]
    NOT?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RedeemCode"> | string
    description?: StringWithAggregatesFilter<"RedeemCode"> | string
    rewardType?: EnumRewardTypeWithAggregatesFilter<"RedeemCode"> | $Enums.RewardType
    rewardValue?: JsonWithAggregatesFilter<"RedeemCode">
    maxUses?: IntNullableWithAggregatesFilter<"RedeemCode"> | number | null
    currentUses?: IntWithAggregatesFilter<"RedeemCode"> | number
    isActive?: BoolWithAggregatesFilter<"RedeemCode"> | boolean
    expiryDate?: DateTimeNullableWithAggregatesFilter<"RedeemCode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
  }

  export type RedeemCodeRecordWhereInput = {
    AND?: RedeemCodeRecordWhereInput | RedeemCodeRecordWhereInput[]
    OR?: RedeemCodeRecordWhereInput[]
    NOT?: RedeemCodeRecordWhereInput | RedeemCodeRecordWhereInput[]
    id?: IntFilter<"RedeemCodeRecord"> | number
    redeemCodeId?: StringFilter<"RedeemCodeRecord"> | string
    userProfileId?: IntFilter<"RedeemCodeRecord"> | number
    redeemedAt?: DateTimeFilter<"RedeemCodeRecord"> | Date | string
    redeemCode?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type RedeemCodeRecordOrderByWithRelationInput = {
    id?: SortOrder
    redeemCodeId?: SortOrder
    userProfileId?: SortOrder
    redeemedAt?: SortOrder
    redeemCode?: RedeemCodeOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type RedeemCodeRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    redeemCodeId_userProfileId?: RedeemCodeRecordRedeemCodeIdUserProfileIdCompoundUniqueInput
    AND?: RedeemCodeRecordWhereInput | RedeemCodeRecordWhereInput[]
    OR?: RedeemCodeRecordWhereInput[]
    NOT?: RedeemCodeRecordWhereInput | RedeemCodeRecordWhereInput[]
    redeemCodeId?: StringFilter<"RedeemCodeRecord"> | string
    userProfileId?: IntFilter<"RedeemCodeRecord"> | number
    redeemedAt?: DateTimeFilter<"RedeemCodeRecord"> | Date | string
    redeemCode?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id" | "redeemCodeId_userProfileId">

  export type RedeemCodeRecordOrderByWithAggregationInput = {
    id?: SortOrder
    redeemCodeId?: SortOrder
    userProfileId?: SortOrder
    redeemedAt?: SortOrder
    _count?: RedeemCodeRecordCountOrderByAggregateInput
    _avg?: RedeemCodeRecordAvgOrderByAggregateInput
    _max?: RedeemCodeRecordMaxOrderByAggregateInput
    _min?: RedeemCodeRecordMinOrderByAggregateInput
    _sum?: RedeemCodeRecordSumOrderByAggregateInput
  }

  export type RedeemCodeRecordScalarWhereWithAggregatesInput = {
    AND?: RedeemCodeRecordScalarWhereWithAggregatesInput | RedeemCodeRecordScalarWhereWithAggregatesInput[]
    OR?: RedeemCodeRecordScalarWhereWithAggregatesInput[]
    NOT?: RedeemCodeRecordScalarWhereWithAggregatesInput | RedeemCodeRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RedeemCodeRecord"> | number
    redeemCodeId?: StringWithAggregatesFilter<"RedeemCodeRecord"> | string
    userProfileId?: IntWithAggregatesFilter<"RedeemCodeRecord"> | number
    redeemedAt?: DateTimeWithAggregatesFilter<"RedeemCodeRecord"> | Date | string
  }

  export type AdRewardMilestoneWhereInput = {
    AND?: AdRewardMilestoneWhereInput | AdRewardMilestoneWhereInput[]
    OR?: AdRewardMilestoneWhereInput[]
    NOT?: AdRewardMilestoneWhereInput | AdRewardMilestoneWhereInput[]
    id?: IntFilter<"AdRewardMilestone"> | number
    userProfileId?: IntFilter<"AdRewardMilestone"> | number
    totalAdsWatched?: IntFilter<"AdRewardMilestone"> | number
    adsWatchedToday?: IntFilter<"AdRewardMilestone"> | number
    lastAdWatchedAt?: DateTimeNullableFilter<"AdRewardMilestone"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type AdRewardMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
    lastAdWatchedAt?: SortOrderInput | SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type AdRewardMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userProfileId?: number
    AND?: AdRewardMilestoneWhereInput | AdRewardMilestoneWhereInput[]
    OR?: AdRewardMilestoneWhereInput[]
    NOT?: AdRewardMilestoneWhereInput | AdRewardMilestoneWhereInput[]
    totalAdsWatched?: IntFilter<"AdRewardMilestone"> | number
    adsWatchedToday?: IntFilter<"AdRewardMilestone"> | number
    lastAdWatchedAt?: DateTimeNullableFilter<"AdRewardMilestone"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id" | "userProfileId">

  export type AdRewardMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
    lastAdWatchedAt?: SortOrderInput | SortOrder
    _count?: AdRewardMilestoneCountOrderByAggregateInput
    _avg?: AdRewardMilestoneAvgOrderByAggregateInput
    _max?: AdRewardMilestoneMaxOrderByAggregateInput
    _min?: AdRewardMilestoneMinOrderByAggregateInput
    _sum?: AdRewardMilestoneSumOrderByAggregateInput
  }

  export type AdRewardMilestoneScalarWhereWithAggregatesInput = {
    AND?: AdRewardMilestoneScalarWhereWithAggregatesInput | AdRewardMilestoneScalarWhereWithAggregatesInput[]
    OR?: AdRewardMilestoneScalarWhereWithAggregatesInput[]
    NOT?: AdRewardMilestoneScalarWhereWithAggregatesInput | AdRewardMilestoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdRewardMilestone"> | number
    userProfileId?: IntWithAggregatesFilter<"AdRewardMilestone"> | number
    totalAdsWatched?: IntWithAggregatesFilter<"AdRewardMilestone"> | number
    adsWatchedToday?: IntWithAggregatesFilter<"AdRewardMilestone"> | number
    lastAdWatchedAt?: DateTimeNullableWithAggregatesFilter<"AdRewardMilestone"> | Date | string | null
  }

  export type PremiumBoxRewardWhereInput = {
    AND?: PremiumBoxRewardWhereInput | PremiumBoxRewardWhereInput[]
    OR?: PremiumBoxRewardWhereInput[]
    NOT?: PremiumBoxRewardWhereInput | PremiumBoxRewardWhereInput[]
    id?: IntFilter<"PremiumBoxReward"> | number
    category?: StringFilter<"PremiumBoxReward"> | string
    rewardType?: EnumRewardTypeFilter<"PremiumBoxReward"> | $Enums.RewardType
    rewardValue?: JsonFilter<"PremiumBoxReward">
    weight?: FloatFilter<"PremiumBoxReward"> | number
  }

  export type PremiumBoxRewardOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    weight?: SortOrder
  }

  export type PremiumBoxRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PremiumBoxRewardWhereInput | PremiumBoxRewardWhereInput[]
    OR?: PremiumBoxRewardWhereInput[]
    NOT?: PremiumBoxRewardWhereInput | PremiumBoxRewardWhereInput[]
    category?: StringFilter<"PremiumBoxReward"> | string
    rewardType?: EnumRewardTypeFilter<"PremiumBoxReward"> | $Enums.RewardType
    rewardValue?: JsonFilter<"PremiumBoxReward">
    weight?: FloatFilter<"PremiumBoxReward"> | number
  }, "id">

  export type PremiumBoxRewardOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    weight?: SortOrder
    _count?: PremiumBoxRewardCountOrderByAggregateInput
    _avg?: PremiumBoxRewardAvgOrderByAggregateInput
    _max?: PremiumBoxRewardMaxOrderByAggregateInput
    _min?: PremiumBoxRewardMinOrderByAggregateInput
    _sum?: PremiumBoxRewardSumOrderByAggregateInput
  }

  export type PremiumBoxRewardScalarWhereWithAggregatesInput = {
    AND?: PremiumBoxRewardScalarWhereWithAggregatesInput | PremiumBoxRewardScalarWhereWithAggregatesInput[]
    OR?: PremiumBoxRewardScalarWhereWithAggregatesInput[]
    NOT?: PremiumBoxRewardScalarWhereWithAggregatesInput | PremiumBoxRewardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PremiumBoxReward"> | number
    category?: StringWithAggregatesFilter<"PremiumBoxReward"> | string
    rewardType?: EnumRewardTypeWithAggregatesFilter<"PremiumBoxReward"> | $Enums.RewardType
    rewardValue?: JsonWithAggregatesFilter<"PremiumBoxReward">
    weight?: FloatWithAggregatesFilter<"PremiumBoxReward"> | number
  }

  export type EquipmentRewardWhereInput = {
    AND?: EquipmentRewardWhereInput | EquipmentRewardWhereInput[]
    OR?: EquipmentRewardWhereInput[]
    NOT?: EquipmentRewardWhereInput | EquipmentRewardWhereInput[]
    id?: IntFilter<"EquipmentReward"> | number
    boxId?: IntFilter<"EquipmentReward"> | number
    itemId?: IntFilter<"EquipmentReward"> | number
    rarity?: EnumItemRarityFilter<"EquipmentReward"> | $Enums.ItemRarity
    weight?: FloatFilter<"EquipmentReward"> | number
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type EquipmentRewardOrderByWithRelationInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    rarity?: SortOrder
    weight?: SortOrder
    item?: ItemOrderByWithRelationInput
  }

  export type EquipmentRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EquipmentRewardWhereInput | EquipmentRewardWhereInput[]
    OR?: EquipmentRewardWhereInput[]
    NOT?: EquipmentRewardWhereInput | EquipmentRewardWhereInput[]
    boxId?: IntFilter<"EquipmentReward"> | number
    itemId?: IntFilter<"EquipmentReward"> | number
    rarity?: EnumItemRarityFilter<"EquipmentReward"> | $Enums.ItemRarity
    weight?: FloatFilter<"EquipmentReward"> | number
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type EquipmentRewardOrderByWithAggregationInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    rarity?: SortOrder
    weight?: SortOrder
    _count?: EquipmentRewardCountOrderByAggregateInput
    _avg?: EquipmentRewardAvgOrderByAggregateInput
    _max?: EquipmentRewardMaxOrderByAggregateInput
    _min?: EquipmentRewardMinOrderByAggregateInput
    _sum?: EquipmentRewardSumOrderByAggregateInput
  }

  export type EquipmentRewardScalarWhereWithAggregatesInput = {
    AND?: EquipmentRewardScalarWhereWithAggregatesInput | EquipmentRewardScalarWhereWithAggregatesInput[]
    OR?: EquipmentRewardScalarWhereWithAggregatesInput[]
    NOT?: EquipmentRewardScalarWhereWithAggregatesInput | EquipmentRewardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EquipmentReward"> | number
    boxId?: IntWithAggregatesFilter<"EquipmentReward"> | number
    itemId?: IntWithAggregatesFilter<"EquipmentReward"> | number
    rarity?: EnumItemRarityWithAggregatesFilter<"EquipmentReward"> | $Enums.ItemRarity
    weight?: FloatWithAggregatesFilter<"EquipmentReward"> | number
  }

  export type TournamentWhereInput = {
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    id?: IntFilter<"Tournament"> | number
    name?: StringFilter<"Tournament"> | string
    tournamentId?: StringNullableFilter<"Tournament"> | string | null
    type?: EnumTournamentTypeFilter<"Tournament"> | $Enums.TournamentType
    division?: IntNullableFilter<"Tournament"> | number | null
    status?: EnumTournamentStatusFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    registrationEndTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    entryFeeCredits?: BigIntNullableFilter<"Tournament"> | bigint | number | null
    entryFeeGems?: IntNullableFilter<"Tournament"> | number | null
    entryFeeItemId?: IntNullableFilter<"Tournament"> | number | null
    prizePoolJson?: JsonFilter<"Tournament">
    seasonDay?: IntNullableFilter<"Tournament"> | number | null
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    games?: GameListRelationFilter
    entries?: TournamentEntryListRelationFilter
  }

  export type TournamentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    type?: SortOrder
    division?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    registrationEndTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    entryFeeCredits?: SortOrderInput | SortOrder
    entryFeeGems?: SortOrderInput | SortOrder
    entryFeeItemId?: SortOrderInput | SortOrder
    prizePoolJson?: SortOrder
    seasonDay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    games?: GameOrderByRelationAggregateInput
    entries?: TournamentEntryOrderByRelationAggregateInput
  }

  export type TournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    name?: StringFilter<"Tournament"> | string
    tournamentId?: StringNullableFilter<"Tournament"> | string | null
    type?: EnumTournamentTypeFilter<"Tournament"> | $Enums.TournamentType
    division?: IntNullableFilter<"Tournament"> | number | null
    status?: EnumTournamentStatusFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    registrationEndTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    entryFeeCredits?: BigIntNullableFilter<"Tournament"> | bigint | number | null
    entryFeeGems?: IntNullableFilter<"Tournament"> | number | null
    entryFeeItemId?: IntNullableFilter<"Tournament"> | number | null
    prizePoolJson?: JsonFilter<"Tournament">
    seasonDay?: IntNullableFilter<"Tournament"> | number | null
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    games?: GameListRelationFilter
    entries?: TournamentEntryListRelationFilter
  }, "id">

  export type TournamentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    type?: SortOrder
    division?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    registrationEndTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    entryFeeCredits?: SortOrderInput | SortOrder
    entryFeeGems?: SortOrderInput | SortOrder
    entryFeeItemId?: SortOrderInput | SortOrder
    prizePoolJson?: SortOrder
    seasonDay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TournamentCountOrderByAggregateInput
    _avg?: TournamentAvgOrderByAggregateInput
    _max?: TournamentMaxOrderByAggregateInput
    _min?: TournamentMinOrderByAggregateInput
    _sum?: TournamentSumOrderByAggregateInput
  }

  export type TournamentScalarWhereWithAggregatesInput = {
    AND?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    OR?: TournamentScalarWhereWithAggregatesInput[]
    NOT?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tournament"> | number
    name?: StringWithAggregatesFilter<"Tournament"> | string
    tournamentId?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    type?: EnumTournamentTypeWithAggregatesFilter<"Tournament"> | $Enums.TournamentType
    division?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
    status?: EnumTournamentStatusWithAggregatesFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    registrationEndTime?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    entryFeeCredits?: BigIntNullableWithAggregatesFilter<"Tournament"> | bigint | number | null
    entryFeeGems?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
    entryFeeItemId?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
    prizePoolJson?: JsonWithAggregatesFilter<"Tournament">
    seasonDay?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
  }

  export type TournamentEntryWhereInput = {
    AND?: TournamentEntryWhereInput | TournamentEntryWhereInput[]
    OR?: TournamentEntryWhereInput[]
    NOT?: TournamentEntryWhereInput | TournamentEntryWhereInput[]
    id?: IntFilter<"TournamentEntry"> | number
    tournamentId?: IntFilter<"TournamentEntry"> | number
    teamId?: IntFilter<"TournamentEntry"> | number
    registeredAt?: DateTimeFilter<"TournamentEntry"> | Date | string
    finalRank?: IntNullableFilter<"TournamentEntry"> | number | null
    rewardsClaimed?: BoolFilter<"TournamentEntry"> | boolean
    tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TournamentEntryOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    registeredAt?: SortOrder
    finalRank?: SortOrderInput | SortOrder
    rewardsClaimed?: SortOrder
    tournament?: TournamentOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type TournamentEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tournamentId_teamId?: TournamentEntryTournamentIdTeamIdCompoundUniqueInput
    AND?: TournamentEntryWhereInput | TournamentEntryWhereInput[]
    OR?: TournamentEntryWhereInput[]
    NOT?: TournamentEntryWhereInput | TournamentEntryWhereInput[]
    tournamentId?: IntFilter<"TournamentEntry"> | number
    teamId?: IntFilter<"TournamentEntry"> | number
    registeredAt?: DateTimeFilter<"TournamentEntry"> | Date | string
    finalRank?: IntNullableFilter<"TournamentEntry"> | number | null
    rewardsClaimed?: BoolFilter<"TournamentEntry"> | boolean
    tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "tournamentId_teamId">

  export type TournamentEntryOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    registeredAt?: SortOrder
    finalRank?: SortOrderInput | SortOrder
    rewardsClaimed?: SortOrder
    _count?: TournamentEntryCountOrderByAggregateInput
    _avg?: TournamentEntryAvgOrderByAggregateInput
    _max?: TournamentEntryMaxOrderByAggregateInput
    _min?: TournamentEntryMinOrderByAggregateInput
    _sum?: TournamentEntrySumOrderByAggregateInput
  }

  export type TournamentEntryScalarWhereWithAggregatesInput = {
    AND?: TournamentEntryScalarWhereWithAggregatesInput | TournamentEntryScalarWhereWithAggregatesInput[]
    OR?: TournamentEntryScalarWhereWithAggregatesInput[]
    NOT?: TournamentEntryScalarWhereWithAggregatesInput | TournamentEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TournamentEntry"> | number
    tournamentId?: IntWithAggregatesFilter<"TournamentEntry"> | number
    teamId?: IntWithAggregatesFilter<"TournamentEntry"> | number
    registeredAt?: DateTimeWithAggregatesFilter<"TournamentEntry"> | Date | string
    finalRank?: IntNullableWithAggregatesFilter<"TournamentEntry"> | number | null
    rewardsClaimed?: BoolWithAggregatesFilter<"TournamentEntry"> | boolean
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: IntFilter<"PaymentTransaction"> | number
    userId?: StringFilter<"PaymentTransaction"> | string
    teamId?: IntFilter<"PaymentTransaction"> | number
    transactionType?: StringFilter<"PaymentTransaction"> | string
    itemName?: StringFilter<"PaymentTransaction"> | string
    itemType?: StringFilter<"PaymentTransaction"> | string
    creditsAmount?: BigIntFilter<"PaymentTransaction"> | bigint | number
    gemsAmount?: IntFilter<"PaymentTransaction"> | number
    status?: StringFilter<"PaymentTransaction"> | string
    metadata?: JsonNullableFilter<"PaymentTransaction">
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    transactionType?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    userId?: StringFilter<"PaymentTransaction"> | string
    teamId?: IntFilter<"PaymentTransaction"> | number
    transactionType?: StringFilter<"PaymentTransaction"> | string
    itemName?: StringFilter<"PaymentTransaction"> | string
    itemType?: StringFilter<"PaymentTransaction"> | string
    creditsAmount?: BigIntFilter<"PaymentTransaction"> | bigint | number
    gemsAmount?: IntFilter<"PaymentTransaction"> | number
    status?: StringFilter<"PaymentTransaction"> | string
    metadata?: JsonNullableFilter<"PaymentTransaction">
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
  }, "id">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    transactionType?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    userId?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    teamId?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    transactionType?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    itemName?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    itemType?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    creditsAmount?: BigIntWithAggregatesFilter<"PaymentTransaction"> | bigint | number
    gemsAmount?: IntWithAggregatesFilter<"PaymentTransaction"> | number
    status?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    metadata?: JsonNullableWithAggregatesFilter<"PaymentTransaction">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
  }

  export type UserProfileCreateInput = {
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamCreateNestedOneWithoutUserInput
    redeemedCodes?: RedeemCodeRecordCreateNestedManyWithoutUserProfileInput
    adRewardMilestone?: AdRewardMilestoneCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: number
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamUncheckedCreateNestedOneWithoutUserInput
    redeemedCodes?: RedeemCodeRecordUncheckedCreateNestedManyWithoutUserProfileInput
    adRewardMilestone?: AdRewardMilestoneUncheckedCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUpdateOneWithoutUserNestedInput
    redeemedCodes?: RedeemCodeRecordUpdateManyWithoutUserProfileNestedInput
    adRewardMilestone?: AdRewardMilestoneUpdateOneWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUncheckedUpdateOneWithoutUserNestedInput
    redeemedCodes?: RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    adRewardMilestone?: AdRewardMilestoneUncheckedUpdateOneWithoutUserProfileNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: number
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
  }

  export type UserProfileUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type SessionUncheckedCreateInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type SessionUpdateInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerCreateInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentCreateInput = {
    equippedAt?: Date | string
    player: PlayerCreateNestedOneWithoutCurrentEquipmentInput
    item: ItemCreateNestedOneWithoutPlayerEquipmentInput
  }

  export type PlayerEquipmentUncheckedCreateInput = {
    id?: number
    playerId: number
    itemId: number
    equippedAt?: Date | string
  }

  export type PlayerEquipmentUpdateInput = {
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCurrentEquipmentNestedInput
    item?: ItemUpdateOneRequiredWithoutPlayerEquipmentNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentCreateManyInput = {
    id?: number
    playerId: number
    itemId: number
    equippedAt?: Date | string
  }

  export type PlayerEquipmentUpdateManyMutationInput = {
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
    player?: PlayerCreateNestedOneWithoutContractInput
    staff?: StaffCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    playerId?: number | null
    staffId?: number | null
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
  }

  export type ContractUpdateInput = {
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutContractNestedInput
    staff?: StaffUpdateOneWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyInput = {
    id?: number
    playerId?: number | null
    staffId?: number | null
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonNullValueInput | InputJsonValue
    playerLinks?: PlayerSkillLinkCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonNullValueInput | InputJsonValue
    playerLinks?: PlayerSkillLinkUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
    playerLinks?: PlayerSkillLinkUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
    playerLinks?: PlayerSkillLinkUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonNullValueInput | InputJsonValue
  }

  export type SkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
  }

  export type PlayerSkillLinkCreateInput = {
    currentTier?: number
    acquiredAt?: Date | string
    player: PlayerCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutPlayerLinksInput
  }

  export type PlayerSkillLinkUncheckedCreateInput = {
    id?: number
    playerId: number
    skillId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type PlayerSkillLinkUpdateInput = {
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutPlayerLinksNestedInput
  }

  export type PlayerSkillLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkCreateManyInput = {
    id?: number
    playerId: number
    skillId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type PlayerSkillLinkUpdateManyMutationInput = {
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutStaffInput
    contract?: ContractCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: number
    teamId: number
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffUpdateInput = {
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutStaffNestedInput
    contract?: ContractUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: number
    teamId: number
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamFinancesCreateInput = {
    credits?: bigint | number
    gems?: number
    escrowCredits?: bigint | number
    escrowGems?: number
    projectedIncome?: bigint | number
    projectedExpenses?: bigint | number
    lastSeasonRevenue?: bigint | number
    lastSeasonExpenses?: bigint | number
    facilitiesMaintenanceCost?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutFinancesInput
  }

  export type TeamFinancesUncheckedCreateInput = {
    id?: number
    teamId: number
    credits?: bigint | number
    gems?: number
    escrowCredits?: bigint | number
    escrowGems?: number
    projectedIncome?: bigint | number
    projectedExpenses?: bigint | number
    lastSeasonRevenue?: bigint | number
    lastSeasonExpenses?: bigint | number
    facilitiesMaintenanceCost?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamFinancesUpdateInput = {
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutFinancesNestedInput
  }

  export type TeamFinancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamFinancesCreateManyInput = {
    id?: number
    teamId: number
    credits?: bigint | number
    gems?: number
    escrowCredits?: bigint | number
    escrowGems?: number
    projectedIncome?: bigint | number
    projectedExpenses?: bigint | number
    lastSeasonRevenue?: bigint | number
    lastSeasonExpenses?: bigint | number
    facilitiesMaintenanceCost?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamFinancesUpdateManyMutationInput = {
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamFinancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StadiumCreateInput = {
    capacity?: number
    concessionsLevel?: number
    parkingLevel?: number
    vipSuitesLevel?: number
    merchandisingLevel?: number
    lightingScreensLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutStadiumInput
  }

  export type StadiumUncheckedCreateInput = {
    id?: number
    teamId: number
    capacity?: number
    concessionsLevel?: number
    parkingLevel?: number
    vipSuitesLevel?: number
    merchandisingLevel?: number
    lightingScreensLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StadiumUpdateInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutStadiumNestedInput
  }

  export type StadiumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StadiumCreateManyInput = {
    id?: number
    teamId: number
    capacity?: number
    concessionsLevel?: number
    parkingLevel?: number
    vipSuitesLevel?: number
    merchandisingLevel?: number
    lightingScreensLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StadiumUpdateManyMutationInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StadiumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryItemCreateInput = {
    quantity: number
    acquiredAt?: Date | string
    team: TeamCreateNestedOneWithoutInventoryItemsInput
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: number
    teamId: number
    itemId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInventoryItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: number
    teamId: number
    itemId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostCreateInput = {
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
    team: TeamCreateNestedOneWithoutActiveBoostsInput
    player?: PlayerCreateNestedOneWithoutActiveBoostsInput
    item: ItemCreateNestedOneWithoutActiveBoostsInput
  }

  export type ActiveBoostUncheckedCreateInput = {
    id?: number
    teamId: number
    playerId?: number | null
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type ActiveBoostUpdateInput = {
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutActiveBoostsNestedInput
    player?: PlayerUpdateOneWithoutActiveBoostsNestedInput
    item?: ItemUpdateOneRequiredWithoutActiveBoostsNestedInput
  }

  export type ActiveBoostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostCreateManyInput = {
    id?: number
    teamId: number
    playerId?: number | null
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type ActiveBoostUpdateManyMutationInput = {
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingCreateInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketplaceListingInput
    sellerTeam: TeamCreateNestedOneWithoutMarketplaceListingsInput
    currentHighBidderTeam?: TeamCreateNestedOneWithoutHighBidderOnListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
    history?: ListingHistoryCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
    history?: ListingHistoryUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUpdateInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput
    sellerTeam?: TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput
    currentHighBidderTeam?: TeamUpdateOneWithoutHighBidderOnListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingCreateManyInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingUpdateManyMutationInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateInput = {
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutBidsInput
    bidderTeam: TeamCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateInput = {
    id?: number
    listingId: number
    bidderTeamId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type BidUpdateInput = {
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput
    bidderTeam?: TeamUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    bidderTeamId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyInput = {
    id?: number
    listingId: number
    bidderTeamId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type BidUpdateManyMutationInput = {
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    bidderTeamId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryCreateInput = {
    actionType: $Enums.ListingActionType
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutHistoryInput
    team?: TeamCreateNestedOneWithoutListingHistoryInput
  }

  export type ListingHistoryUncheckedCreateInput = {
    id?: number
    listingId: number
    actionType: $Enums.ListingActionType
    teamId?: number | null
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type ListingHistoryUpdateInput = {
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutHistoryNestedInput
    team?: TeamUpdateOneWithoutListingHistoryNestedInput
  }

  export type ListingHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryCreateManyInput = {
    id?: number
    listingId: number
    actionType: $Enums.ListingActionType
    teamId?: number | null
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type ListingHistoryUpdateManyMutationInput = {
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMarketValueCreateInput = {
    carRating: number
    potential: number
    minBuyNow: bigint | number
    marketValue: bigint | number
    lastUpdated?: Date | string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketValueInput
  }

  export type PlayerMarketValueUncheckedCreateInput = {
    id?: number
    playerId: number
    carRating: number
    potential: number
    minBuyNow: bigint | number
    marketValue: bigint | number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type PlayerMarketValueUpdateInput = {
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketValueNestedInput
  }

  export type PlayerMarketValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMarketValueCreateManyInput = {
    id?: number
    playerId: number
    carRating: number
    potential: number
    minBuyNow: bigint | number
    marketValue: bigint | number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type PlayerMarketValueUpdateManyMutationInput = {
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMarketValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyCreateInput = {
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutStrategyInput
  }

  export type StrategyUncheckedCreateInput = {
    id?: number
    teamId: number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyUpdateInput = {
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutStrategyNestedInput
  }

  export type StrategyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyCreateManyInput = {
    id?: number
    teamId: number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyUpdateManyMutationInput = {
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateInput = {
    division: number
    name: string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    schedule?: GameCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingCreateNestedManyWithoutLeagueInput
    season: SeasonCreateNestedOneWithoutLeaguesInput
  }

  export type LeagueUncheckedCreateInput = {
    id?: number
    division: number
    name: string
    seasonId: string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    schedule?: GameUncheckedCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUpdateInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    schedule?: GameUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUpdateManyWithoutLeagueNestedInput
    season?: SeasonUpdateOneRequiredWithoutLeaguesNestedInput
  }

  export type LeagueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    schedule?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateManyInput = {
    id?: number
    division: number
    name: string
    seasonId: string
  }

  export type LeagueUpdateManyMutationInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LeagueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
  }

  export type LeagueStandingCreateInput = {
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutStandingsInput
  }

  export type LeagueStandingUncheckedCreateInput = {
    id?: number
    leagueId: number
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
  }

  export type LeagueStandingUpdateInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutStandingsNestedInput
  }

  export type LeagueStandingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueStandingCreateManyInput = {
    id?: number
    leagueId: number
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
  }

  export type LeagueStandingUpdateManyMutationInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueStandingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutScheduleInput
    homeTeam: TeamCreateNestedOneWithoutHomeTeamGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayTeamGamesInput
    tournament?: TournamentCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameUpdateInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutScheduleNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeTeamGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayTeamGamesNestedInput
    tournament?: TournamentUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateManyInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    leagues?: LeagueCreateNestedManyWithoutSeasonInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    leagues?: LeagueUncheckedCreateNestedManyWithoutSeasonInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUpdateManyWithoutSeasonNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUncheckedUpdateManyWithoutSeasonNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
  }

  export type SeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    teamId: number
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    teamId: number
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TryoutPackCreateInput = {
    name: string
    description: string
    creditCost: bigint | number
    gemCost?: number | null
    numPlayers: number
    qualityTier: string
  }

  export type TryoutPackUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    creditCost: bigint | number
    gemCost?: number | null
    numPlayers: number
    qualityTier: string
  }

  export type TryoutPackUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creditCost?: BigIntFieldUpdateOperationsInput | bigint | number
    gemCost?: NullableIntFieldUpdateOperationsInput | number | null
    numPlayers?: IntFieldUpdateOperationsInput | number
    qualityTier?: StringFieldUpdateOperationsInput | string
  }

  export type TryoutPackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creditCost?: BigIntFieldUpdateOperationsInput | bigint | number
    gemCost?: NullableIntFieldUpdateOperationsInput | number | null
    numPlayers?: IntFieldUpdateOperationsInput | number
    qualityTier?: StringFieldUpdateOperationsInput | string
  }

  export type TryoutPackCreateManyInput = {
    id?: number
    name: string
    description: string
    creditCost: bigint | number
    gemCost?: number | null
    numPlayers: number
    qualityTier: string
  }

  export type TryoutPackUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creditCost?: BigIntFieldUpdateOperationsInput | bigint | number
    gemCost?: NullableIntFieldUpdateOperationsInput | number | null
    numPlayers?: IntFieldUpdateOperationsInput | number
    qualityTier?: StringFieldUpdateOperationsInput | string
  }

  export type TryoutPackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creditCost?: BigIntFieldUpdateOperationsInput | bigint | number
    gemCost?: NullableIntFieldUpdateOperationsInput | number | null
    numPlayers?: IntFieldUpdateOperationsInput | number
    qualityTier?: StringFieldUpdateOperationsInput | string
  }

  export type TryoutHistoryCreateInput = {
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    team: TeamCreateNestedOneWithoutTryoutHistoryInput
    season: SeasonCreateNestedOneWithoutTryoutHistoryInput
    player?: PlayerCreateNestedOneWithoutTryoutHistoryInput
  }

  export type TryoutHistoryUncheckedCreateInput = {
    id?: number
    teamId: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type TryoutHistoryUpdateInput = {
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTryoutHistoryNestedInput
    season?: SeasonUpdateOneRequiredWithoutTryoutHistoryNestedInput
    player?: PlayerUpdateOneWithoutTryoutHistoryNestedInput
  }

  export type TryoutHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TryoutHistoryCreateManyInput = {
    id?: number
    teamId: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type TryoutHistoryUpdateManyMutationInput = {
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TryoutHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GemPackCreateInput = {
    name: string
    gemAmount: number
    usdPrice: number
    productId: string
  }

  export type GemPackUncheckedCreateInput = {
    id?: number
    name: string
    gemAmount: number
    usdPrice: number
    productId: string
  }

  export type GemPackUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    gemAmount?: IntFieldUpdateOperationsInput | number
    usdPrice?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type GemPackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gemAmount?: IntFieldUpdateOperationsInput | number
    usdPrice?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type GemPackCreateManyInput = {
    id?: number
    name: string
    gemAmount: number
    usdPrice: number
    productId: string
  }

  export type GemPackUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    gemAmount?: IntFieldUpdateOperationsInput | number
    usdPrice?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type GemPackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gemAmount?: IntFieldUpdateOperationsInput | number
    usdPrice?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditExchangeRateCreateInput = {
    gems: number
    credits: bigint | number
    bonusPercentage?: number
  }

  export type CreditExchangeRateUncheckedCreateInput = {
    id?: number
    gems: number
    credits: bigint | number
    bonusPercentage?: number
  }

  export type CreditExchangeRateUpdateInput = {
    gems?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    bonusPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditExchangeRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    bonusPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditExchangeRateCreateManyInput = {
    id?: number
    gems: number
    credits: bigint | number
    bonusPercentage?: number
  }

  export type CreditExchangeRateUpdateManyMutationInput = {
    gems?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    bonusPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditExchangeRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    bonusPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type ReferralCreateInput = {
    referrerUserId: string
    referredUserId: string
    rewardGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralUncheckedCreateInput = {
    id?: number
    referrerUserId: string
    referredUserId: string
    rewardGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    referrerUserId?: StringFieldUpdateOperationsInput | string
    referredUserId?: StringFieldUpdateOperationsInput | string
    rewardGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerUserId?: StringFieldUpdateOperationsInput | string
    referredUserId?: StringFieldUpdateOperationsInput | string
    rewardGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: number
    referrerUserId: string
    referredUserId: string
    rewardGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    referrerUserId?: StringFieldUpdateOperationsInput | string
    referredUserId?: StringFieldUpdateOperationsInput | string
    rewardGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerUserId?: StringFieldUpdateOperationsInput | string
    referredUserId?: StringFieldUpdateOperationsInput | string
    rewardGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeCreateInput = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    expiryDate?: Date | string | null
    createdAt?: Date | string
    redeemedBy?: RedeemCodeRecordCreateNestedManyWithoutRedeemCodeInput
  }

  export type RedeemCodeUncheckedCreateInput = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    expiryDate?: Date | string | null
    createdAt?: Date | string
    redeemedBy?: RedeemCodeRecordUncheckedCreateNestedManyWithoutRedeemCodeInput
  }

  export type RedeemCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redeemedBy?: RedeemCodeRecordUpdateManyWithoutRedeemCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redeemedBy?: RedeemCodeRecordUncheckedUpdateManyWithoutRedeemCodeNestedInput
  }

  export type RedeemCodeCreateManyInput = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type RedeemCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeRecordCreateInput = {
    redeemedAt?: Date | string
    redeemCode: RedeemCodeCreateNestedOneWithoutRedeemedByInput
    userProfile: UserProfileCreateNestedOneWithoutRedeemedCodesInput
  }

  export type RedeemCodeRecordUncheckedCreateInput = {
    id?: number
    redeemCodeId: string
    userProfileId: number
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordUpdateInput = {
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redeemCode?: RedeemCodeUpdateOneRequiredWithoutRedeemedByNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutRedeemedCodesNestedInput
  }

  export type RedeemCodeRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    redeemCodeId?: StringFieldUpdateOperationsInput | string
    userProfileId?: IntFieldUpdateOperationsInput | number
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeRecordCreateManyInput = {
    id?: number
    redeemCodeId: string
    userProfileId: number
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordUpdateManyMutationInput = {
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    redeemCodeId?: StringFieldUpdateOperationsInput | string
    userProfileId?: IntFieldUpdateOperationsInput | number
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRewardMilestoneCreateInput = {
    totalAdsWatched?: number
    adsWatchedToday?: number
    lastAdWatchedAt?: Date | string | null
    userProfile: UserProfileCreateNestedOneWithoutAdRewardMilestoneInput
  }

  export type AdRewardMilestoneUncheckedCreateInput = {
    id?: number
    userProfileId: number
    totalAdsWatched?: number
    adsWatchedToday?: number
    lastAdWatchedAt?: Date | string | null
  }

  export type AdRewardMilestoneUpdateInput = {
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProfile?: UserProfileUpdateOneRequiredWithoutAdRewardMilestoneNestedInput
  }

  export type AdRewardMilestoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdRewardMilestoneCreateManyInput = {
    id?: number
    userProfileId: number
    totalAdsWatched?: number
    adsWatchedToday?: number
    lastAdWatchedAt?: Date | string | null
  }

  export type AdRewardMilestoneUpdateManyMutationInput = {
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdRewardMilestoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PremiumBoxRewardCreateInput = {
    category: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    weight: number
  }

  export type PremiumBoxRewardUncheckedCreateInput = {
    id?: number
    category: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    weight: number
  }

  export type PremiumBoxRewardUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type PremiumBoxRewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type PremiumBoxRewardCreateManyInput = {
    id?: number
    category: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    weight: number
  }

  export type PremiumBoxRewardUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type PremiumBoxRewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentRewardCreateInput = {
    boxId: number
    rarity: $Enums.ItemRarity
    weight: number
    item: ItemCreateNestedOneWithoutPremiumBoxRewardsInput
  }

  export type EquipmentRewardUncheckedCreateInput = {
    id?: number
    boxId: number
    itemId: number
    rarity: $Enums.ItemRarity
    weight: number
  }

  export type EquipmentRewardUpdateInput = {
    boxId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutPremiumBoxRewardsNestedInput
  }

  export type EquipmentRewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boxId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentRewardCreateManyInput = {
    id?: number
    boxId: number
    itemId: number
    rarity: $Enums.ItemRarity
    weight: number
  }

  export type EquipmentRewardUpdateManyMutationInput = {
    boxId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentRewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boxId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type TournamentCreateInput = {
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    games?: GameCreateNestedManyWithoutTournamentInput
    entries?: TournamentEntryCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    id?: number
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutTournamentInput
    entries?: TournamentEntryUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutTournamentNestedInput
    entries?: TournamentEntryUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutTournamentNestedInput
    entries?: TournamentEntryUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentCreateManyInput = {
    id?: number
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
  }

  export type TournamentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentEntryCreateInput = {
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
    tournament: TournamentCreateNestedOneWithoutEntriesInput
    team: TeamCreateNestedOneWithoutTournamentEntriesInput
  }

  export type TournamentEntryUncheckedCreateInput = {
    id?: number
    tournamentId: number
    teamId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type TournamentEntryUpdateInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
    tournament?: TournamentUpdateOneRequiredWithoutEntriesNestedInput
    team?: TeamUpdateOneRequiredWithoutTournamentEntriesNestedInput
  }

  export type TournamentEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tournamentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentEntryCreateManyInput = {
    id?: number
    tournamentId: number
    teamId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type TournamentEntryUpdateManyMutationInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tournamentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentTransactionCreateInput = {
    userId: string
    teamId: number
    transactionType: string
    itemName: string
    itemType: string
    creditsAmount?: bigint | number
    gemsAmount?: number
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: number
    userId: string
    teamId: number
    transactionType: string
    itemName: string
    itemType: string
    creditsAmount?: bigint | number
    gemsAmount?: number
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    transactionType?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    creditsAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    gemsAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    transactionType?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    creditsAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    gemsAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyInput = {
    id?: number
    userId: string
    teamId: number
    transactionType: string
    itemName: string
    itemType: string
    creditsAmount?: bigint | number
    gemsAmount?: number
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    transactionType?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    creditsAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    gemsAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    transactionType?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    creditsAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    gemsAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type RedeemCodeRecordListRelationFilter = {
    every?: RedeemCodeRecordWhereInput
    some?: RedeemCodeRecordWhereInput
    none?: RedeemCodeRecordWhereInput
  }

  export type AdRewardMilestoneNullableScalarRelationFilter = {
    is?: AdRewardMilestoneWhereInput | null
    isNot?: AdRewardMilestoneWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RedeemCodeRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    ndaAccepted?: SortOrder
    ndaAcceptedAt?: SortOrder
    ndaVersion?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    ndaAccepted?: SortOrder
    ndaAcceptedAt?: SortOrder
    ndaVersion?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    ndaAccepted?: SortOrder
    ndaAcceptedAt?: SortOrder
    ndaVersion?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SessionCountOrderByAggregateInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sid?: SortOrder
    expire?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sid?: SortOrder
    expire?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumFieldSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldSize | EnumFieldSizeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldSizeFilter<$PrismaModel> | $Enums.FieldSize
  }

  export type EnumTacticalFocusFilter<$PrismaModel = never> = {
    equals?: $Enums.TacticalFocus | EnumTacticalFocusFieldRefInput<$PrismaModel>
    in?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    not?: NestedEnumTacticalFocusFilter<$PrismaModel> | $Enums.TacticalFocus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserProfileScalarRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type TeamFinancesNullableScalarRelationFilter = {
    is?: TeamFinancesWhereInput | null
    isNot?: TeamFinancesWhereInput | null
  }

  export type StadiumNullableScalarRelationFilter = {
    is?: StadiumWhereInput | null
    isNot?: StadiumWhereInput | null
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type LeagueNullableScalarRelationFilter = {
    is?: LeagueWhereInput | null
    isNot?: LeagueWhereInput | null
  }

  export type ActiveBoostListRelationFilter = {
    every?: ActiveBoostWhereInput
    some?: ActiveBoostWhereInput
    none?: ActiveBoostWhereInput
  }

  export type StrategyNullableScalarRelationFilter = {
    is?: StrategyWhereInput | null
    isNot?: StrategyWhereInput | null
  }

  export type MarketplaceListingListRelationFilter = {
    every?: MarketplaceListingWhereInput
    some?: MarketplaceListingWhereInput
    none?: MarketplaceListingWhereInput
  }

  export type BidListRelationFilter = {
    every?: BidWhereInput
    some?: BidWhereInput
    none?: BidWhereInput
  }

  export type ListingHistoryListRelationFilter = {
    every?: ListingHistoryWhereInput
    some?: ListingHistoryWhereInput
    none?: ListingHistoryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type TournamentEntryListRelationFilter = {
    every?: TournamentEntryWhereInput
    some?: TournamentEntryWhereInput
    none?: TournamentEntryWhereInput
  }

  export type TryoutHistoryListRelationFilter = {
    every?: TryoutHistoryWhereInput
    some?: TryoutHistoryWhereInput
    none?: TryoutHistoryWhereInput
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActiveBoostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TryoutHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    isAI?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    homeField?: SortOrder
    tacticalFocus?: SortOrder
    leagueId?: SortOrder
    division?: SortOrder
    subdivision?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    leagueId?: SortOrder
    division?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    isAI?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    homeField?: SortOrder
    tacticalFocus?: SortOrder
    leagueId?: SortOrder
    division?: SortOrder
    subdivision?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    isAI?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    homeField?: SortOrder
    tacticalFocus?: SortOrder
    leagueId?: SortOrder
    division?: SortOrder
    subdivision?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    camaraderie?: SortOrder
    fanLoyalty?: SortOrder
    leagueId?: SortOrder
    division?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    points?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumFieldSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldSize | EnumFieldSizeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldSizeWithAggregatesFilter<$PrismaModel> | $Enums.FieldSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldSizeFilter<$PrismaModel>
    _max?: NestedEnumFieldSizeFilter<$PrismaModel>
  }

  export type EnumTacticalFocusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TacticalFocus | EnumTacticalFocusFieldRefInput<$PrismaModel>
    in?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    not?: NestedEnumTacticalFocusWithAggregatesFilter<$PrismaModel> | $Enums.TacticalFocus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTacticalFocusFilter<$PrismaModel>
    _max?: NestedEnumTacticalFocusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type EnumPlayerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRole | EnumPlayerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerRoleFilter<$PrismaModel> | $Enums.PlayerRole
  }

  export type EnumInjuryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusFilter<$PrismaModel> | $Enums.InjuryStatus
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type ContractNullableScalarRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type PlayerSkillLinkListRelationFilter = {
    every?: PlayerSkillLinkWhereInput
    some?: PlayerSkillLinkWhereInput
    none?: PlayerSkillLinkWhereInput
  }

  export type MarketplaceListingNullableScalarRelationFilter = {
    is?: MarketplaceListingWhereInput | null
    isNot?: MarketplaceListingWhereInput | null
  }

  export type PlayerMarketValueNullableScalarRelationFilter = {
    is?: PlayerMarketValueWhereInput | null
    isNot?: PlayerMarketValueWhereInput | null
  }

  export type PlayerEquipmentListRelationFilter = {
    every?: PlayerEquipmentWhereInput
    some?: PlayerEquipmentWhereInput
    none?: PlayerEquipmentWhereInput
  }

  export type PlayerSkillLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    race?: SortOrder
    age?: SortOrder
    role?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryStatus?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    isOnMarket?: SortOrder
    isRetired?: SortOrder
    camaraderieScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    age?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    camaraderieScore?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    race?: SortOrder
    age?: SortOrder
    role?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryStatus?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    isOnMarket?: SortOrder
    isRetired?: SortOrder
    camaraderieScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    race?: SortOrder
    age?: SortOrder
    role?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryStatus?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    isOnMarket?: SortOrder
    isRetired?: SortOrder
    camaraderieScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    age?: SortOrder
    speed?: SortOrder
    power?: SortOrder
    throwing?: SortOrder
    catching?: SortOrder
    kicking?: SortOrder
    staminaAttribute?: SortOrder
    leadership?: SortOrder
    agility?: SortOrder
    potentialRating?: SortOrder
    dailyStaminaLevel?: SortOrder
    injuryRecoveryPointsNeeded?: SortOrder
    injuryRecoveryPointsCurrent?: SortOrder
    dailyItemsUsed?: SortOrder
    careerInjuries?: SortOrder
    gamesPlayedLastSeason?: SortOrder
    seasonMinutesLeague?: SortOrder
    seasonMinutesTournament?: SortOrder
    seasonMinutesExhibition?: SortOrder
    seasonMinutesTotal?: SortOrder
    camaraderieScore?: SortOrder
  }

  export type EnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type EnumPlayerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRole | EnumPlayerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerRoleWithAggregatesFilter<$PrismaModel> | $Enums.PlayerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerRoleFilter<$PrismaModel>
    _max?: NestedEnumPlayerRoleFilter<$PrismaModel>
  }

  export type EnumInjuryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InjuryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryStatusFilter<$PrismaModel>
    _max?: NestedEnumInjuryStatusFilter<$PrismaModel>
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type PlayerEquipmentPlayerIdItemIdCompoundUniqueInput = {
    playerId: number
    itemId: number
  }

  export type PlayerEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    equippedAt?: SortOrder
  }

  export type PlayerEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
  }

  export type PlayerEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    equippedAt?: SortOrder
  }

  export type PlayerEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    equippedAt?: SortOrder
  }

  export type PlayerEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
  }

  export type PlayerNullableScalarRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    staffId?: SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
    startDate?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    staffId?: SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    staffId?: SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
    startDate?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    staffId?: SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
    startDate?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    staffId?: SortOrder
    salary?: SortOrder
    length?: SortOrder
    signingBonus?: SortOrder
  }

  export type EnumSkillTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeFilter<$PrismaModel> | $Enums.SkillType
  }

  export type EnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tiers?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSkillTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillTypeFilter<$PrismaModel>
  }

  export type EnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type PlayerSkillLinkPlayerIdSkillIdCompoundUniqueInput = {
    playerId: number
    skillId: number
  }

  export type PlayerSkillLinkCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
    acquiredAt?: SortOrder
  }

  export type PlayerSkillLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
  }

  export type PlayerSkillLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
    acquiredAt?: SortOrder
  }

  export type PlayerSkillLinkMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
    acquiredAt?: SortOrder
  }

  export type PlayerSkillLinkSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillId?: SortOrder
    currentTier?: SortOrder
  }

  export type EnumStaffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffTypeFilter<$PrismaModel> | $Enums.StaffType
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    level?: SortOrder
    motivation?: SortOrder
    development?: SortOrder
    teaching?: SortOrder
    physiology?: SortOrder
    talentIdentification?: SortOrder
    potentialAssessment?: SortOrder
    tactics?: SortOrder
    age?: SortOrder
  }

  export type EnumStaffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel> | $Enums.StaffType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffTypeFilter<$PrismaModel>
    _max?: NestedEnumStaffTypeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type TeamFinancesCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamFinancesAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
  }

  export type TeamFinancesMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamFinancesMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamFinancesSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    credits?: SortOrder
    gems?: SortOrder
    escrowCredits?: SortOrder
    escrowGems?: SortOrder
    projectedIncome?: SortOrder
    projectedExpenses?: SortOrder
    lastSeasonRevenue?: SortOrder
    lastSeasonExpenses?: SortOrder
    facilitiesMaintenanceCost?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StadiumCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StadiumAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
  }

  export type StadiumMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StadiumMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StadiumSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    capacity?: SortOrder
    concessionsLevel?: SortOrder
    parkingLevel?: SortOrder
    vipSuitesLevel?: SortOrder
    merchandisingLevel?: SortOrder
    lightingScreensLevel?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type EnumEquipmentSlotNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel> | $Enums.EquipmentSlot | null
  }

  export type EnumRaceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRaceNullableFilter<$PrismaModel> | $Enums.Race | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EquipmentRewardListRelationFilter = {
    every?: EquipmentRewardWhereInput
    some?: EquipmentRewardWhereInput
    none?: EquipmentRewardWhereInput
  }

  export type EquipmentRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    slot?: SortOrder
    raceRestriction?: SortOrder
    statEffects?: SortOrder
    rarity?: SortOrder
    creditPrice?: SortOrder
    gemPrice?: SortOrder
    effectValue?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    creditPrice?: SortOrder
    gemPrice?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    slot?: SortOrder
    raceRestriction?: SortOrder
    rarity?: SortOrder
    creditPrice?: SortOrder
    gemPrice?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    slot?: SortOrder
    raceRestriction?: SortOrder
    rarity?: SortOrder
    creditPrice?: SortOrder
    gemPrice?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    creditPrice?: SortOrder
    gemPrice?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type EnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentSlot | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
    _max?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
  }

  export type EnumRaceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Race | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRaceNullableFilter<$PrismaModel>
    _max?: NestedEnumRaceNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type InventoryItemTeamIdItemIdCompoundUniqueInput = {
    teamId: number
    itemId: number
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type ActiveBoostCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    matchType?: SortOrder
    isActive?: SortOrder
    appliedAt?: SortOrder
  }

  export type ActiveBoostAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
  }

  export type ActiveBoostMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    matchType?: SortOrder
    isActive?: SortOrder
    appliedAt?: SortOrder
  }

  export type ActiveBoostMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    matchType?: SortOrder
    isActive?: SortOrder
    appliedAt?: SortOrder
  }

  export type ActiveBoostSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
  }

  export type EnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type EnumMarketplaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceStatus | EnumMarketplaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceStatusFilter<$PrismaModel> | $Enums.MarketplaceStatus
  }

  export type MarketplaceListingCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrder
    currentHighBidderTeamId?: SortOrder
    expiryTimestamp?: SortOrder
    originalExpiryTimestamp?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
    listingStatus?: SortOrder
    isOffSeasonConverted?: SortOrder
    autoDelistAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrder
    currentHighBidderTeamId?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
  }

  export type MarketplaceListingMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrder
    currentHighBidderTeamId?: SortOrder
    expiryTimestamp?: SortOrder
    originalExpiryTimestamp?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
    listingStatus?: SortOrder
    isOffSeasonConverted?: SortOrder
    autoDelistAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrder
    currentHighBidderTeamId?: SortOrder
    expiryTimestamp?: SortOrder
    originalExpiryTimestamp?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
    listingStatus?: SortOrder
    isOffSeasonConverted?: SortOrder
    autoDelistAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    sellerTeamId?: SortOrder
    startBid?: SortOrder
    buyNowPrice?: SortOrder
    minBuyNowPrice?: SortOrder
    currentBid?: SortOrder
    currentHighBidderTeamId?: SortOrder
    auctionExtensions?: SortOrder
    listingFee?: SortOrder
    marketTaxRate?: SortOrder
    escrowAmount?: SortOrder
  }

  export type EnumMarketplaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceStatus | EnumMarketplaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceStatusFilter<$PrismaModel>
  }

  export type MarketplaceListingScalarRelationFilter = {
    is?: MarketplaceListingWhereInput
    isNot?: MarketplaceListingWhereInput
  }

  export type BidCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
    isWinningBid?: SortOrder
    isRefunded?: SortOrder
    placedAt?: SortOrder
  }

  export type BidAvgOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
  }

  export type BidMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
    isWinningBid?: SortOrder
    isRefunded?: SortOrder
    placedAt?: SortOrder
  }

  export type BidMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
    isWinningBid?: SortOrder
    isRefunded?: SortOrder
    placedAt?: SortOrder
  }

  export type BidSumOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    bidderTeamId?: SortOrder
    bidAmount?: SortOrder
    escrowAmount?: SortOrder
  }

  export type EnumListingActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingActionType | EnumListingActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingActionTypeFilter<$PrismaModel> | $Enums.ListingActionType
  }

  export type ListingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    actionType?: SortOrder
    teamId?: SortOrder
    amount?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type ListingHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    teamId?: SortOrder
    amount?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
  }

  export type ListingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    actionType?: SortOrder
    teamId?: SortOrder
    amount?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type ListingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    actionType?: SortOrder
    teamId?: SortOrder
    amount?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type ListingHistorySumOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    teamId?: SortOrder
    amount?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
  }

  export type EnumListingActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingActionType | EnumListingActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListingActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingActionTypeFilter<$PrismaModel>
    _max?: NestedEnumListingActionTypeFilter<$PrismaModel>
  }

  export type PlayerMarketValueCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMarketValueAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
  }

  export type PlayerMarketValueMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMarketValueMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMarketValueSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    carRating?: SortOrder
    potential?: SortOrder
    minBuyNow?: SortOrder
    marketValue?: SortOrder
  }

  export type StrategyCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    formationJson?: SortOrder
    substitutionJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type StrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategySumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type LeagueStandingListRelationFilter = {
    every?: LeagueStandingWhereInput
    some?: LeagueStandingWhereInput
    none?: LeagueStandingWhereInput
  }

  export type SeasonScalarRelationFilter = {
    is?: SeasonWhereInput
    isNot?: SeasonWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueStandingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueNameSeasonIdCompoundUniqueInput = {
    name: string
    seasonId: string
  }

  export type LeagueCountOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
    name?: SortOrder
    seasonId?: SortOrder
  }

  export type LeagueAvgOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
  }

  export type LeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
    name?: SortOrder
    seasonId?: SortOrder
  }

  export type LeagueMinOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
    name?: SortOrder
    seasonId?: SortOrder
  }

  export type LeagueSumOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
  }

  export type LeagueScalarRelationFilter = {
    is?: LeagueWhereInput
    isNot?: LeagueWhereInput
  }

  export type LeagueStandingLeagueIdTeamIdCompoundUniqueInput = {
    leagueId: number
    teamId: number
  }

  export type LeagueStandingCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    streak?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueStandingAvgOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    rank?: SortOrder
  }

  export type LeagueStandingMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    streak?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueStandingMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    teamName?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    streak?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueStandingSumOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    pointsFor?: SortOrder
    pointsAgainst?: SortOrder
    pointDifferential?: SortOrder
    rank?: SortOrder
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type TournamentNullableScalarRelationFilter = {
    is?: TournamentWhereInput | null
    isNot?: TournamentWhereInput | null
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    gameDate?: SortOrder
    simulated?: SortOrder
    simulationLog?: SortOrder
    matchType?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    gameDate?: SortOrder
    simulated?: SortOrder
    matchType?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    gameDate?: SortOrder
    simulated?: SortOrder
    matchType?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    tournamentId?: SortOrder
    round?: SortOrder
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type EnumSeasonPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonPhase | EnumSeasonPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumSeasonPhaseFilter<$PrismaModel> | $Enums.SeasonPhase
  }

  export type LeagueListRelationFilter = {
    every?: LeagueWhereInput
    some?: LeagueWhereInput
    none?: LeagueWhereInput
  }

  export type LeagueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    seasonNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentDay?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    seasonNumber?: SortOrder
    currentDay?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentDay?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    seasonNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentDay?: SortOrder
    phase?: SortOrder
    createdAt?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    seasonNumber?: SortOrder
    currentDay?: SortOrder
  }

  export type EnumSeasonPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonPhase | EnumSeasonPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumSeasonPhaseWithAggregatesFilter<$PrismaModel> | $Enums.SeasonPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeasonPhaseFilter<$PrismaModel>
    _max?: NestedEnumSeasonPhaseFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    linkTo?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    linkTo?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    linkTo?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type TryoutPackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrder
    numPlayers?: SortOrder
    qualityTier?: SortOrder
  }

  export type TryoutPackAvgOrderByAggregateInput = {
    id?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrder
    numPlayers?: SortOrder
  }

  export type TryoutPackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrder
    numPlayers?: SortOrder
    qualityTier?: SortOrder
  }

  export type TryoutPackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrder
    numPlayers?: SortOrder
    qualityTier?: SortOrder
  }

  export type TryoutPackSumOrderByAggregateInput = {
    id?: SortOrder
    creditCost?: SortOrder
    gemCost?: SortOrder
    numPlayers?: SortOrder
  }

  export type TryoutHistoryTeamIdSeasonIdCompoundUniqueInput = {
    teamId: number
    seasonId: string
  }

  export type TryoutHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    tryoutType?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    conductedAt?: SortOrder
    playerId?: SortOrder
  }

  export type TryoutHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    playerId?: SortOrder
  }

  export type TryoutHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    tryoutType?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    conductedAt?: SortOrder
    playerId?: SortOrder
  }

  export type TryoutHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    tryoutType?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    conductedAt?: SortOrder
    playerId?: SortOrder
  }

  export type TryoutHistorySumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    cost?: SortOrder
    playersAdded?: SortOrder
    playerId?: SortOrder
  }

  export type GemPackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
    productId?: SortOrder
  }

  export type GemPackAvgOrderByAggregateInput = {
    id?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
  }

  export type GemPackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
    productId?: SortOrder
  }

  export type GemPackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
    productId?: SortOrder
  }

  export type GemPackSumOrderByAggregateInput = {
    id?: SortOrder
    gemAmount?: SortOrder
    usdPrice?: SortOrder
  }

  export type CreditExchangeRateCountOrderByAggregateInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type CreditExchangeRateAvgOrderByAggregateInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type CreditExchangeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type CreditExchangeRateMinOrderByAggregateInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type CreditExchangeRateSumOrderByAggregateInput = {
    id?: SortOrder
    gems?: SortOrder
    credits?: SortOrder
    bonusPercentage?: SortOrder
  }

  export type ReferralReferrerUserIdReferredUserIdCompoundUniqueInput = {
    referrerUserId: string
    referredUserId: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerUserId?: SortOrder
    referredUserId?: SortOrder
    rewardGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerUserId?: SortOrder
    referredUserId?: SortOrder
    rewardGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerUserId?: SortOrder
    referredUserId?: SortOrder
    rewardGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type RedeemCodeCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type RedeemCodeAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    currentUses?: SortOrder
  }

  export type RedeemCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rewardType?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type RedeemCodeMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rewardType?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type RedeemCodeSumOrderByAggregateInput = {
    maxUses?: SortOrder
    currentUses?: SortOrder
  }

  export type EnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type RedeemCodeScalarRelationFilter = {
    is?: RedeemCodeWhereInput
    isNot?: RedeemCodeWhereInput
  }

  export type RedeemCodeRecordRedeemCodeIdUserProfileIdCompoundUniqueInput = {
    redeemCodeId: string
    userProfileId: number
  }

  export type RedeemCodeRecordCountOrderByAggregateInput = {
    id?: SortOrder
    redeemCodeId?: SortOrder
    userProfileId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type RedeemCodeRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
  }

  export type RedeemCodeRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    redeemCodeId?: SortOrder
    userProfileId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type RedeemCodeRecordMinOrderByAggregateInput = {
    id?: SortOrder
    redeemCodeId?: SortOrder
    userProfileId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type RedeemCodeRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
  }

  export type AdRewardMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
    lastAdWatchedAt?: SortOrder
  }

  export type AdRewardMilestoneAvgOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
  }

  export type AdRewardMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
    lastAdWatchedAt?: SortOrder
  }

  export type AdRewardMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
    lastAdWatchedAt?: SortOrder
  }

  export type AdRewardMilestoneSumOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    totalAdsWatched?: SortOrder
    adsWatchedToday?: SortOrder
  }

  export type PremiumBoxRewardCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    rewardType?: SortOrder
    rewardValue?: SortOrder
    weight?: SortOrder
  }

  export type PremiumBoxRewardAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
  }

  export type PremiumBoxRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    rewardType?: SortOrder
    weight?: SortOrder
  }

  export type PremiumBoxRewardMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    rewardType?: SortOrder
    weight?: SortOrder
  }

  export type PremiumBoxRewardSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
  }

  export type EquipmentRewardCountOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    rarity?: SortOrder
    weight?: SortOrder
  }

  export type EquipmentRewardAvgOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    weight?: SortOrder
  }

  export type EquipmentRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    rarity?: SortOrder
    weight?: SortOrder
  }

  export type EquipmentRewardMinOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    rarity?: SortOrder
    weight?: SortOrder
  }

  export type EquipmentRewardSumOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    itemId?: SortOrder
    weight?: SortOrder
  }

  export type EnumTournamentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentType | EnumTournamentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentTypeFilter<$PrismaModel> | $Enums.TournamentType
  }

  export type EnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type TournamentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tournamentId?: SortOrder
    type?: SortOrder
    division?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    registrationEndTime?: SortOrder
    endTime?: SortOrder
    entryFeeCredits?: SortOrder
    entryFeeGems?: SortOrder
    entryFeeItemId?: SortOrder
    prizePoolJson?: SortOrder
    seasonDay?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentAvgOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
    entryFeeCredits?: SortOrder
    entryFeeGems?: SortOrder
    entryFeeItemId?: SortOrder
    seasonDay?: SortOrder
  }

  export type TournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tournamentId?: SortOrder
    type?: SortOrder
    division?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    registrationEndTime?: SortOrder
    endTime?: SortOrder
    entryFeeCredits?: SortOrder
    entryFeeGems?: SortOrder
    entryFeeItemId?: SortOrder
    seasonDay?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tournamentId?: SortOrder
    type?: SortOrder
    division?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    registrationEndTime?: SortOrder
    endTime?: SortOrder
    entryFeeCredits?: SortOrder
    entryFeeGems?: SortOrder
    entryFeeItemId?: SortOrder
    seasonDay?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentSumOrderByAggregateInput = {
    id?: SortOrder
    division?: SortOrder
    entryFeeCredits?: SortOrder
    entryFeeGems?: SortOrder
    entryFeeItemId?: SortOrder
    seasonDay?: SortOrder
  }

  export type EnumTournamentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentType | EnumTournamentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TournamentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentTypeFilter<$PrismaModel>
    _max?: NestedEnumTournamentTypeFilter<$PrismaModel>
  }

  export type EnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type TournamentScalarRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type TournamentEntryTournamentIdTeamIdCompoundUniqueInput = {
    tournamentId: number
    teamId: number
  }

  export type TournamentEntryCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    registeredAt?: SortOrder
    finalRank?: SortOrder
    rewardsClaimed?: SortOrder
  }

  export type TournamentEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    finalRank?: SortOrder
  }

  export type TournamentEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    registeredAt?: SortOrder
    finalRank?: SortOrder
    rewardsClaimed?: SortOrder
  }

  export type TournamentEntryMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    registeredAt?: SortOrder
    finalRank?: SortOrder
    rewardsClaimed?: SortOrder
  }

  export type TournamentEntrySumOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
    finalRank?: SortOrder
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    transactionType?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    transactionType?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    transactionType?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    creditsAmount?: SortOrder
    gemsAmount?: SortOrder
  }

  export type TeamCreateNestedOneWithoutUserInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput
    connect?: TeamWhereUniqueInput
  }

  export type RedeemCodeRecordCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput> | RedeemCodeRecordCreateWithoutUserProfileInput[] | RedeemCodeRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutUserProfileInput | RedeemCodeRecordCreateOrConnectWithoutUserProfileInput[]
    createMany?: RedeemCodeRecordCreateManyUserProfileInputEnvelope
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
  }

  export type AdRewardMilestoneCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AdRewardMilestoneCreateOrConnectWithoutUserProfileInput
    connect?: AdRewardMilestoneWhereUniqueInput
  }

  export type TeamUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput
    connect?: TeamWhereUniqueInput
  }

  export type RedeemCodeRecordUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput> | RedeemCodeRecordCreateWithoutUserProfileInput[] | RedeemCodeRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutUserProfileInput | RedeemCodeRecordCreateOrConnectWithoutUserProfileInput[]
    createMany?: RedeemCodeRecordCreateManyUserProfileInputEnvelope
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
  }

  export type AdRewardMilestoneUncheckedCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AdRewardMilestoneCreateOrConnectWithoutUserProfileInput
    connect?: AdRewardMilestoneWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TeamUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput
    upsert?: TeamUpsertWithoutUserInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutUserInput, TeamUpdateWithoutUserInput>, TeamUncheckedUpdateWithoutUserInput>
  }

  export type RedeemCodeRecordUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput> | RedeemCodeRecordCreateWithoutUserProfileInput[] | RedeemCodeRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutUserProfileInput | RedeemCodeRecordCreateOrConnectWithoutUserProfileInput[]
    upsert?: RedeemCodeRecordUpsertWithWhereUniqueWithoutUserProfileInput | RedeemCodeRecordUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: RedeemCodeRecordCreateManyUserProfileInputEnvelope
    set?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    disconnect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    delete?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    update?: RedeemCodeRecordUpdateWithWhereUniqueWithoutUserProfileInput | RedeemCodeRecordUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: RedeemCodeRecordUpdateManyWithWhereWithoutUserProfileInput | RedeemCodeRecordUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
  }

  export type AdRewardMilestoneUpdateOneWithoutUserProfileNestedInput = {
    create?: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AdRewardMilestoneCreateOrConnectWithoutUserProfileInput
    upsert?: AdRewardMilestoneUpsertWithoutUserProfileInput
    disconnect?: AdRewardMilestoneWhereInput | boolean
    delete?: AdRewardMilestoneWhereInput | boolean
    connect?: AdRewardMilestoneWhereUniqueInput
    update?: XOR<XOR<AdRewardMilestoneUpdateToOneWithWhereWithoutUserProfileInput, AdRewardMilestoneUpdateWithoutUserProfileInput>, AdRewardMilestoneUncheckedUpdateWithoutUserProfileInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput
    upsert?: TeamUpsertWithoutUserInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutUserInput, TeamUpdateWithoutUserInput>, TeamUncheckedUpdateWithoutUserInput>
  }

  export type RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput> | RedeemCodeRecordCreateWithoutUserProfileInput[] | RedeemCodeRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutUserProfileInput | RedeemCodeRecordCreateOrConnectWithoutUserProfileInput[]
    upsert?: RedeemCodeRecordUpsertWithWhereUniqueWithoutUserProfileInput | RedeemCodeRecordUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: RedeemCodeRecordCreateManyUserProfileInputEnvelope
    set?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    disconnect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    delete?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    update?: RedeemCodeRecordUpdateWithWhereUniqueWithoutUserProfileInput | RedeemCodeRecordUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: RedeemCodeRecordUpdateManyWithWhereWithoutUserProfileInput | RedeemCodeRecordUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
  }

  export type AdRewardMilestoneUncheckedUpdateOneWithoutUserProfileNestedInput = {
    create?: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AdRewardMilestoneCreateOrConnectWithoutUserProfileInput
    upsert?: AdRewardMilestoneUpsertWithoutUserProfileInput
    disconnect?: AdRewardMilestoneWhereInput | boolean
    delete?: AdRewardMilestoneWhereInput | boolean
    connect?: AdRewardMilestoneWhereUniqueInput
    update?: XOR<XOR<AdRewardMilestoneUpdateToOneWithWhereWithoutUserProfileInput, AdRewardMilestoneUpdateWithoutUserProfileInput>, AdRewardMilestoneUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserProfileCreateNestedOneWithoutTeamInput = {
    create?: XOR<UserProfileCreateWithoutTeamInput, UserProfileUncheckedCreateWithoutTeamInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTeamInput
    connect?: UserProfileWhereUniqueInput
  }

  export type PlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutTeamInput = {
    create?: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput> | StaffCreateWithoutTeamInput[] | StaffUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTeamInput | StaffCreateOrConnectWithoutTeamInput[]
    createMany?: StaffCreateManyTeamInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type TeamFinancesCreateNestedOneWithoutTeamInput = {
    create?: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamFinancesCreateOrConnectWithoutTeamInput
    connect?: TeamFinancesWhereUniqueInput
  }

  export type StadiumCreateNestedOneWithoutTeamInput = {
    create?: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StadiumCreateOrConnectWithoutTeamInput
    connect?: StadiumWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutTeamInput = {
    create?: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput> | InventoryItemCreateWithoutTeamInput[] | InventoryItemUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTeamInput | InventoryItemCreateOrConnectWithoutTeamInput[]
    createMany?: InventoryItemCreateManyTeamInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type LeagueCreateNestedOneWithoutTeamsInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    connect?: LeagueWhereUniqueInput
  }

  export type ActiveBoostCreateNestedManyWithoutTeamInput = {
    create?: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput> | ActiveBoostCreateWithoutTeamInput[] | ActiveBoostUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutTeamInput | ActiveBoostCreateOrConnectWithoutTeamInput[]
    createMany?: ActiveBoostCreateManyTeamInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type StrategyCreateNestedOneWithoutTeamInput = {
    create?: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutTeamInput
    connect?: StrategyWhereUniqueInput
  }

  export type MarketplaceListingCreateNestedManyWithoutSellerTeamInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput> | MarketplaceListingCreateWithoutSellerTeamInput[] | MarketplaceListingUncheckedCreateWithoutSellerTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerTeamInput | MarketplaceListingCreateOrConnectWithoutSellerTeamInput[]
    createMany?: MarketplaceListingCreateManySellerTeamInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type BidCreateNestedManyWithoutBidderTeamInput = {
    create?: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput> | BidCreateWithoutBidderTeamInput[] | BidUncheckedCreateWithoutBidderTeamInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderTeamInput | BidCreateOrConnectWithoutBidderTeamInput[]
    createMany?: BidCreateManyBidderTeamInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput> | MarketplaceListingCreateWithoutCurrentHighBidderTeamInput[] | MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput | MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput[]
    createMany?: MarketplaceListingCreateManyCurrentHighBidderTeamInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type ListingHistoryCreateNestedManyWithoutTeamInput = {
    create?: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput> | ListingHistoryCreateWithoutTeamInput[] | ListingHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutTeamInput | ListingHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: ListingHistoryCreateManyTeamInputEnvelope
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTeamInput = {
    create?: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput> | NotificationCreateWithoutTeamInput[] | NotificationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeamInput | NotificationCreateOrConnectWithoutTeamInput[]
    createMany?: NotificationCreateManyTeamInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TournamentEntryCreateNestedManyWithoutTeamInput = {
    create?: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput> | TournamentEntryCreateWithoutTeamInput[] | TournamentEntryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTeamInput | TournamentEntryCreateOrConnectWithoutTeamInput[]
    createMany?: TournamentEntryCreateManyTeamInputEnvelope
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
  }

  export type TryoutHistoryCreateNestedManyWithoutTeamInput = {
    create?: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput> | TryoutHistoryCreateWithoutTeamInput[] | TryoutHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutTeamInput | TryoutHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: TryoutHistoryCreateManyTeamInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput> | StaffCreateWithoutTeamInput[] | StaffUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTeamInput | StaffCreateOrConnectWithoutTeamInput[]
    createMany?: StaffCreateManyTeamInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type TeamFinancesUncheckedCreateNestedOneWithoutTeamInput = {
    create?: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamFinancesCreateOrConnectWithoutTeamInput
    connect?: TeamFinancesWhereUniqueInput
  }

  export type StadiumUncheckedCreateNestedOneWithoutTeamInput = {
    create?: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StadiumCreateOrConnectWithoutTeamInput
    connect?: StadiumWhereUniqueInput
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput> | InventoryItemCreateWithoutTeamInput[] | InventoryItemUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTeamInput | InventoryItemCreateOrConnectWithoutTeamInput[]
    createMany?: InventoryItemCreateManyTeamInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ActiveBoostUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput> | ActiveBoostCreateWithoutTeamInput[] | ActiveBoostUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutTeamInput | ActiveBoostCreateOrConnectWithoutTeamInput[]
    createMany?: ActiveBoostCreateManyTeamInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type StrategyUncheckedCreateNestedOneWithoutTeamInput = {
    create?: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutTeamInput
    connect?: StrategyWhereUniqueInput
  }

  export type MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput> | MarketplaceListingCreateWithoutSellerTeamInput[] | MarketplaceListingUncheckedCreateWithoutSellerTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerTeamInput | MarketplaceListingCreateOrConnectWithoutSellerTeamInput[]
    createMany?: MarketplaceListingCreateManySellerTeamInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutBidderTeamInput = {
    create?: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput> | BidCreateWithoutBidderTeamInput[] | BidUncheckedCreateWithoutBidderTeamInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderTeamInput | BidCreateOrConnectWithoutBidderTeamInput[]
    createMany?: BidCreateManyBidderTeamInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput> | MarketplaceListingCreateWithoutCurrentHighBidderTeamInput[] | MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput | MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput[]
    createMany?: MarketplaceListingCreateManyCurrentHighBidderTeamInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type ListingHistoryUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput> | ListingHistoryCreateWithoutTeamInput[] | ListingHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutTeamInput | ListingHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: ListingHistoryCreateManyTeamInputEnvelope
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput> | NotificationCreateWithoutTeamInput[] | NotificationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeamInput | NotificationCreateOrConnectWithoutTeamInput[]
    createMany?: NotificationCreateManyTeamInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TournamentEntryUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput> | TournamentEntryCreateWithoutTeamInput[] | TournamentEntryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTeamInput | TournamentEntryCreateOrConnectWithoutTeamInput[]
    createMany?: TournamentEntryCreateManyTeamInputEnvelope
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
  }

  export type TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput> | TryoutHistoryCreateWithoutTeamInput[] | TryoutHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutTeamInput | TryoutHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: TryoutHistoryCreateManyTeamInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumFieldSizeFieldUpdateOperationsInput = {
    set?: $Enums.FieldSize
  }

  export type EnumTacticalFocusFieldUpdateOperationsInput = {
    set?: $Enums.TacticalFocus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<UserProfileCreateWithoutTeamInput, UserProfileUncheckedCreateWithoutTeamInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTeamInput
    upsert?: UserProfileUpsertWithoutTeamInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutTeamInput, UserProfileUpdateWithoutTeamInput>, UserProfileUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutTeamNestedInput = {
    create?: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput> | StaffCreateWithoutTeamInput[] | StaffUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTeamInput | StaffCreateOrConnectWithoutTeamInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutTeamInput | StaffUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: StaffCreateManyTeamInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutTeamInput | StaffUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutTeamInput | StaffUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type TeamFinancesUpdateOneWithoutTeamNestedInput = {
    create?: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamFinancesCreateOrConnectWithoutTeamInput
    upsert?: TeamFinancesUpsertWithoutTeamInput
    disconnect?: TeamFinancesWhereInput | boolean
    delete?: TeamFinancesWhereInput | boolean
    connect?: TeamFinancesWhereUniqueInput
    update?: XOR<XOR<TeamFinancesUpdateToOneWithWhereWithoutTeamInput, TeamFinancesUpdateWithoutTeamInput>, TeamFinancesUncheckedUpdateWithoutTeamInput>
  }

  export type StadiumUpdateOneWithoutTeamNestedInput = {
    create?: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StadiumCreateOrConnectWithoutTeamInput
    upsert?: StadiumUpsertWithoutTeamInput
    disconnect?: StadiumWhereInput | boolean
    delete?: StadiumWhereInput | boolean
    connect?: StadiumWhereUniqueInput
    update?: XOR<XOR<StadiumUpdateToOneWithWhereWithoutTeamInput, StadiumUpdateWithoutTeamInput>, StadiumUncheckedUpdateWithoutTeamInput>
  }

  export type InventoryItemUpdateManyWithoutTeamNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput> | InventoryItemCreateWithoutTeamInput[] | InventoryItemUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTeamInput | InventoryItemCreateOrConnectWithoutTeamInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTeamInput | InventoryItemUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: InventoryItemCreateManyTeamInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTeamInput | InventoryItemUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTeamInput | InventoryItemUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type LeagueUpdateOneWithoutTeamsNestedInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    upsert?: LeagueUpsertWithoutTeamsInput
    disconnect?: LeagueWhereInput | boolean
    delete?: LeagueWhereInput | boolean
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutTeamsInput, LeagueUpdateWithoutTeamsInput>, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type ActiveBoostUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput> | ActiveBoostCreateWithoutTeamInput[] | ActiveBoostUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutTeamInput | ActiveBoostCreateOrConnectWithoutTeamInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutTeamInput | ActiveBoostUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ActiveBoostCreateManyTeamInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutTeamInput | ActiveBoostUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutTeamInput | ActiveBoostUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type StrategyUpdateOneWithoutTeamNestedInput = {
    create?: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutTeamInput
    upsert?: StrategyUpsertWithoutTeamInput
    disconnect?: StrategyWhereInput | boolean
    delete?: StrategyWhereInput | boolean
    connect?: StrategyWhereUniqueInput
    update?: XOR<XOR<StrategyUpdateToOneWithWhereWithoutTeamInput, StrategyUpdateWithoutTeamInput>, StrategyUncheckedUpdateWithoutTeamInput>
  }

  export type MarketplaceListingUpdateManyWithoutSellerTeamNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput> | MarketplaceListingCreateWithoutSellerTeamInput[] | MarketplaceListingUncheckedCreateWithoutSellerTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerTeamInput | MarketplaceListingCreateOrConnectWithoutSellerTeamInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutSellerTeamInput | MarketplaceListingUpsertWithWhereUniqueWithoutSellerTeamInput[]
    createMany?: MarketplaceListingCreateManySellerTeamInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutSellerTeamInput | MarketplaceListingUpdateWithWhereUniqueWithoutSellerTeamInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutSellerTeamInput | MarketplaceListingUpdateManyWithWhereWithoutSellerTeamInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type BidUpdateManyWithoutBidderTeamNestedInput = {
    create?: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput> | BidCreateWithoutBidderTeamInput[] | BidUncheckedCreateWithoutBidderTeamInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderTeamInput | BidCreateOrConnectWithoutBidderTeamInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderTeamInput | BidUpsertWithWhereUniqueWithoutBidderTeamInput[]
    createMany?: BidCreateManyBidderTeamInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderTeamInput | BidUpdateWithWhereUniqueWithoutBidderTeamInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderTeamInput | BidUpdateManyWithWhereWithoutBidderTeamInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput> | MarketplaceListingCreateWithoutCurrentHighBidderTeamInput[] | MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput | MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutCurrentHighBidderTeamInput | MarketplaceListingUpsertWithWhereUniqueWithoutCurrentHighBidderTeamInput[]
    createMany?: MarketplaceListingCreateManyCurrentHighBidderTeamInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutCurrentHighBidderTeamInput | MarketplaceListingUpdateWithWhereUniqueWithoutCurrentHighBidderTeamInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutCurrentHighBidderTeamInput | MarketplaceListingUpdateManyWithWhereWithoutCurrentHighBidderTeamInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type ListingHistoryUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput> | ListingHistoryCreateWithoutTeamInput[] | ListingHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutTeamInput | ListingHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: ListingHistoryUpsertWithWhereUniqueWithoutTeamInput | ListingHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ListingHistoryCreateManyTeamInputEnvelope
    set?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    disconnect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    delete?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    update?: ListingHistoryUpdateWithWhereUniqueWithoutTeamInput | ListingHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ListingHistoryUpdateManyWithWhereWithoutTeamInput | ListingHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput> | NotificationCreateWithoutTeamInput[] | NotificationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeamInput | NotificationCreateOrConnectWithoutTeamInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTeamInput | NotificationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: NotificationCreateManyTeamInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTeamInput | NotificationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTeamInput | NotificationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TournamentEntryUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput> | TournamentEntryCreateWithoutTeamInput[] | TournamentEntryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTeamInput | TournamentEntryCreateOrConnectWithoutTeamInput[]
    upsert?: TournamentEntryUpsertWithWhereUniqueWithoutTeamInput | TournamentEntryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TournamentEntryCreateManyTeamInputEnvelope
    set?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    disconnect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    delete?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    update?: TournamentEntryUpdateWithWhereUniqueWithoutTeamInput | TournamentEntryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TournamentEntryUpdateManyWithWhereWithoutTeamInput | TournamentEntryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
  }

  export type TryoutHistoryUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput> | TryoutHistoryCreateWithoutTeamInput[] | TryoutHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutTeamInput | TryoutHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutTeamInput | TryoutHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TryoutHistoryCreateManyTeamInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutTeamInput | TryoutHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutTeamInput | TryoutHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type GameUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput> | StaffCreateWithoutTeamInput[] | StaffUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTeamInput | StaffCreateOrConnectWithoutTeamInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutTeamInput | StaffUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: StaffCreateManyTeamInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutTeamInput | StaffUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutTeamInput | StaffUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput = {
    create?: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamFinancesCreateOrConnectWithoutTeamInput
    upsert?: TeamFinancesUpsertWithoutTeamInput
    disconnect?: TeamFinancesWhereInput | boolean
    delete?: TeamFinancesWhereInput | boolean
    connect?: TeamFinancesWhereUniqueInput
    update?: XOR<XOR<TeamFinancesUpdateToOneWithWhereWithoutTeamInput, TeamFinancesUpdateWithoutTeamInput>, TeamFinancesUncheckedUpdateWithoutTeamInput>
  }

  export type StadiumUncheckedUpdateOneWithoutTeamNestedInput = {
    create?: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StadiumCreateOrConnectWithoutTeamInput
    upsert?: StadiumUpsertWithoutTeamInput
    disconnect?: StadiumWhereInput | boolean
    delete?: StadiumWhereInput | boolean
    connect?: StadiumWhereUniqueInput
    update?: XOR<XOR<StadiumUpdateToOneWithWhereWithoutTeamInput, StadiumUpdateWithoutTeamInput>, StadiumUncheckedUpdateWithoutTeamInput>
  }

  export type InventoryItemUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput> | InventoryItemCreateWithoutTeamInput[] | InventoryItemUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTeamInput | InventoryItemCreateOrConnectWithoutTeamInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTeamInput | InventoryItemUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: InventoryItemCreateManyTeamInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTeamInput | InventoryItemUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTeamInput | InventoryItemUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput> | ActiveBoostCreateWithoutTeamInput[] | ActiveBoostUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutTeamInput | ActiveBoostCreateOrConnectWithoutTeamInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutTeamInput | ActiveBoostUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ActiveBoostCreateManyTeamInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutTeamInput | ActiveBoostUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutTeamInput | ActiveBoostUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type StrategyUncheckedUpdateOneWithoutTeamNestedInput = {
    create?: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
    connectOrCreate?: StrategyCreateOrConnectWithoutTeamInput
    upsert?: StrategyUpsertWithoutTeamInput
    disconnect?: StrategyWhereInput | boolean
    delete?: StrategyWhereInput | boolean
    connect?: StrategyWhereUniqueInput
    update?: XOR<XOR<StrategyUpdateToOneWithWhereWithoutTeamInput, StrategyUpdateWithoutTeamInput>, StrategyUncheckedUpdateWithoutTeamInput>
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput> | MarketplaceListingCreateWithoutSellerTeamInput[] | MarketplaceListingUncheckedCreateWithoutSellerTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutSellerTeamInput | MarketplaceListingCreateOrConnectWithoutSellerTeamInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutSellerTeamInput | MarketplaceListingUpsertWithWhereUniqueWithoutSellerTeamInput[]
    createMany?: MarketplaceListingCreateManySellerTeamInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutSellerTeamInput | MarketplaceListingUpdateWithWhereUniqueWithoutSellerTeamInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutSellerTeamInput | MarketplaceListingUpdateManyWithWhereWithoutSellerTeamInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutBidderTeamNestedInput = {
    create?: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput> | BidCreateWithoutBidderTeamInput[] | BidUncheckedCreateWithoutBidderTeamInput[]
    connectOrCreate?: BidCreateOrConnectWithoutBidderTeamInput | BidCreateOrConnectWithoutBidderTeamInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutBidderTeamInput | BidUpsertWithWhereUniqueWithoutBidderTeamInput[]
    createMany?: BidCreateManyBidderTeamInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutBidderTeamInput | BidUpdateWithWhereUniqueWithoutBidderTeamInput[]
    updateMany?: BidUpdateManyWithWhereWithoutBidderTeamInput | BidUpdateManyWithWhereWithoutBidderTeamInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput> | MarketplaceListingCreateWithoutCurrentHighBidderTeamInput[] | MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput | MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutCurrentHighBidderTeamInput | MarketplaceListingUpsertWithWhereUniqueWithoutCurrentHighBidderTeamInput[]
    createMany?: MarketplaceListingCreateManyCurrentHighBidderTeamInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutCurrentHighBidderTeamInput | MarketplaceListingUpdateWithWhereUniqueWithoutCurrentHighBidderTeamInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutCurrentHighBidderTeamInput | MarketplaceListingUpdateManyWithWhereWithoutCurrentHighBidderTeamInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput> | ListingHistoryCreateWithoutTeamInput[] | ListingHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutTeamInput | ListingHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: ListingHistoryUpsertWithWhereUniqueWithoutTeamInput | ListingHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ListingHistoryCreateManyTeamInputEnvelope
    set?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    disconnect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    delete?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    update?: ListingHistoryUpdateWithWhereUniqueWithoutTeamInput | ListingHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ListingHistoryUpdateManyWithWhereWithoutTeamInput | ListingHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput> | NotificationCreateWithoutTeamInput[] | NotificationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeamInput | NotificationCreateOrConnectWithoutTeamInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTeamInput | NotificationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: NotificationCreateManyTeamInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTeamInput | NotificationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTeamInput | NotificationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput> | TournamentEntryCreateWithoutTeamInput[] | TournamentEntryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTeamInput | TournamentEntryCreateOrConnectWithoutTeamInput[]
    upsert?: TournamentEntryUpsertWithWhereUniqueWithoutTeamInput | TournamentEntryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TournamentEntryCreateManyTeamInputEnvelope
    set?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    disconnect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    delete?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    update?: TournamentEntryUpdateWithWhereUniqueWithoutTeamInput | TournamentEntryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TournamentEntryUpdateManyWithWhereWithoutTeamInput | TournamentEntryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput> | TryoutHistoryCreateWithoutTeamInput[] | TryoutHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutTeamInput | TryoutHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutTeamInput | TryoutHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TryoutHistoryCreateManyTeamInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutTeamInput | TryoutHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutTeamInput | TryoutHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutPlayersInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    connect?: TeamWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutPlayerInput = {
    create?: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPlayerInput
    connect?: ContractWhereUniqueInput
  }

  export type PlayerSkillLinkCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput> | PlayerSkillLinkCreateWithoutPlayerInput[] | PlayerSkillLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutPlayerInput | PlayerSkillLinkCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillLinkCreateManyPlayerInputEnvelope
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
  }

  export type MarketplaceListingCreateNestedOneWithoutPlayerInput = {
    create?: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutPlayerInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type PlayerMarketValueCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerMarketValueCreateOrConnectWithoutPlayerInput
    connect?: PlayerMarketValueWhereUniqueInput
  }

  export type TryoutHistoryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput> | TryoutHistoryCreateWithoutPlayerInput[] | TryoutHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutPlayerInput | TryoutHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: TryoutHistoryCreateManyPlayerInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type ActiveBoostCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput> | ActiveBoostCreateWithoutPlayerInput[] | ActiveBoostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutPlayerInput | ActiveBoostCreateOrConnectWithoutPlayerInput[]
    createMany?: ActiveBoostCreateManyPlayerInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type PlayerEquipmentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPlayerInput
    connect?: ContractWhereUniqueInput
  }

  export type PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput> | PlayerSkillLinkCreateWithoutPlayerInput[] | PlayerSkillLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutPlayerInput | PlayerSkillLinkCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillLinkCreateManyPlayerInputEnvelope
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutPlayerInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerMarketValueCreateOrConnectWithoutPlayerInput
    connect?: PlayerMarketValueWhereUniqueInput
  }

  export type TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput> | TryoutHistoryCreateWithoutPlayerInput[] | TryoutHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutPlayerInput | TryoutHistoryCreateOrConnectWithoutPlayerInput[]
    createMany?: TryoutHistoryCreateManyPlayerInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput> | ActiveBoostCreateWithoutPlayerInput[] | ActiveBoostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutPlayerInput | ActiveBoostCreateOrConnectWithoutPlayerInput[]
    createMany?: ActiveBoostCreateManyPlayerInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type EnumRaceFieldUpdateOperationsInput = {
    set?: $Enums.Race
  }

  export type EnumPlayerRoleFieldUpdateOperationsInput = {
    set?: $Enums.PlayerRole
  }

  export type EnumInjuryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InjuryStatus
  }

  export type TeamUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    upsert?: TeamUpsertWithoutPlayersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlayersInput, TeamUpdateWithoutPlayersInput>, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type ContractUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPlayerInput
    upsert?: ContractUpsertWithoutPlayerInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutPlayerInput, ContractUpdateWithoutPlayerInput>, ContractUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillLinkUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput> | PlayerSkillLinkCreateWithoutPlayerInput[] | PlayerSkillLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutPlayerInput | PlayerSkillLinkCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillLinkUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillLinkUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillLinkCreateManyPlayerInputEnvelope
    set?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    disconnect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    delete?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    update?: PlayerSkillLinkUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillLinkUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillLinkUpdateManyWithWhereWithoutPlayerInput | PlayerSkillLinkUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
  }

  export type MarketplaceListingUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutPlayerInput
    upsert?: MarketplaceListingUpsertWithoutPlayerInput
    disconnect?: MarketplaceListingWhereInput | boolean
    delete?: MarketplaceListingWhereInput | boolean
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutPlayerInput, MarketplaceListingUpdateWithoutPlayerInput>, MarketplaceListingUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerMarketValueUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerMarketValueCreateOrConnectWithoutPlayerInput
    upsert?: PlayerMarketValueUpsertWithoutPlayerInput
    disconnect?: PlayerMarketValueWhereInput | boolean
    delete?: PlayerMarketValueWhereInput | boolean
    connect?: PlayerMarketValueWhereUniqueInput
    update?: XOR<XOR<PlayerMarketValueUpdateToOneWithWhereWithoutPlayerInput, PlayerMarketValueUpdateWithoutPlayerInput>, PlayerMarketValueUncheckedUpdateWithoutPlayerInput>
  }

  export type TryoutHistoryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput> | TryoutHistoryCreateWithoutPlayerInput[] | TryoutHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutPlayerInput | TryoutHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutPlayerInput | TryoutHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TryoutHistoryCreateManyPlayerInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutPlayerInput | TryoutHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutPlayerInput | TryoutHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type ActiveBoostUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput> | ActiveBoostCreateWithoutPlayerInput[] | ActiveBoostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutPlayerInput | ActiveBoostCreateOrConnectWithoutPlayerInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutPlayerInput | ActiveBoostUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ActiveBoostCreateManyPlayerInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutPlayerInput | ActiveBoostUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutPlayerInput | ActiveBoostUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type PlayerEquipmentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput | PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPlayerInput
    upsert?: ContractUpsertWithoutPlayerInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutPlayerInput, ContractUpdateWithoutPlayerInput>, ContractUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput> | PlayerSkillLinkCreateWithoutPlayerInput[] | PlayerSkillLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutPlayerInput | PlayerSkillLinkCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillLinkUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillLinkUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillLinkCreateManyPlayerInputEnvelope
    set?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    disconnect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    delete?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    update?: PlayerSkillLinkUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillLinkUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillLinkUpdateManyWithWhereWithoutPlayerInput | PlayerSkillLinkUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutPlayerInput
    upsert?: MarketplaceListingUpsertWithoutPlayerInput
    disconnect?: MarketplaceListingWhereInput | boolean
    delete?: MarketplaceListingWhereInput | boolean
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutPlayerInput, MarketplaceListingUpdateWithoutPlayerInput>, MarketplaceListingUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerMarketValueCreateOrConnectWithoutPlayerInput
    upsert?: PlayerMarketValueUpsertWithoutPlayerInput
    disconnect?: PlayerMarketValueWhereInput | boolean
    delete?: PlayerMarketValueWhereInput | boolean
    connect?: PlayerMarketValueWhereUniqueInput
    update?: XOR<XOR<PlayerMarketValueUpdateToOneWithWhereWithoutPlayerInput, PlayerMarketValueUpdateWithoutPlayerInput>, PlayerMarketValueUncheckedUpdateWithoutPlayerInput>
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput> | TryoutHistoryCreateWithoutPlayerInput[] | TryoutHistoryUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutPlayerInput | TryoutHistoryCreateOrConnectWithoutPlayerInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutPlayerInput | TryoutHistoryUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TryoutHistoryCreateManyPlayerInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutPlayerInput | TryoutHistoryUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutPlayerInput | TryoutHistoryUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput> | ActiveBoostCreateWithoutPlayerInput[] | ActiveBoostUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutPlayerInput | ActiveBoostCreateOrConnectWithoutPlayerInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutPlayerInput | ActiveBoostUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ActiveBoostCreateManyPlayerInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutPlayerInput | ActiveBoostUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutPlayerInput | ActiveBoostUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput> | PlayerEquipmentCreateWithoutPlayerInput[] | PlayerEquipmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutPlayerInput | PlayerEquipmentCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEquipmentCreateManyPlayerInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput | PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput | PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutCurrentEquipmentInput = {
    create?: XOR<PlayerCreateWithoutCurrentEquipmentInput, PlayerUncheckedCreateWithoutCurrentEquipmentInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentEquipmentInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPlayerEquipmentInput = {
    create?: XOR<ItemCreateWithoutPlayerEquipmentInput, ItemUncheckedCreateWithoutPlayerEquipmentInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPlayerEquipmentInput
    connect?: ItemWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutCurrentEquipmentNestedInput = {
    create?: XOR<PlayerCreateWithoutCurrentEquipmentInput, PlayerUncheckedCreateWithoutCurrentEquipmentInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentEquipmentInput
    upsert?: PlayerUpsertWithoutCurrentEquipmentInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCurrentEquipmentInput, PlayerUpdateWithoutCurrentEquipmentInput>, PlayerUncheckedUpdateWithoutCurrentEquipmentInput>
  }

  export type ItemUpdateOneRequiredWithoutPlayerEquipmentNestedInput = {
    create?: XOR<ItemCreateWithoutPlayerEquipmentInput, ItemUncheckedCreateWithoutPlayerEquipmentInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPlayerEquipmentInput
    upsert?: ItemUpsertWithoutPlayerEquipmentInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPlayerEquipmentInput, ItemUpdateWithoutPlayerEquipmentInput>, ItemUncheckedUpdateWithoutPlayerEquipmentInput>
  }

  export type PlayerCreateNestedOneWithoutContractInput = {
    create?: XOR<PlayerCreateWithoutContractInput, PlayerUncheckedCreateWithoutContractInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutContractInput
    connect?: PlayerWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutContractInput = {
    create?: XOR<StaffCreateWithoutContractInput, StaffUncheckedCreateWithoutContractInput>
    connectOrCreate?: StaffCreateOrConnectWithoutContractInput
    connect?: StaffWhereUniqueInput
  }

  export type PlayerUpdateOneWithoutContractNestedInput = {
    create?: XOR<PlayerCreateWithoutContractInput, PlayerUncheckedCreateWithoutContractInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutContractInput
    upsert?: PlayerUpsertWithoutContractInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutContractInput, PlayerUpdateWithoutContractInput>, PlayerUncheckedUpdateWithoutContractInput>
  }

  export type StaffUpdateOneWithoutContractNestedInput = {
    create?: XOR<StaffCreateWithoutContractInput, StaffUncheckedCreateWithoutContractInput>
    connectOrCreate?: StaffCreateOrConnectWithoutContractInput
    upsert?: StaffUpsertWithoutContractInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutContractInput, StaffUpdateWithoutContractInput>, StaffUncheckedUpdateWithoutContractInput>
  }

  export type PlayerSkillLinkCreateNestedManyWithoutSkillInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput> | PlayerSkillLinkCreateWithoutSkillInput[] | PlayerSkillLinkUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutSkillInput | PlayerSkillLinkCreateOrConnectWithoutSkillInput[]
    createMany?: PlayerSkillLinkCreateManySkillInputEnvelope
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
  }

  export type PlayerSkillLinkUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput> | PlayerSkillLinkCreateWithoutSkillInput[] | PlayerSkillLinkUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutSkillInput | PlayerSkillLinkCreateOrConnectWithoutSkillInput[]
    createMany?: PlayerSkillLinkCreateManySkillInputEnvelope
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
  }

  export type EnumSkillTypeFieldUpdateOperationsInput = {
    set?: $Enums.SkillType
  }

  export type EnumSkillCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SkillCategory
  }

  export type PlayerSkillLinkUpdateManyWithoutSkillNestedInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput> | PlayerSkillLinkCreateWithoutSkillInput[] | PlayerSkillLinkUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutSkillInput | PlayerSkillLinkCreateOrConnectWithoutSkillInput[]
    upsert?: PlayerSkillLinkUpsertWithWhereUniqueWithoutSkillInput | PlayerSkillLinkUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: PlayerSkillLinkCreateManySkillInputEnvelope
    set?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    disconnect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    delete?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    update?: PlayerSkillLinkUpdateWithWhereUniqueWithoutSkillInput | PlayerSkillLinkUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: PlayerSkillLinkUpdateManyWithWhereWithoutSkillInput | PlayerSkillLinkUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
  }

  export type PlayerSkillLinkUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput> | PlayerSkillLinkCreateWithoutSkillInput[] | PlayerSkillLinkUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: PlayerSkillLinkCreateOrConnectWithoutSkillInput | PlayerSkillLinkCreateOrConnectWithoutSkillInput[]
    upsert?: PlayerSkillLinkUpsertWithWhereUniqueWithoutSkillInput | PlayerSkillLinkUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: PlayerSkillLinkCreateManySkillInputEnvelope
    set?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    disconnect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    delete?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    connect?: PlayerSkillLinkWhereUniqueInput | PlayerSkillLinkWhereUniqueInput[]
    update?: PlayerSkillLinkUpdateWithWhereUniqueWithoutSkillInput | PlayerSkillLinkUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: PlayerSkillLinkUpdateManyWithWhereWithoutSkillInput | PlayerSkillLinkUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutSkillsInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutPlayerLinksInput = {
    create?: XOR<SkillCreateWithoutPlayerLinksInput, SkillUncheckedCreateWithoutPlayerLinksInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPlayerLinksInput
    connect?: SkillWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    upsert?: PlayerUpsertWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSkillsInput, PlayerUpdateWithoutSkillsInput>, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutPlayerLinksNestedInput = {
    create?: XOR<SkillCreateWithoutPlayerLinksInput, SkillUncheckedCreateWithoutPlayerLinksInput>
    connectOrCreate?: SkillCreateOrConnectWithoutPlayerLinksInput
    upsert?: SkillUpsertWithoutPlayerLinksInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutPlayerLinksInput, SkillUpdateWithoutPlayerLinksInput>, SkillUncheckedUpdateWithoutPlayerLinksInput>
  }

  export type TeamCreateNestedOneWithoutStaffInput = {
    create?: XOR<TeamCreateWithoutStaffInput, TeamUncheckedCreateWithoutStaffInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStaffInput
    connect?: TeamWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutStaffInput = {
    create?: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ContractCreateOrConnectWithoutStaffInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUncheckedCreateNestedOneWithoutStaffInput = {
    create?: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ContractCreateOrConnectWithoutStaffInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumStaffTypeFieldUpdateOperationsInput = {
    set?: $Enums.StaffType
  }

  export type TeamUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<TeamCreateWithoutStaffInput, TeamUncheckedCreateWithoutStaffInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStaffInput
    upsert?: TeamUpsertWithoutStaffInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutStaffInput, TeamUpdateWithoutStaffInput>, TeamUncheckedUpdateWithoutStaffInput>
  }

  export type ContractUpdateOneWithoutStaffNestedInput = {
    create?: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ContractCreateOrConnectWithoutStaffInput
    upsert?: ContractUpsertWithoutStaffInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutStaffInput, ContractUpdateWithoutStaffInput>, ContractUncheckedUpdateWithoutStaffInput>
  }

  export type ContractUncheckedUpdateOneWithoutStaffNestedInput = {
    create?: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
    connectOrCreate?: ContractCreateOrConnectWithoutStaffInput
    upsert?: ContractUpsertWithoutStaffInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutStaffInput, ContractUpdateWithoutStaffInput>, ContractUncheckedUpdateWithoutStaffInput>
  }

  export type TeamCreateNestedOneWithoutFinancesInput = {
    create?: XOR<TeamCreateWithoutFinancesInput, TeamUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFinancesInput
    connect?: TeamWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type TeamUpdateOneRequiredWithoutFinancesNestedInput = {
    create?: XOR<TeamCreateWithoutFinancesInput, TeamUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFinancesInput
    upsert?: TeamUpsertWithoutFinancesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutFinancesInput, TeamUpdateWithoutFinancesInput>, TeamUncheckedUpdateWithoutFinancesInput>
  }

  export type TeamCreateNestedOneWithoutStadiumInput = {
    create?: XOR<TeamCreateWithoutStadiumInput, TeamUncheckedCreateWithoutStadiumInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStadiumInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutStadiumNestedInput = {
    create?: XOR<TeamCreateWithoutStadiumInput, TeamUncheckedCreateWithoutStadiumInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStadiumInput
    upsert?: TeamUpsertWithoutStadiumInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutStadiumInput, TeamUpdateWithoutStadiumInput>, TeamUncheckedUpdateWithoutStadiumInput>
  }

  export type InventoryItemCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ActiveBoostCreateNestedManyWithoutItemInput = {
    create?: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput> | ActiveBoostCreateWithoutItemInput[] | ActiveBoostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutItemInput | ActiveBoostCreateOrConnectWithoutItemInput[]
    createMany?: ActiveBoostCreateManyItemInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type PlayerEquipmentCreateNestedManyWithoutItemInput = {
    create?: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput> | PlayerEquipmentCreateWithoutItemInput[] | PlayerEquipmentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutItemInput | PlayerEquipmentCreateOrConnectWithoutItemInput[]
    createMany?: PlayerEquipmentCreateManyItemInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type EquipmentRewardCreateNestedManyWithoutItemInput = {
    create?: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput> | EquipmentRewardCreateWithoutItemInput[] | EquipmentRewardUncheckedCreateWithoutItemInput[]
    connectOrCreate?: EquipmentRewardCreateOrConnectWithoutItemInput | EquipmentRewardCreateOrConnectWithoutItemInput[]
    createMany?: EquipmentRewardCreateManyItemInputEnvelope
    connect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ActiveBoostUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput> | ActiveBoostCreateWithoutItemInput[] | ActiveBoostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutItemInput | ActiveBoostCreateOrConnectWithoutItemInput[]
    createMany?: ActiveBoostCreateManyItemInputEnvelope
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
  }

  export type PlayerEquipmentUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput> | PlayerEquipmentCreateWithoutItemInput[] | PlayerEquipmentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutItemInput | PlayerEquipmentCreateOrConnectWithoutItemInput[]
    createMany?: PlayerEquipmentCreateManyItemInputEnvelope
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
  }

  export type EquipmentRewardUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput> | EquipmentRewardCreateWithoutItemInput[] | EquipmentRewardUncheckedCreateWithoutItemInput[]
    connectOrCreate?: EquipmentRewardCreateOrConnectWithoutItemInput | EquipmentRewardCreateOrConnectWithoutItemInput[]
    createMany?: EquipmentRewardCreateManyItemInputEnvelope
    connect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type NullableEnumEquipmentSlotFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentSlot | null
  }

  export type NullableEnumRaceFieldUpdateOperationsInput = {
    set?: $Enums.Race | null
  }

  export type EnumItemRarityFieldUpdateOperationsInput = {
    set?: $Enums.ItemRarity
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type InventoryItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ActiveBoostUpdateManyWithoutItemNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput> | ActiveBoostCreateWithoutItemInput[] | ActiveBoostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutItemInput | ActiveBoostCreateOrConnectWithoutItemInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutItemInput | ActiveBoostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ActiveBoostCreateManyItemInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutItemInput | ActiveBoostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutItemInput | ActiveBoostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type PlayerEquipmentUpdateManyWithoutItemNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput> | PlayerEquipmentCreateWithoutItemInput[] | PlayerEquipmentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutItemInput | PlayerEquipmentCreateOrConnectWithoutItemInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutItemInput | PlayerEquipmentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PlayerEquipmentCreateManyItemInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutItemInput | PlayerEquipmentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutItemInput | PlayerEquipmentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type EquipmentRewardUpdateManyWithoutItemNestedInput = {
    create?: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput> | EquipmentRewardCreateWithoutItemInput[] | EquipmentRewardUncheckedCreateWithoutItemInput[]
    connectOrCreate?: EquipmentRewardCreateOrConnectWithoutItemInput | EquipmentRewardCreateOrConnectWithoutItemInput[]
    upsert?: EquipmentRewardUpsertWithWhereUniqueWithoutItemInput | EquipmentRewardUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: EquipmentRewardCreateManyItemInputEnvelope
    set?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    disconnect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    delete?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    connect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    update?: EquipmentRewardUpdateWithWhereUniqueWithoutItemInput | EquipmentRewardUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: EquipmentRewardUpdateManyWithWhereWithoutItemInput | EquipmentRewardUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: EquipmentRewardScalarWhereInput | EquipmentRewardScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ActiveBoostUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput> | ActiveBoostCreateWithoutItemInput[] | ActiveBoostUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ActiveBoostCreateOrConnectWithoutItemInput | ActiveBoostCreateOrConnectWithoutItemInput[]
    upsert?: ActiveBoostUpsertWithWhereUniqueWithoutItemInput | ActiveBoostUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ActiveBoostCreateManyItemInputEnvelope
    set?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    disconnect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    delete?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    connect?: ActiveBoostWhereUniqueInput | ActiveBoostWhereUniqueInput[]
    update?: ActiveBoostUpdateWithWhereUniqueWithoutItemInput | ActiveBoostUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ActiveBoostUpdateManyWithWhereWithoutItemInput | ActiveBoostUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput> | PlayerEquipmentCreateWithoutItemInput[] | PlayerEquipmentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerEquipmentCreateOrConnectWithoutItemInput | PlayerEquipmentCreateOrConnectWithoutItemInput[]
    upsert?: PlayerEquipmentUpsertWithWhereUniqueWithoutItemInput | PlayerEquipmentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PlayerEquipmentCreateManyItemInputEnvelope
    set?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    disconnect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    delete?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    connect?: PlayerEquipmentWhereUniqueInput | PlayerEquipmentWhereUniqueInput[]
    update?: PlayerEquipmentUpdateWithWhereUniqueWithoutItemInput | PlayerEquipmentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PlayerEquipmentUpdateManyWithWhereWithoutItemInput | PlayerEquipmentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
  }

  export type EquipmentRewardUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput> | EquipmentRewardCreateWithoutItemInput[] | EquipmentRewardUncheckedCreateWithoutItemInput[]
    connectOrCreate?: EquipmentRewardCreateOrConnectWithoutItemInput | EquipmentRewardCreateOrConnectWithoutItemInput[]
    upsert?: EquipmentRewardUpsertWithWhereUniqueWithoutItemInput | EquipmentRewardUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: EquipmentRewardCreateManyItemInputEnvelope
    set?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    disconnect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    delete?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    connect?: EquipmentRewardWhereUniqueInput | EquipmentRewardWhereUniqueInput[]
    update?: EquipmentRewardUpdateWithWhereUniqueWithoutItemInput | EquipmentRewardUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: EquipmentRewardUpdateManyWithWhereWithoutItemInput | EquipmentRewardUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: EquipmentRewardScalarWhereInput | EquipmentRewardScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<TeamCreateWithoutInventoryItemsInput, TeamUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInventoryItemsInput
    connect?: TeamWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<TeamCreateWithoutInventoryItemsInput, TeamUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInventoryItemsInput
    upsert?: TeamUpsertWithoutInventoryItemsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutInventoryItemsInput, TeamUpdateWithoutInventoryItemsInput>, TeamUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    upsert?: ItemUpsertWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryItemsInput, ItemUpdateWithoutInventoryItemsInput>, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type TeamCreateNestedOneWithoutActiveBoostsInput = {
    create?: XOR<TeamCreateWithoutActiveBoostsInput, TeamUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutActiveBoostsInput
    connect?: TeamWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutActiveBoostsInput = {
    create?: XOR<PlayerCreateWithoutActiveBoostsInput, PlayerUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutActiveBoostsInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutActiveBoostsInput = {
    create?: XOR<ItemCreateWithoutActiveBoostsInput, ItemUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutActiveBoostsInput
    connect?: ItemWhereUniqueInput
  }

  export type EnumMatchTypeFieldUpdateOperationsInput = {
    set?: $Enums.MatchType
  }

  export type TeamUpdateOneRequiredWithoutActiveBoostsNestedInput = {
    create?: XOR<TeamCreateWithoutActiveBoostsInput, TeamUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutActiveBoostsInput
    upsert?: TeamUpsertWithoutActiveBoostsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutActiveBoostsInput, TeamUpdateWithoutActiveBoostsInput>, TeamUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type PlayerUpdateOneWithoutActiveBoostsNestedInput = {
    create?: XOR<PlayerCreateWithoutActiveBoostsInput, PlayerUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutActiveBoostsInput
    upsert?: PlayerUpsertWithoutActiveBoostsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutActiveBoostsInput, PlayerUpdateWithoutActiveBoostsInput>, PlayerUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type ItemUpdateOneRequiredWithoutActiveBoostsNestedInput = {
    create?: XOR<ItemCreateWithoutActiveBoostsInput, ItemUncheckedCreateWithoutActiveBoostsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutActiveBoostsInput
    upsert?: ItemUpsertWithoutActiveBoostsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutActiveBoostsInput, ItemUpdateWithoutActiveBoostsInput>, ItemUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type PlayerCreateNestedOneWithoutMarketplaceListingInput = {
    create?: XOR<PlayerCreateWithoutMarketplaceListingInput, PlayerUncheckedCreateWithoutMarketplaceListingInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketplaceListingInput
    connect?: PlayerWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMarketplaceListingsInput = {
    create?: XOR<TeamCreateWithoutMarketplaceListingsInput, TeamUncheckedCreateWithoutMarketplaceListingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMarketplaceListingsInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutHighBidderOnListingsInput = {
    create?: XOR<TeamCreateWithoutHighBidderOnListingsInput, TeamUncheckedCreateWithoutHighBidderOnListingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHighBidderOnListingsInput
    connect?: TeamWhereUniqueInput
  }

  export type BidCreateNestedManyWithoutListingInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type ListingHistoryCreateNestedManyWithoutListingInput = {
    create?: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput> | ListingHistoryCreateWithoutListingInput[] | ListingHistoryUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutListingInput | ListingHistoryCreateOrConnectWithoutListingInput[]
    createMany?: ListingHistoryCreateManyListingInputEnvelope
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type ListingHistoryUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput> | ListingHistoryCreateWithoutListingInput[] | ListingHistoryUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutListingInput | ListingHistoryCreateOrConnectWithoutListingInput[]
    createMany?: ListingHistoryCreateManyListingInputEnvelope
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
  }

  export type EnumMarketplaceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MarketplaceStatus
  }

  export type PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput = {
    create?: XOR<PlayerCreateWithoutMarketplaceListingInput, PlayerUncheckedCreateWithoutMarketplaceListingInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketplaceListingInput
    upsert?: PlayerUpsertWithoutMarketplaceListingInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMarketplaceListingInput, PlayerUpdateWithoutMarketplaceListingInput>, PlayerUncheckedUpdateWithoutMarketplaceListingInput>
  }

  export type TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput = {
    create?: XOR<TeamCreateWithoutMarketplaceListingsInput, TeamUncheckedCreateWithoutMarketplaceListingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMarketplaceListingsInput
    upsert?: TeamUpsertWithoutMarketplaceListingsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMarketplaceListingsInput, TeamUpdateWithoutMarketplaceListingsInput>, TeamUncheckedUpdateWithoutMarketplaceListingsInput>
  }

  export type TeamUpdateOneWithoutHighBidderOnListingsNestedInput = {
    create?: XOR<TeamCreateWithoutHighBidderOnListingsInput, TeamUncheckedCreateWithoutHighBidderOnListingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHighBidderOnListingsInput
    upsert?: TeamUpsertWithoutHighBidderOnListingsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutHighBidderOnListingsInput, TeamUpdateWithoutHighBidderOnListingsInput>, TeamUncheckedUpdateWithoutHighBidderOnListingsInput>
  }

  export type BidUpdateManyWithoutListingNestedInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutListingInput | BidUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutListingInput | BidUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BidUpdateManyWithWhereWithoutListingInput | BidUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type ListingHistoryUpdateManyWithoutListingNestedInput = {
    create?: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput> | ListingHistoryCreateWithoutListingInput[] | ListingHistoryUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutListingInput | ListingHistoryCreateOrConnectWithoutListingInput[]
    upsert?: ListingHistoryUpsertWithWhereUniqueWithoutListingInput | ListingHistoryUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ListingHistoryCreateManyListingInputEnvelope
    set?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    disconnect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    delete?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    update?: ListingHistoryUpdateWithWhereUniqueWithoutListingInput | ListingHistoryUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ListingHistoryUpdateManyWithWhereWithoutListingInput | ListingHistoryUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput> | BidCreateWithoutListingInput[] | BidUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BidCreateOrConnectWithoutListingInput | BidCreateOrConnectWithoutListingInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutListingInput | BidUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BidCreateManyListingInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutListingInput | BidUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BidUpdateManyWithWhereWithoutListingInput | BidUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type ListingHistoryUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput> | ListingHistoryCreateWithoutListingInput[] | ListingHistoryUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ListingHistoryCreateOrConnectWithoutListingInput | ListingHistoryCreateOrConnectWithoutListingInput[]
    upsert?: ListingHistoryUpsertWithWhereUniqueWithoutListingInput | ListingHistoryUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ListingHistoryCreateManyListingInputEnvelope
    set?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    disconnect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    delete?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    connect?: ListingHistoryWhereUniqueInput | ListingHistoryWhereUniqueInput[]
    update?: ListingHistoryUpdateWithWhereUniqueWithoutListingInput | ListingHistoryUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ListingHistoryUpdateManyWithWhereWithoutListingInput | ListingHistoryUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
  }

  export type MarketplaceListingCreateNestedOneWithoutBidsInput = {
    create?: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutBidsInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutBidsInput = {
    create?: XOR<TeamCreateWithoutBidsInput, TeamUncheckedCreateWithoutBidsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBidsInput
    connect?: TeamWhereUniqueInput
  }

  export type MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutBidsInput
    upsert?: MarketplaceListingUpsertWithoutBidsInput
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutBidsInput, MarketplaceListingUpdateWithoutBidsInput>, MarketplaceListingUncheckedUpdateWithoutBidsInput>
  }

  export type TeamUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<TeamCreateWithoutBidsInput, TeamUncheckedCreateWithoutBidsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBidsInput
    upsert?: TeamUpsertWithoutBidsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutBidsInput, TeamUpdateWithoutBidsInput>, TeamUncheckedUpdateWithoutBidsInput>
  }

  export type MarketplaceListingCreateNestedOneWithoutHistoryInput = {
    create?: XOR<MarketplaceListingCreateWithoutHistoryInput, MarketplaceListingUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutHistoryInput
    connect?: MarketplaceListingWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutListingHistoryInput = {
    create?: XOR<TeamCreateWithoutListingHistoryInput, TeamUncheckedCreateWithoutListingHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutListingHistoryInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumListingActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ListingActionType
  }

  export type MarketplaceListingUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutHistoryInput, MarketplaceListingUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutHistoryInput
    upsert?: MarketplaceListingUpsertWithoutHistoryInput
    connect?: MarketplaceListingWhereUniqueInput
    update?: XOR<XOR<MarketplaceListingUpdateToOneWithWhereWithoutHistoryInput, MarketplaceListingUpdateWithoutHistoryInput>, MarketplaceListingUncheckedUpdateWithoutHistoryInput>
  }

  export type TeamUpdateOneWithoutListingHistoryNestedInput = {
    create?: XOR<TeamCreateWithoutListingHistoryInput, TeamUncheckedCreateWithoutListingHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutListingHistoryInput
    upsert?: TeamUpsertWithoutListingHistoryInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutListingHistoryInput, TeamUpdateWithoutListingHistoryInput>, TeamUncheckedUpdateWithoutListingHistoryInput>
  }

  export type PlayerCreateNestedOneWithoutMarketValueInput = {
    create?: XOR<PlayerCreateWithoutMarketValueInput, PlayerUncheckedCreateWithoutMarketValueInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketValueInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMarketValueNestedInput = {
    create?: XOR<PlayerCreateWithoutMarketValueInput, PlayerUncheckedCreateWithoutMarketValueInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketValueInput
    upsert?: PlayerUpsertWithoutMarketValueInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMarketValueInput, PlayerUpdateWithoutMarketValueInput>, PlayerUncheckedUpdateWithoutMarketValueInput>
  }

  export type TeamCreateNestedOneWithoutStrategyInput = {
    create?: XOR<TeamCreateWithoutStrategyInput, TeamUncheckedCreateWithoutStrategyInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStrategyInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutStrategyNestedInput = {
    create?: XOR<TeamCreateWithoutStrategyInput, TeamUncheckedCreateWithoutStrategyInput>
    connectOrCreate?: TeamCreateOrConnectWithoutStrategyInput
    upsert?: TeamUpsertWithoutStrategyInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutStrategyInput, TeamUpdateWithoutStrategyInput>, TeamUncheckedUpdateWithoutStrategyInput>
  }

  export type TeamCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type LeagueStandingCreateNestedManyWithoutLeagueInput = {
    create?: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput> | LeagueStandingCreateWithoutLeagueInput[] | LeagueStandingUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: LeagueStandingCreateOrConnectWithoutLeagueInput | LeagueStandingCreateOrConnectWithoutLeagueInput[]
    createMany?: LeagueStandingCreateManyLeagueInputEnvelope
    connect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
  }

  export type SeasonCreateNestedOneWithoutLeaguesInput = {
    create?: XOR<SeasonCreateWithoutLeaguesInput, SeasonUncheckedCreateWithoutLeaguesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutLeaguesInput
    connect?: SeasonWhereUniqueInput
  }

  export type TeamUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type LeagueStandingUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput> | LeagueStandingCreateWithoutLeagueInput[] | LeagueStandingUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: LeagueStandingCreateOrConnectWithoutLeagueInput | LeagueStandingCreateOrConnectWithoutLeagueInput[]
    createMany?: LeagueStandingCreateManyLeagueInputEnvelope
    connect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
  }

  export type TeamUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type GameUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type LeagueStandingUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput> | LeagueStandingCreateWithoutLeagueInput[] | LeagueStandingUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: LeagueStandingCreateOrConnectWithoutLeagueInput | LeagueStandingCreateOrConnectWithoutLeagueInput[]
    upsert?: LeagueStandingUpsertWithWhereUniqueWithoutLeagueInput | LeagueStandingUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: LeagueStandingCreateManyLeagueInputEnvelope
    set?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    disconnect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    delete?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    connect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    update?: LeagueStandingUpdateWithWhereUniqueWithoutLeagueInput | LeagueStandingUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: LeagueStandingUpdateManyWithWhereWithoutLeagueInput | LeagueStandingUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: LeagueStandingScalarWhereInput | LeagueStandingScalarWhereInput[]
  }

  export type SeasonUpdateOneRequiredWithoutLeaguesNestedInput = {
    create?: XOR<SeasonCreateWithoutLeaguesInput, SeasonUncheckedCreateWithoutLeaguesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutLeaguesInput
    upsert?: SeasonUpsertWithoutLeaguesInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutLeaguesInput, SeasonUpdateWithoutLeaguesInput>, SeasonUncheckedUpdateWithoutLeaguesInput>
  }

  export type TeamUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type LeagueStandingUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput> | LeagueStandingCreateWithoutLeagueInput[] | LeagueStandingUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: LeagueStandingCreateOrConnectWithoutLeagueInput | LeagueStandingCreateOrConnectWithoutLeagueInput[]
    upsert?: LeagueStandingUpsertWithWhereUniqueWithoutLeagueInput | LeagueStandingUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: LeagueStandingCreateManyLeagueInputEnvelope
    set?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    disconnect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    delete?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    connect?: LeagueStandingWhereUniqueInput | LeagueStandingWhereUniqueInput[]
    update?: LeagueStandingUpdateWithWhereUniqueWithoutLeagueInput | LeagueStandingUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: LeagueStandingUpdateManyWithWhereWithoutLeagueInput | LeagueStandingUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: LeagueStandingScalarWhereInput | LeagueStandingScalarWhereInput[]
  }

  export type LeagueCreateNestedOneWithoutStandingsInput = {
    create?: XOR<LeagueCreateWithoutStandingsInput, LeagueUncheckedCreateWithoutStandingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutStandingsInput
    connect?: LeagueWhereUniqueInput
  }

  export type LeagueUpdateOneRequiredWithoutStandingsNestedInput = {
    create?: XOR<LeagueCreateWithoutStandingsInput, LeagueUncheckedCreateWithoutStandingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutStandingsInput
    upsert?: LeagueUpsertWithoutStandingsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutStandingsInput, LeagueUpdateWithoutStandingsInput>, LeagueUncheckedUpdateWithoutStandingsInput>
  }

  export type LeagueCreateNestedOneWithoutScheduleInput = {
    create?: XOR<LeagueCreateWithoutScheduleInput, LeagueUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutScheduleInput
    connect?: LeagueWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutHomeTeamGamesInput = {
    create?: XOR<TeamCreateWithoutHomeTeamGamesInput, TeamUncheckedCreateWithoutHomeTeamGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeTeamGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAwayTeamGamesInput = {
    create?: XOR<TeamCreateWithoutAwayTeamGamesInput, TeamUncheckedCreateWithoutAwayTeamGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayTeamGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutGamesInput = {
    create?: XOR<TournamentCreateWithoutGamesInput, TournamentUncheckedCreateWithoutGamesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutGamesInput
    connect?: TournamentWhereUniqueInput
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type LeagueUpdateOneWithoutScheduleNestedInput = {
    create?: XOR<LeagueCreateWithoutScheduleInput, LeagueUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutScheduleInput
    upsert?: LeagueUpsertWithoutScheduleInput
    disconnect?: LeagueWhereInput | boolean
    delete?: LeagueWhereInput | boolean
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutScheduleInput, LeagueUpdateWithoutScheduleInput>, LeagueUncheckedUpdateWithoutScheduleInput>
  }

  export type TeamUpdateOneRequiredWithoutHomeTeamGamesNestedInput = {
    create?: XOR<TeamCreateWithoutHomeTeamGamesInput, TeamUncheckedCreateWithoutHomeTeamGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeTeamGamesInput
    upsert?: TeamUpsertWithoutHomeTeamGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutHomeTeamGamesInput, TeamUpdateWithoutHomeTeamGamesInput>, TeamUncheckedUpdateWithoutHomeTeamGamesInput>
  }

  export type TeamUpdateOneRequiredWithoutAwayTeamGamesNestedInput = {
    create?: XOR<TeamCreateWithoutAwayTeamGamesInput, TeamUncheckedCreateWithoutAwayTeamGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayTeamGamesInput
    upsert?: TeamUpsertWithoutAwayTeamGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAwayTeamGamesInput, TeamUpdateWithoutAwayTeamGamesInput>, TeamUncheckedUpdateWithoutAwayTeamGamesInput>
  }

  export type TournamentUpdateOneWithoutGamesNestedInput = {
    create?: XOR<TournamentCreateWithoutGamesInput, TournamentUncheckedCreateWithoutGamesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutGamesInput
    upsert?: TournamentUpsertWithoutGamesInput
    disconnect?: TournamentWhereInput | boolean
    delete?: TournamentWhereInput | boolean
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutGamesInput, TournamentUpdateWithoutGamesInput>, TournamentUncheckedUpdateWithoutGamesInput>
  }

  export type LeagueCreateNestedManyWithoutSeasonInput = {
    create?: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput> | LeagueCreateWithoutSeasonInput[] | LeagueUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonInput | LeagueCreateOrConnectWithoutSeasonInput[]
    createMany?: LeagueCreateManySeasonInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type TryoutHistoryCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput> | TryoutHistoryCreateWithoutSeasonInput[] | TryoutHistoryUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutSeasonInput | TryoutHistoryCreateOrConnectWithoutSeasonInput[]
    createMany?: TryoutHistoryCreateManySeasonInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type LeagueUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput> | LeagueCreateWithoutSeasonInput[] | LeagueUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonInput | LeagueCreateOrConnectWithoutSeasonInput[]
    createMany?: LeagueCreateManySeasonInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type TryoutHistoryUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput> | TryoutHistoryCreateWithoutSeasonInput[] | TryoutHistoryUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutSeasonInput | TryoutHistoryCreateOrConnectWithoutSeasonInput[]
    createMany?: TryoutHistoryCreateManySeasonInputEnvelope
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
  }

  export type EnumSeasonPhaseFieldUpdateOperationsInput = {
    set?: $Enums.SeasonPhase
  }

  export type LeagueUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput> | LeagueCreateWithoutSeasonInput[] | LeagueUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonInput | LeagueCreateOrConnectWithoutSeasonInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutSeasonInput | LeagueUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: LeagueCreateManySeasonInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutSeasonInput | LeagueUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutSeasonInput | LeagueUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type TryoutHistoryUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput> | TryoutHistoryCreateWithoutSeasonInput[] | TryoutHistoryUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutSeasonInput | TryoutHistoryCreateOrConnectWithoutSeasonInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutSeasonInput | TryoutHistoryUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TryoutHistoryCreateManySeasonInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutSeasonInput | TryoutHistoryUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutSeasonInput | TryoutHistoryUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type LeagueUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput> | LeagueCreateWithoutSeasonInput[] | LeagueUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSeasonInput | LeagueCreateOrConnectWithoutSeasonInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutSeasonInput | LeagueUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: LeagueCreateManySeasonInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutSeasonInput | LeagueUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutSeasonInput | LeagueUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput> | TryoutHistoryCreateWithoutSeasonInput[] | TryoutHistoryUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TryoutHistoryCreateOrConnectWithoutSeasonInput | TryoutHistoryCreateOrConnectWithoutSeasonInput[]
    upsert?: TryoutHistoryUpsertWithWhereUniqueWithoutSeasonInput | TryoutHistoryUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TryoutHistoryCreateManySeasonInputEnvelope
    set?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    disconnect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    delete?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    connect?: TryoutHistoryWhereUniqueInput | TryoutHistoryWhereUniqueInput[]
    update?: TryoutHistoryUpdateWithWhereUniqueWithoutSeasonInput | TryoutHistoryUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TryoutHistoryUpdateManyWithWhereWithoutSeasonInput | TryoutHistoryUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TeamCreateWithoutNotificationsInput, TeamUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutNotificationsInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type TeamUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TeamCreateWithoutNotificationsInput, TeamUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutNotificationsInput
    upsert?: TeamUpsertWithoutNotificationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutNotificationsInput, TeamUpdateWithoutNotificationsInput>, TeamUncheckedUpdateWithoutNotificationsInput>
  }

  export type TeamCreateNestedOneWithoutTryoutHistoryInput = {
    create?: XOR<TeamCreateWithoutTryoutHistoryInput, TeamUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTryoutHistoryInput
    connect?: TeamWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutTryoutHistoryInput = {
    create?: XOR<SeasonCreateWithoutTryoutHistoryInput, SeasonUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTryoutHistoryInput
    connect?: SeasonWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutTryoutHistoryInput = {
    create?: XOR<PlayerCreateWithoutTryoutHistoryInput, PlayerUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTryoutHistoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutTryoutHistoryNestedInput = {
    create?: XOR<TeamCreateWithoutTryoutHistoryInput, TeamUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTryoutHistoryInput
    upsert?: TeamUpsertWithoutTryoutHistoryInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTryoutHistoryInput, TeamUpdateWithoutTryoutHistoryInput>, TeamUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type SeasonUpdateOneRequiredWithoutTryoutHistoryNestedInput = {
    create?: XOR<SeasonCreateWithoutTryoutHistoryInput, SeasonUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTryoutHistoryInput
    upsert?: SeasonUpsertWithoutTryoutHistoryInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutTryoutHistoryInput, SeasonUpdateWithoutTryoutHistoryInput>, SeasonUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type PlayerUpdateOneWithoutTryoutHistoryNestedInput = {
    create?: XOR<PlayerCreateWithoutTryoutHistoryInput, PlayerUncheckedCreateWithoutTryoutHistoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTryoutHistoryInput
    upsert?: PlayerUpsertWithoutTryoutHistoryInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutTryoutHistoryInput, PlayerUpdateWithoutTryoutHistoryInput>, PlayerUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type RedeemCodeRecordCreateNestedManyWithoutRedeemCodeInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput> | RedeemCodeRecordCreateWithoutRedeemCodeInput[] | RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput | RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput[]
    createMany?: RedeemCodeRecordCreateManyRedeemCodeInputEnvelope
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
  }

  export type RedeemCodeRecordUncheckedCreateNestedManyWithoutRedeemCodeInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput> | RedeemCodeRecordCreateWithoutRedeemCodeInput[] | RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput | RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput[]
    createMany?: RedeemCodeRecordCreateManyRedeemCodeInputEnvelope
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
  }

  export type EnumRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardType
  }

  export type RedeemCodeRecordUpdateManyWithoutRedeemCodeNestedInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput> | RedeemCodeRecordCreateWithoutRedeemCodeInput[] | RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput | RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput[]
    upsert?: RedeemCodeRecordUpsertWithWhereUniqueWithoutRedeemCodeInput | RedeemCodeRecordUpsertWithWhereUniqueWithoutRedeemCodeInput[]
    createMany?: RedeemCodeRecordCreateManyRedeemCodeInputEnvelope
    set?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    disconnect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    delete?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    update?: RedeemCodeRecordUpdateWithWhereUniqueWithoutRedeemCodeInput | RedeemCodeRecordUpdateWithWhereUniqueWithoutRedeemCodeInput[]
    updateMany?: RedeemCodeRecordUpdateManyWithWhereWithoutRedeemCodeInput | RedeemCodeRecordUpdateManyWithWhereWithoutRedeemCodeInput[]
    deleteMany?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
  }

  export type RedeemCodeRecordUncheckedUpdateManyWithoutRedeemCodeNestedInput = {
    create?: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput> | RedeemCodeRecordCreateWithoutRedeemCodeInput[] | RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput[]
    connectOrCreate?: RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput | RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput[]
    upsert?: RedeemCodeRecordUpsertWithWhereUniqueWithoutRedeemCodeInput | RedeemCodeRecordUpsertWithWhereUniqueWithoutRedeemCodeInput[]
    createMany?: RedeemCodeRecordCreateManyRedeemCodeInputEnvelope
    set?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    disconnect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    delete?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    connect?: RedeemCodeRecordWhereUniqueInput | RedeemCodeRecordWhereUniqueInput[]
    update?: RedeemCodeRecordUpdateWithWhereUniqueWithoutRedeemCodeInput | RedeemCodeRecordUpdateWithWhereUniqueWithoutRedeemCodeInput[]
    updateMany?: RedeemCodeRecordUpdateManyWithWhereWithoutRedeemCodeInput | RedeemCodeRecordUpdateManyWithWhereWithoutRedeemCodeInput[]
    deleteMany?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
  }

  export type RedeemCodeCreateNestedOneWithoutRedeemedByInput = {
    create?: XOR<RedeemCodeCreateWithoutRedeemedByInput, RedeemCodeUncheckedCreateWithoutRedeemedByInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedeemedByInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutRedeemedCodesInput = {
    create?: XOR<UserProfileCreateWithoutRedeemedCodesInput, UserProfileUncheckedCreateWithoutRedeemedCodesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutRedeemedCodesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type RedeemCodeUpdateOneRequiredWithoutRedeemedByNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutRedeemedByInput, RedeemCodeUncheckedCreateWithoutRedeemedByInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedeemedByInput
    upsert?: RedeemCodeUpsertWithoutRedeemedByInput
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutRedeemedByInput, RedeemCodeUpdateWithoutRedeemedByInput>, RedeemCodeUncheckedUpdateWithoutRedeemedByInput>
  }

  export type UserProfileUpdateOneRequiredWithoutRedeemedCodesNestedInput = {
    create?: XOR<UserProfileCreateWithoutRedeemedCodesInput, UserProfileUncheckedCreateWithoutRedeemedCodesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutRedeemedCodesInput
    upsert?: UserProfileUpsertWithoutRedeemedCodesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutRedeemedCodesInput, UserProfileUpdateWithoutRedeemedCodesInput>, UserProfileUncheckedUpdateWithoutRedeemedCodesInput>
  }

  export type UserProfileCreateNestedOneWithoutAdRewardMilestoneInput = {
    create?: XOR<UserProfileCreateWithoutAdRewardMilestoneInput, UserProfileUncheckedCreateWithoutAdRewardMilestoneInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdRewardMilestoneInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutAdRewardMilestoneNestedInput = {
    create?: XOR<UserProfileCreateWithoutAdRewardMilestoneInput, UserProfileUncheckedCreateWithoutAdRewardMilestoneInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdRewardMilestoneInput
    upsert?: UserProfileUpsertWithoutAdRewardMilestoneInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutAdRewardMilestoneInput, UserProfileUpdateWithoutAdRewardMilestoneInput>, UserProfileUncheckedUpdateWithoutAdRewardMilestoneInput>
  }

  export type ItemCreateNestedOneWithoutPremiumBoxRewardsInput = {
    create?: XOR<ItemCreateWithoutPremiumBoxRewardsInput, ItemUncheckedCreateWithoutPremiumBoxRewardsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPremiumBoxRewardsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutPremiumBoxRewardsNestedInput = {
    create?: XOR<ItemCreateWithoutPremiumBoxRewardsInput, ItemUncheckedCreateWithoutPremiumBoxRewardsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPremiumBoxRewardsInput
    upsert?: ItemUpsertWithoutPremiumBoxRewardsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPremiumBoxRewardsInput, ItemUpdateWithoutPremiumBoxRewardsInput>, ItemUncheckedUpdateWithoutPremiumBoxRewardsInput>
  }

  export type GameCreateNestedManyWithoutTournamentInput = {
    create?: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput> | GameCreateWithoutTournamentInput[] | GameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput | GameCreateOrConnectWithoutTournamentInput[]
    createMany?: GameCreateManyTournamentInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TournamentEntryCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput> | TournamentEntryCreateWithoutTournamentInput[] | TournamentEntryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTournamentInput | TournamentEntryCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentEntryCreateManyTournamentInputEnvelope
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput> | GameCreateWithoutTournamentInput[] | GameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput | GameCreateOrConnectWithoutTournamentInput[]
    createMany?: GameCreateManyTournamentInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TournamentEntryUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput> | TournamentEntryCreateWithoutTournamentInput[] | TournamentEntryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTournamentInput | TournamentEntryCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentEntryCreateManyTournamentInputEnvelope
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
  }

  export type EnumTournamentTypeFieldUpdateOperationsInput = {
    set?: $Enums.TournamentType
  }

  export type EnumTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentStatus
  }

  export type GameUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput> | GameCreateWithoutTournamentInput[] | GameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput | GameCreateOrConnectWithoutTournamentInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutTournamentInput | GameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: GameCreateManyTournamentInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutTournamentInput | GameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: GameUpdateManyWithWhereWithoutTournamentInput | GameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TournamentEntryUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput> | TournamentEntryCreateWithoutTournamentInput[] | TournamentEntryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTournamentInput | TournamentEntryCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentEntryUpsertWithWhereUniqueWithoutTournamentInput | TournamentEntryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentEntryCreateManyTournamentInputEnvelope
    set?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    disconnect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    delete?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    update?: TournamentEntryUpdateWithWhereUniqueWithoutTournamentInput | TournamentEntryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentEntryUpdateManyWithWhereWithoutTournamentInput | TournamentEntryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput> | GameCreateWithoutTournamentInput[] | GameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput | GameCreateOrConnectWithoutTournamentInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutTournamentInput | GameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: GameCreateManyTournamentInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutTournamentInput | GameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: GameUpdateManyWithWhereWithoutTournamentInput | GameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TournamentEntryUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput> | TournamentEntryCreateWithoutTournamentInput[] | TournamentEntryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentEntryCreateOrConnectWithoutTournamentInput | TournamentEntryCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentEntryUpsertWithWhereUniqueWithoutTournamentInput | TournamentEntryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentEntryCreateManyTournamentInputEnvelope
    set?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    disconnect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    delete?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    connect?: TournamentEntryWhereUniqueInput | TournamentEntryWhereUniqueInput[]
    update?: TournamentEntryUpdateWithWhereUniqueWithoutTournamentInput | TournamentEntryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentEntryUpdateManyWithWhereWithoutTournamentInput | TournamentEntryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
  }

  export type TournamentCreateNestedOneWithoutEntriesInput = {
    create?: XOR<TournamentCreateWithoutEntriesInput, TournamentUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutEntriesInput
    connect?: TournamentWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTournamentEntriesInput = {
    create?: XOR<TeamCreateWithoutTournamentEntriesInput, TeamUncheckedCreateWithoutTournamentEntriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentEntriesInput
    connect?: TeamWhereUniqueInput
  }

  export type TournamentUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<TournamentCreateWithoutEntriesInput, TournamentUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutEntriesInput
    upsert?: TournamentUpsertWithoutEntriesInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutEntriesInput, TournamentUpdateWithoutEntriesInput>, TournamentUncheckedUpdateWithoutEntriesInput>
  }

  export type TeamUpdateOneRequiredWithoutTournamentEntriesNestedInput = {
    create?: XOR<TeamCreateWithoutTournamentEntriesInput, TeamUncheckedCreateWithoutTournamentEntriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentEntriesInput
    upsert?: TeamUpsertWithoutTournamentEntriesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTournamentEntriesInput, TeamUpdateWithoutTournamentEntriesInput>, TeamUncheckedUpdateWithoutTournamentEntriesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFieldSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldSize | EnumFieldSizeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldSizeFilter<$PrismaModel> | $Enums.FieldSize
  }

  export type NestedEnumTacticalFocusFilter<$PrismaModel = never> = {
    equals?: $Enums.TacticalFocus | EnumTacticalFocusFieldRefInput<$PrismaModel>
    in?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    not?: NestedEnumTacticalFocusFilter<$PrismaModel> | $Enums.TacticalFocus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFieldSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldSize | EnumFieldSizeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldSize[] | ListEnumFieldSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldSizeWithAggregatesFilter<$PrismaModel> | $Enums.FieldSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldSizeFilter<$PrismaModel>
    _max?: NestedEnumFieldSizeFilter<$PrismaModel>
  }

  export type NestedEnumTacticalFocusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TacticalFocus | EnumTacticalFocusFieldRefInput<$PrismaModel>
    in?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TacticalFocus[] | ListEnumTacticalFocusFieldRefInput<$PrismaModel>
    not?: NestedEnumTacticalFocusWithAggregatesFilter<$PrismaModel> | $Enums.TacticalFocus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTacticalFocusFilter<$PrismaModel>
    _max?: NestedEnumTacticalFocusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type NestedEnumPlayerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRole | EnumPlayerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerRoleFilter<$PrismaModel> | $Enums.PlayerRole
  }

  export type NestedEnumInjuryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusFilter<$PrismaModel> | $Enums.InjuryStatus
  }

  export type NestedEnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type NestedEnumPlayerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerRole | EnumPlayerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerRole[] | ListEnumPlayerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerRoleWithAggregatesFilter<$PrismaModel> | $Enums.PlayerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerRoleFilter<$PrismaModel>
    _max?: NestedEnumPlayerRoleFilter<$PrismaModel>
  }

  export type NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InjuryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryStatusFilter<$PrismaModel>
    _max?: NestedEnumInjuryStatusFilter<$PrismaModel>
  }

  export type NestedEnumSkillTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeFilter<$PrismaModel> | $Enums.SkillType
  }

  export type NestedEnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillTypeFilter<$PrismaModel>
  }

  export type NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type NestedEnumStaffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffTypeFilter<$PrismaModel> | $Enums.StaffType
  }

  export type NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel> | $Enums.StaffType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffTypeFilter<$PrismaModel>
    _max?: NestedEnumStaffTypeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumEquipmentSlotNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel> | $Enums.EquipmentSlot | null
  }

  export type NestedEnumRaceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRaceNullableFilter<$PrismaModel> | $Enums.Race | null
  }

  export type NestedEnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentSlot | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
    _max?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
  }

  export type NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Race | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRaceNullableFilter<$PrismaModel>
    _max?: NestedEnumRaceNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type NestedEnumMarketplaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceStatus | EnumMarketplaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceStatusFilter<$PrismaModel> | $Enums.MarketplaceStatus
  }

  export type NestedEnumMarketplaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceStatus | EnumMarketplaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceStatus[] | ListEnumMarketplaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceStatusFilter<$PrismaModel>
  }

  export type NestedEnumListingActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingActionType | EnumListingActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingActionTypeFilter<$PrismaModel> | $Enums.ListingActionType
  }

  export type NestedEnumListingActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingActionType | EnumListingActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingActionType[] | ListEnumListingActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListingActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListingActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingActionTypeFilter<$PrismaModel>
    _max?: NestedEnumListingActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type NestedEnumSeasonPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonPhase | EnumSeasonPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumSeasonPhaseFilter<$PrismaModel> | $Enums.SeasonPhase
  }

  export type NestedEnumSeasonPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonPhase | EnumSeasonPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeasonPhase[] | ListEnumSeasonPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumSeasonPhaseWithAggregatesFilter<$PrismaModel> | $Enums.SeasonPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeasonPhaseFilter<$PrismaModel>
    _max?: NestedEnumSeasonPhaseFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type NestedEnumTournamentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentType | EnumTournamentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentTypeFilter<$PrismaModel> | $Enums.TournamentType
  }

  export type NestedEnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type NestedEnumTournamentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentType | EnumTournamentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentType[] | ListEnumTournamentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TournamentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentTypeFilter<$PrismaModel>
    _max?: NestedEnumTournamentTypeFilter<$PrismaModel>
  }

  export type NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type TeamCreateWithoutUserInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutUserInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
  }

  export type RedeemCodeRecordCreateWithoutUserProfileInput = {
    redeemedAt?: Date | string
    redeemCode: RedeemCodeCreateNestedOneWithoutRedeemedByInput
  }

  export type RedeemCodeRecordUncheckedCreateWithoutUserProfileInput = {
    id?: number
    redeemCodeId: string
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordCreateOrConnectWithoutUserProfileInput = {
    where: RedeemCodeRecordWhereUniqueInput
    create: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput>
  }

  export type RedeemCodeRecordCreateManyUserProfileInputEnvelope = {
    data: RedeemCodeRecordCreateManyUserProfileInput | RedeemCodeRecordCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type AdRewardMilestoneCreateWithoutUserProfileInput = {
    totalAdsWatched?: number
    adsWatchedToday?: number
    lastAdWatchedAt?: Date | string | null
  }

  export type AdRewardMilestoneUncheckedCreateWithoutUserProfileInput = {
    id?: number
    totalAdsWatched?: number
    adsWatchedToday?: number
    lastAdWatchedAt?: Date | string | null
  }

  export type AdRewardMilestoneCreateOrConnectWithoutUserProfileInput = {
    where: AdRewardMilestoneWhereUniqueInput
    create: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
  }

  export type TeamUpsertWithoutUserInput = {
    update: XOR<TeamUpdateWithoutUserInput, TeamUncheckedUpdateWithoutUserInput>
    create: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutUserInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutUserInput, TeamUncheckedUpdateWithoutUserInput>
  }

  export type TeamUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type RedeemCodeRecordUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: RedeemCodeRecordWhereUniqueInput
    update: XOR<RedeemCodeRecordUpdateWithoutUserProfileInput, RedeemCodeRecordUncheckedUpdateWithoutUserProfileInput>
    create: XOR<RedeemCodeRecordCreateWithoutUserProfileInput, RedeemCodeRecordUncheckedCreateWithoutUserProfileInput>
  }

  export type RedeemCodeRecordUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: RedeemCodeRecordWhereUniqueInput
    data: XOR<RedeemCodeRecordUpdateWithoutUserProfileInput, RedeemCodeRecordUncheckedUpdateWithoutUserProfileInput>
  }

  export type RedeemCodeRecordUpdateManyWithWhereWithoutUserProfileInput = {
    where: RedeemCodeRecordScalarWhereInput
    data: XOR<RedeemCodeRecordUpdateManyMutationInput, RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type RedeemCodeRecordScalarWhereInput = {
    AND?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
    OR?: RedeemCodeRecordScalarWhereInput[]
    NOT?: RedeemCodeRecordScalarWhereInput | RedeemCodeRecordScalarWhereInput[]
    id?: IntFilter<"RedeemCodeRecord"> | number
    redeemCodeId?: StringFilter<"RedeemCodeRecord"> | string
    userProfileId?: IntFilter<"RedeemCodeRecord"> | number
    redeemedAt?: DateTimeFilter<"RedeemCodeRecord"> | Date | string
  }

  export type AdRewardMilestoneUpsertWithoutUserProfileInput = {
    update: XOR<AdRewardMilestoneUpdateWithoutUserProfileInput, AdRewardMilestoneUncheckedUpdateWithoutUserProfileInput>
    create: XOR<AdRewardMilestoneCreateWithoutUserProfileInput, AdRewardMilestoneUncheckedCreateWithoutUserProfileInput>
    where?: AdRewardMilestoneWhereInput
  }

  export type AdRewardMilestoneUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: AdRewardMilestoneWhereInput
    data: XOR<AdRewardMilestoneUpdateWithoutUserProfileInput, AdRewardMilestoneUncheckedUpdateWithoutUserProfileInput>
  }

  export type AdRewardMilestoneUpdateWithoutUserProfileInput = {
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdRewardMilestoneUncheckedUpdateWithoutUserProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAdsWatched?: IntFieldUpdateOperationsInput | number
    adsWatchedToday?: IntFieldUpdateOperationsInput | number
    lastAdWatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateWithoutTeamInput = {
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    redeemedCodes?: RedeemCodeRecordCreateNestedManyWithoutUserProfileInput
    adRewardMilestone?: AdRewardMilestoneCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    redeemedCodes?: RedeemCodeRecordUncheckedCreateNestedManyWithoutUserProfileInput
    adRewardMilestone?: AdRewardMilestoneUncheckedCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutTeamInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutTeamInput, UserProfileUncheckedCreateWithoutTeamInput>
  }

  export type PlayerCreateWithoutTeamInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTeamInput = {
    id?: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerCreateManyTeamInputEnvelope = {
    data: PlayerCreateManyTeamInput | PlayerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutTeamInput = {
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutTeamInput = {
    id?: number
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutTeamInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput>
  }

  export type StaffCreateManyTeamInputEnvelope = {
    data: StaffCreateManyTeamInput | StaffCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamFinancesCreateWithoutTeamInput = {
    credits?: bigint | number
    gems?: number
    escrowCredits?: bigint | number
    escrowGems?: number
    projectedIncome?: bigint | number
    projectedExpenses?: bigint | number
    lastSeasonRevenue?: bigint | number
    lastSeasonExpenses?: bigint | number
    facilitiesMaintenanceCost?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamFinancesUncheckedCreateWithoutTeamInput = {
    id?: number
    credits?: bigint | number
    gems?: number
    escrowCredits?: bigint | number
    escrowGems?: number
    projectedIncome?: bigint | number
    projectedExpenses?: bigint | number
    lastSeasonRevenue?: bigint | number
    lastSeasonExpenses?: bigint | number
    facilitiesMaintenanceCost?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamFinancesCreateOrConnectWithoutTeamInput = {
    where: TeamFinancesWhereUniqueInput
    create: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
  }

  export type StadiumCreateWithoutTeamInput = {
    capacity?: number
    concessionsLevel?: number
    parkingLevel?: number
    vipSuitesLevel?: number
    merchandisingLevel?: number
    lightingScreensLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StadiumUncheckedCreateWithoutTeamInput = {
    id?: number
    capacity?: number
    concessionsLevel?: number
    parkingLevel?: number
    vipSuitesLevel?: number
    merchandisingLevel?: number
    lightingScreensLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StadiumCreateOrConnectWithoutTeamInput = {
    where: StadiumWhereUniqueInput
    create: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
  }

  export type InventoryItemCreateWithoutTeamInput = {
    quantity: number
    acquiredAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutTeamInput = {
    id?: number
    itemId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutTeamInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput>
  }

  export type InventoryItemCreateManyTeamInputEnvelope = {
    data: InventoryItemCreateManyTeamInput | InventoryItemCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type LeagueCreateWithoutTeamsInput = {
    division: number
    name: string
    schedule?: GameCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingCreateNestedManyWithoutLeagueInput
    season: SeasonCreateNestedOneWithoutLeaguesInput
  }

  export type LeagueUncheckedCreateWithoutTeamsInput = {
    id?: number
    division: number
    name: string
    seasonId: string
    schedule?: GameUncheckedCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutTeamsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
  }

  export type ActiveBoostCreateWithoutTeamInput = {
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
    player?: PlayerCreateNestedOneWithoutActiveBoostsInput
    item: ItemCreateNestedOneWithoutActiveBoostsInput
  }

  export type ActiveBoostUncheckedCreateWithoutTeamInput = {
    id?: number
    playerId?: number | null
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type ActiveBoostCreateOrConnectWithoutTeamInput = {
    where: ActiveBoostWhereUniqueInput
    create: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput>
  }

  export type ActiveBoostCreateManyTeamInputEnvelope = {
    data: ActiveBoostCreateManyTeamInput | ActiveBoostCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type StrategyCreateWithoutTeamInput = {
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyUncheckedCreateWithoutTeamInput = {
    id?: number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyCreateOrConnectWithoutTeamInput = {
    where: StrategyWhereUniqueInput
    create: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
  }

  export type MarketplaceListingCreateWithoutSellerTeamInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketplaceListingInput
    currentHighBidderTeam?: TeamCreateNestedOneWithoutHighBidderOnListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
    history?: ListingHistoryCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutSellerTeamInput = {
    id?: number
    playerId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
    history?: ListingHistoryUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutSellerTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput>
  }

  export type MarketplaceListingCreateManySellerTeamInputEnvelope = {
    data: MarketplaceListingCreateManySellerTeamInput | MarketplaceListingCreateManySellerTeamInput[]
    skipDuplicates?: boolean
  }

  export type BidCreateWithoutBidderTeamInput = {
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutBidderTeamInput = {
    id?: number
    listingId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutBidderTeamInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput>
  }

  export type BidCreateManyBidderTeamInputEnvelope = {
    data: BidCreateManyBidderTeamInput | BidCreateManyBidderTeamInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceListingCreateWithoutCurrentHighBidderTeamInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketplaceListingInput
    sellerTeam: TeamCreateNestedOneWithoutMarketplaceListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
    history?: ListingHistoryCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
    history?: ListingHistoryUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutCurrentHighBidderTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput>
  }

  export type MarketplaceListingCreateManyCurrentHighBidderTeamInputEnvelope = {
    data: MarketplaceListingCreateManyCurrentHighBidderTeamInput | MarketplaceListingCreateManyCurrentHighBidderTeamInput[]
    skipDuplicates?: boolean
  }

  export type ListingHistoryCreateWithoutTeamInput = {
    actionType: $Enums.ListingActionType
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
    listing: MarketplaceListingCreateNestedOneWithoutHistoryInput
  }

  export type ListingHistoryUncheckedCreateWithoutTeamInput = {
    id?: number
    listingId: number
    actionType: $Enums.ListingActionType
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type ListingHistoryCreateOrConnectWithoutTeamInput = {
    where: ListingHistoryWhereUniqueInput
    create: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput>
  }

  export type ListingHistoryCreateManyTeamInputEnvelope = {
    data: ListingHistoryCreateManyTeamInput | ListingHistoryCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTeamInput = {
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutTeamInput = {
    id?: number
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTeamInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput>
  }

  export type NotificationCreateManyTeamInputEnvelope = {
    data: NotificationCreateManyTeamInput | NotificationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TournamentEntryCreateWithoutTeamInput = {
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
    tournament: TournamentCreateNestedOneWithoutEntriesInput
  }

  export type TournamentEntryUncheckedCreateWithoutTeamInput = {
    id?: number
    tournamentId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type TournamentEntryCreateOrConnectWithoutTeamInput = {
    where: TournamentEntryWhereUniqueInput
    create: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput>
  }

  export type TournamentEntryCreateManyTeamInputEnvelope = {
    data: TournamentEntryCreateManyTeamInput | TournamentEntryCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TryoutHistoryCreateWithoutTeamInput = {
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    season: SeasonCreateNestedOneWithoutTryoutHistoryInput
    player?: PlayerCreateNestedOneWithoutTryoutHistoryInput
  }

  export type TryoutHistoryUncheckedCreateWithoutTeamInput = {
    id?: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type TryoutHistoryCreateOrConnectWithoutTeamInput = {
    where: TryoutHistoryWhereUniqueInput
    create: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput>
  }

  export type TryoutHistoryCreateManyTeamInputEnvelope = {
    data: TryoutHistoryCreateManyTeamInput | TryoutHistoryCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutHomeTeamInput = {
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutScheduleInput
    awayTeam: TeamCreateNestedOneWithoutAwayTeamGamesInput
    tournament?: TournamentCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutHomeTeamInput = {
    id?: number
    leagueId?: number | null
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameCreateOrConnectWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameCreateManyHomeTeamInputEnvelope = {
    data: GameCreateManyHomeTeamInput | GameCreateManyHomeTeamInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutAwayTeamInput = {
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutScheduleInput
    homeTeam: TeamCreateNestedOneWithoutHomeTeamGamesInput
    tournament?: TournamentCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutAwayTeamInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameCreateOrConnectWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameCreateManyAwayTeamInputEnvelope = {
    data: GameCreateManyAwayTeamInput | GameCreateManyAwayTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutTeamInput = {
    update: XOR<UserProfileUpdateWithoutTeamInput, UserProfileUncheckedUpdateWithoutTeamInput>
    create: XOR<UserProfileCreateWithoutTeamInput, UserProfileUncheckedCreateWithoutTeamInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutTeamInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutTeamInput, UserProfileUncheckedUpdateWithoutTeamInput>
  }

  export type UserProfileUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedCodes?: RedeemCodeRecordUpdateManyWithoutUserProfileNestedInput
    adRewardMilestone?: AdRewardMilestoneUpdateOneWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedCodes?: RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    adRewardMilestone?: AdRewardMilestoneUncheckedUpdateOneWithoutUserProfileNestedInput
  }

  export type PlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: IntFilter<"Player"> | number
    teamId?: IntFilter<"Player"> | number
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    race?: EnumRaceFilter<"Player"> | $Enums.Race
    age?: IntFilter<"Player"> | number
    role?: EnumPlayerRoleFilter<"Player"> | $Enums.PlayerRole
    speed?: IntFilter<"Player"> | number
    power?: IntFilter<"Player"> | number
    throwing?: IntFilter<"Player"> | number
    catching?: IntFilter<"Player"> | number
    kicking?: IntFilter<"Player"> | number
    staminaAttribute?: IntFilter<"Player"> | number
    leadership?: IntFilter<"Player"> | number
    agility?: IntFilter<"Player"> | number
    potentialRating?: FloatFilter<"Player"> | number
    dailyStaminaLevel?: IntFilter<"Player"> | number
    injuryStatus?: EnumInjuryStatusFilter<"Player"> | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFilter<"Player"> | number
    injuryRecoveryPointsCurrent?: IntFilter<"Player"> | number
    dailyItemsUsed?: IntFilter<"Player"> | number
    careerInjuries?: IntFilter<"Player"> | number
    gamesPlayedLastSeason?: IntFilter<"Player"> | number
    seasonMinutesLeague?: FloatFilter<"Player"> | number
    seasonMinutesTournament?: FloatFilter<"Player"> | number
    seasonMinutesExhibition?: FloatFilter<"Player"> | number
    seasonMinutesTotal?: FloatFilter<"Player"> | number
    isOnMarket?: BoolFilter<"Player"> | boolean
    isRetired?: BoolFilter<"Player"> | boolean
    camaraderieScore?: FloatFilter<"Player"> | number
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
  }

  export type StaffUpsertWithWhereUniqueWithoutTeamInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutTeamInput, StaffUncheckedUpdateWithoutTeamInput>
    create: XOR<StaffCreateWithoutTeamInput, StaffUncheckedCreateWithoutTeamInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutTeamInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutTeamInput, StaffUncheckedUpdateWithoutTeamInput>
  }

  export type StaffUpdateManyWithWhereWithoutTeamInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutTeamInput>
  }

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[]
    OR?: StaffScalarWhereInput[]
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[]
    id?: IntFilter<"Staff"> | number
    teamId?: IntFilter<"Staff"> | number
    type?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType
    name?: StringFilter<"Staff"> | string
    level?: IntFilter<"Staff"> | number
    motivation?: IntFilter<"Staff"> | number
    development?: IntFilter<"Staff"> | number
    teaching?: IntFilter<"Staff"> | number
    physiology?: IntFilter<"Staff"> | number
    talentIdentification?: IntFilter<"Staff"> | number
    potentialAssessment?: IntFilter<"Staff"> | number
    tactics?: IntFilter<"Staff"> | number
    age?: IntFilter<"Staff"> | number
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
  }

  export type TeamFinancesUpsertWithoutTeamInput = {
    update: XOR<TeamFinancesUpdateWithoutTeamInput, TeamFinancesUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamFinancesCreateWithoutTeamInput, TeamFinancesUncheckedCreateWithoutTeamInput>
    where?: TeamFinancesWhereInput
  }

  export type TeamFinancesUpdateToOneWithWhereWithoutTeamInput = {
    where?: TeamFinancesWhereInput
    data: XOR<TeamFinancesUpdateWithoutTeamInput, TeamFinancesUncheckedUpdateWithoutTeamInput>
  }

  export type TeamFinancesUpdateWithoutTeamInput = {
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamFinancesUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    credits?: BigIntFieldUpdateOperationsInput | bigint | number
    gems?: IntFieldUpdateOperationsInput | number
    escrowCredits?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowGems?: IntFieldUpdateOperationsInput | number
    projectedIncome?: BigIntFieldUpdateOperationsInput | bigint | number
    projectedExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonRevenue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSeasonExpenses?: BigIntFieldUpdateOperationsInput | bigint | number
    facilitiesMaintenanceCost?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StadiumUpsertWithoutTeamInput = {
    update: XOR<StadiumUpdateWithoutTeamInput, StadiumUncheckedUpdateWithoutTeamInput>
    create: XOR<StadiumCreateWithoutTeamInput, StadiumUncheckedCreateWithoutTeamInput>
    where?: StadiumWhereInput
  }

  export type StadiumUpdateToOneWithWhereWithoutTeamInput = {
    where?: StadiumWhereInput
    data: XOR<StadiumUpdateWithoutTeamInput, StadiumUncheckedUpdateWithoutTeamInput>
  }

  export type StadiumUpdateWithoutTeamInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StadiumUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    concessionsLevel?: IntFieldUpdateOperationsInput | number
    parkingLevel?: IntFieldUpdateOperationsInput | number
    vipSuitesLevel?: IntFieldUpdateOperationsInput | number
    merchandisingLevel?: IntFieldUpdateOperationsInput | number
    lightingScreensLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutTeamInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutTeamInput, InventoryItemUncheckedUpdateWithoutTeamInput>
    create: XOR<InventoryItemCreateWithoutTeamInput, InventoryItemUncheckedCreateWithoutTeamInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutTeamInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutTeamInput, InventoryItemUncheckedUpdateWithoutTeamInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutTeamInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutTeamInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    teamId?: IntFilter<"InventoryItem"> | number
    itemId?: IntFilter<"InventoryItem"> | number
    quantity?: IntFilter<"InventoryItem"> | number
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type LeagueUpsertWithoutTeamsInput = {
    update: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutTeamsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type LeagueUpdateWithoutTeamsInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schedule?: GameUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUpdateManyWithoutLeagueNestedInput
    season?: SeasonUpdateOneRequiredWithoutLeaguesNestedInput
  }

  export type LeagueUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    schedule?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type ActiveBoostUpsertWithWhereUniqueWithoutTeamInput = {
    where: ActiveBoostWhereUniqueInput
    update: XOR<ActiveBoostUpdateWithoutTeamInput, ActiveBoostUncheckedUpdateWithoutTeamInput>
    create: XOR<ActiveBoostCreateWithoutTeamInput, ActiveBoostUncheckedCreateWithoutTeamInput>
  }

  export type ActiveBoostUpdateWithWhereUniqueWithoutTeamInput = {
    where: ActiveBoostWhereUniqueInput
    data: XOR<ActiveBoostUpdateWithoutTeamInput, ActiveBoostUncheckedUpdateWithoutTeamInput>
  }

  export type ActiveBoostUpdateManyWithWhereWithoutTeamInput = {
    where: ActiveBoostScalarWhereInput
    data: XOR<ActiveBoostUpdateManyMutationInput, ActiveBoostUncheckedUpdateManyWithoutTeamInput>
  }

  export type ActiveBoostScalarWhereInput = {
    AND?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
    OR?: ActiveBoostScalarWhereInput[]
    NOT?: ActiveBoostScalarWhereInput | ActiveBoostScalarWhereInput[]
    id?: IntFilter<"ActiveBoost"> | number
    teamId?: IntFilter<"ActiveBoost"> | number
    playerId?: IntNullableFilter<"ActiveBoost"> | number | null
    itemId?: IntFilter<"ActiveBoost"> | number
    matchType?: EnumMatchTypeFilter<"ActiveBoost"> | $Enums.MatchType
    isActive?: BoolFilter<"ActiveBoost"> | boolean
    appliedAt?: DateTimeFilter<"ActiveBoost"> | Date | string
  }

  export type StrategyUpsertWithoutTeamInput = {
    update: XOR<StrategyUpdateWithoutTeamInput, StrategyUncheckedUpdateWithoutTeamInput>
    create: XOR<StrategyCreateWithoutTeamInput, StrategyUncheckedCreateWithoutTeamInput>
    where?: StrategyWhereInput
  }

  export type StrategyUpdateToOneWithWhereWithoutTeamInput = {
    where?: StrategyWhereInput
    data: XOR<StrategyUpdateWithoutTeamInput, StrategyUncheckedUpdateWithoutTeamInput>
  }

  export type StrategyUpdateWithoutTeamInput = {
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    formationJson?: NullableJsonNullValueInput | InputJsonValue
    substitutionJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUpsertWithWhereUniqueWithoutSellerTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    update: XOR<MarketplaceListingUpdateWithoutSellerTeamInput, MarketplaceListingUncheckedUpdateWithoutSellerTeamInput>
    create: XOR<MarketplaceListingCreateWithoutSellerTeamInput, MarketplaceListingUncheckedCreateWithoutSellerTeamInput>
  }

  export type MarketplaceListingUpdateWithWhereUniqueWithoutSellerTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    data: XOR<MarketplaceListingUpdateWithoutSellerTeamInput, MarketplaceListingUncheckedUpdateWithoutSellerTeamInput>
  }

  export type MarketplaceListingUpdateManyWithWhereWithoutSellerTeamInput = {
    where: MarketplaceListingScalarWhereInput
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyWithoutSellerTeamInput>
  }

  export type MarketplaceListingScalarWhereInput = {
    AND?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    OR?: MarketplaceListingScalarWhereInput[]
    NOT?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    id?: IntFilter<"MarketplaceListing"> | number
    playerId?: IntFilter<"MarketplaceListing"> | number
    sellerTeamId?: IntFilter<"MarketplaceListing"> | number
    startBid?: BigIntFilter<"MarketplaceListing"> | bigint | number
    buyNowPrice?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    minBuyNowPrice?: BigIntFilter<"MarketplaceListing"> | bigint | number
    currentBid?: BigIntNullableFilter<"MarketplaceListing"> | bigint | number | null
    currentHighBidderTeamId?: IntNullableFilter<"MarketplaceListing"> | number | null
    expiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    originalExpiryTimestamp?: DateTimeFilter<"MarketplaceListing"> | Date | string
    auctionExtensions?: IntFilter<"MarketplaceListing"> | number
    listingFee?: BigIntFilter<"MarketplaceListing"> | bigint | number
    marketTaxRate?: FloatFilter<"MarketplaceListing"> | number
    escrowAmount?: BigIntFilter<"MarketplaceListing"> | bigint | number
    listingStatus?: EnumMarketplaceStatusFilter<"MarketplaceListing"> | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFilter<"MarketplaceListing"> | boolean
    autoDelistAt?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    isActive?: BoolFilter<"MarketplaceListing"> | boolean
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
  }

  export type BidUpsertWithWhereUniqueWithoutBidderTeamInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutBidderTeamInput, BidUncheckedUpdateWithoutBidderTeamInput>
    create: XOR<BidCreateWithoutBidderTeamInput, BidUncheckedCreateWithoutBidderTeamInput>
  }

  export type BidUpdateWithWhereUniqueWithoutBidderTeamInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutBidderTeamInput, BidUncheckedUpdateWithoutBidderTeamInput>
  }

  export type BidUpdateManyWithWhereWithoutBidderTeamInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutBidderTeamInput>
  }

  export type BidScalarWhereInput = {
    AND?: BidScalarWhereInput | BidScalarWhereInput[]
    OR?: BidScalarWhereInput[]
    NOT?: BidScalarWhereInput | BidScalarWhereInput[]
    id?: IntFilter<"Bid"> | number
    listingId?: IntFilter<"Bid"> | number
    bidderTeamId?: IntFilter<"Bid"> | number
    bidAmount?: BigIntFilter<"Bid"> | bigint | number
    escrowAmount?: BigIntFilter<"Bid"> | bigint | number
    isWinningBid?: BoolFilter<"Bid"> | boolean
    isRefunded?: BoolFilter<"Bid"> | boolean
    placedAt?: DateTimeFilter<"Bid"> | Date | string
  }

  export type MarketplaceListingUpsertWithWhereUniqueWithoutCurrentHighBidderTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    update: XOR<MarketplaceListingUpdateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedUpdateWithoutCurrentHighBidderTeamInput>
    create: XOR<MarketplaceListingCreateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedCreateWithoutCurrentHighBidderTeamInput>
  }

  export type MarketplaceListingUpdateWithWhereUniqueWithoutCurrentHighBidderTeamInput = {
    where: MarketplaceListingWhereUniqueInput
    data: XOR<MarketplaceListingUpdateWithoutCurrentHighBidderTeamInput, MarketplaceListingUncheckedUpdateWithoutCurrentHighBidderTeamInput>
  }

  export type MarketplaceListingUpdateManyWithWhereWithoutCurrentHighBidderTeamInput = {
    where: MarketplaceListingScalarWhereInput
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamInput>
  }

  export type ListingHistoryUpsertWithWhereUniqueWithoutTeamInput = {
    where: ListingHistoryWhereUniqueInput
    update: XOR<ListingHistoryUpdateWithoutTeamInput, ListingHistoryUncheckedUpdateWithoutTeamInput>
    create: XOR<ListingHistoryCreateWithoutTeamInput, ListingHistoryUncheckedCreateWithoutTeamInput>
  }

  export type ListingHistoryUpdateWithWhereUniqueWithoutTeamInput = {
    where: ListingHistoryWhereUniqueInput
    data: XOR<ListingHistoryUpdateWithoutTeamInput, ListingHistoryUncheckedUpdateWithoutTeamInput>
  }

  export type ListingHistoryUpdateManyWithWhereWithoutTeamInput = {
    where: ListingHistoryScalarWhereInput
    data: XOR<ListingHistoryUpdateManyMutationInput, ListingHistoryUncheckedUpdateManyWithoutTeamInput>
  }

  export type ListingHistoryScalarWhereInput = {
    AND?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
    OR?: ListingHistoryScalarWhereInput[]
    NOT?: ListingHistoryScalarWhereInput | ListingHistoryScalarWhereInput[]
    id?: IntFilter<"ListingHistory"> | number
    listingId?: IntFilter<"ListingHistory"> | number
    actionType?: EnumListingActionTypeFilter<"ListingHistory"> | $Enums.ListingActionType
    teamId?: IntNullableFilter<"ListingHistory"> | number | null
    amount?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    oldValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    newValue?: BigIntNullableFilter<"ListingHistory"> | bigint | number | null
    description?: StringNullableFilter<"ListingHistory"> | string | null
    timestamp?: DateTimeFilter<"ListingHistory"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTeamInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTeamInput, NotificationUncheckedUpdateWithoutTeamInput>
    create: XOR<NotificationCreateWithoutTeamInput, NotificationUncheckedCreateWithoutTeamInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTeamInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTeamInput, NotificationUncheckedUpdateWithoutTeamInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTeamInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTeamInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    teamId?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    linkTo?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TournamentEntryUpsertWithWhereUniqueWithoutTeamInput = {
    where: TournamentEntryWhereUniqueInput
    update: XOR<TournamentEntryUpdateWithoutTeamInput, TournamentEntryUncheckedUpdateWithoutTeamInput>
    create: XOR<TournamentEntryCreateWithoutTeamInput, TournamentEntryUncheckedCreateWithoutTeamInput>
  }

  export type TournamentEntryUpdateWithWhereUniqueWithoutTeamInput = {
    where: TournamentEntryWhereUniqueInput
    data: XOR<TournamentEntryUpdateWithoutTeamInput, TournamentEntryUncheckedUpdateWithoutTeamInput>
  }

  export type TournamentEntryUpdateManyWithWhereWithoutTeamInput = {
    where: TournamentEntryScalarWhereInput
    data: XOR<TournamentEntryUpdateManyMutationInput, TournamentEntryUncheckedUpdateManyWithoutTeamInput>
  }

  export type TournamentEntryScalarWhereInput = {
    AND?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
    OR?: TournamentEntryScalarWhereInput[]
    NOT?: TournamentEntryScalarWhereInput | TournamentEntryScalarWhereInput[]
    id?: IntFilter<"TournamentEntry"> | number
    tournamentId?: IntFilter<"TournamentEntry"> | number
    teamId?: IntFilter<"TournamentEntry"> | number
    registeredAt?: DateTimeFilter<"TournamentEntry"> | Date | string
    finalRank?: IntNullableFilter<"TournamentEntry"> | number | null
    rewardsClaimed?: BoolFilter<"TournamentEntry"> | boolean
  }

  export type TryoutHistoryUpsertWithWhereUniqueWithoutTeamInput = {
    where: TryoutHistoryWhereUniqueInput
    update: XOR<TryoutHistoryUpdateWithoutTeamInput, TryoutHistoryUncheckedUpdateWithoutTeamInput>
    create: XOR<TryoutHistoryCreateWithoutTeamInput, TryoutHistoryUncheckedCreateWithoutTeamInput>
  }

  export type TryoutHistoryUpdateWithWhereUniqueWithoutTeamInput = {
    where: TryoutHistoryWhereUniqueInput
    data: XOR<TryoutHistoryUpdateWithoutTeamInput, TryoutHistoryUncheckedUpdateWithoutTeamInput>
  }

  export type TryoutHistoryUpdateManyWithWhereWithoutTeamInput = {
    where: TryoutHistoryScalarWhereInput
    data: XOR<TryoutHistoryUpdateManyMutationInput, TryoutHistoryUncheckedUpdateManyWithoutTeamInput>
  }

  export type TryoutHistoryScalarWhereInput = {
    AND?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
    OR?: TryoutHistoryScalarWhereInput[]
    NOT?: TryoutHistoryScalarWhereInput | TryoutHistoryScalarWhereInput[]
    id?: IntFilter<"TryoutHistory"> | number
    teamId?: IntFilter<"TryoutHistory"> | number
    seasonId?: StringFilter<"TryoutHistory"> | string
    tryoutType?: StringFilter<"TryoutHistory"> | string
    cost?: IntFilter<"TryoutHistory"> | number
    playersAdded?: IntFilter<"TryoutHistory"> | number
    conductedAt?: DateTimeFilter<"TryoutHistory"> | Date | string
    playerId?: IntNullableFilter<"TryoutHistory"> | number | null
  }

  export type GameUpsertWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutHomeTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutHomeTeamInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: IntFilter<"Game"> | number
    leagueId?: IntNullableFilter<"Game"> | number | null
    homeTeamId?: IntFilter<"Game"> | number
    awayTeamId?: IntFilter<"Game"> | number
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    gameDate?: DateTimeFilter<"Game"> | Date | string
    simulated?: BoolFilter<"Game"> | boolean
    simulationLog?: JsonNullableFilter<"Game">
    matchType?: EnumMatchTypeFilter<"Game"> | $Enums.MatchType
    tournamentId?: IntNullableFilter<"Game"> | number | null
    round?: IntNullableFilter<"Game"> | number | null
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    createdAt?: DateTimeFilter<"Game"> | Date | string
  }

  export type GameUpsertWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutAwayTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutAwayTeamInput>
  }

  export type TeamCreateWithoutPlayersInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayersInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
  }

  export type ContractCreateWithoutPlayerInput = {
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
    staff?: StaffCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutPlayerInput = {
    id?: number
    staffId?: number | null
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
  }

  export type ContractCreateOrConnectWithoutPlayerInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillLinkCreateWithoutPlayerInput = {
    currentTier?: number
    acquiredAt?: Date | string
    skill: SkillCreateNestedOneWithoutPlayerLinksInput
  }

  export type PlayerSkillLinkUncheckedCreateWithoutPlayerInput = {
    id?: number
    skillId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type PlayerSkillLinkCreateOrConnectWithoutPlayerInput = {
    where: PlayerSkillLinkWhereUniqueInput
    create: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillLinkCreateManyPlayerInputEnvelope = {
    data: PlayerSkillLinkCreateManyPlayerInput | PlayerSkillLinkCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceListingCreateWithoutPlayerInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sellerTeam: TeamCreateNestedOneWithoutMarketplaceListingsInput
    currentHighBidderTeam?: TeamCreateNestedOneWithoutHighBidderOnListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
    history?: ListingHistoryCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutPlayerInput = {
    id?: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
    history?: ListingHistoryUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutPlayerInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerMarketValueCreateWithoutPlayerInput = {
    carRating: number
    potential: number
    minBuyNow: bigint | number
    marketValue: bigint | number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type PlayerMarketValueUncheckedCreateWithoutPlayerInput = {
    id?: number
    carRating: number
    potential: number
    minBuyNow: bigint | number
    marketValue: bigint | number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type PlayerMarketValueCreateOrConnectWithoutPlayerInput = {
    where: PlayerMarketValueWhereUniqueInput
    create: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
  }

  export type TryoutHistoryCreateWithoutPlayerInput = {
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    team: TeamCreateNestedOneWithoutTryoutHistoryInput
    season: SeasonCreateNestedOneWithoutTryoutHistoryInput
  }

  export type TryoutHistoryUncheckedCreateWithoutPlayerInput = {
    id?: number
    teamId: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
  }

  export type TryoutHistoryCreateOrConnectWithoutPlayerInput = {
    where: TryoutHistoryWhereUniqueInput
    create: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type TryoutHistoryCreateManyPlayerInputEnvelope = {
    data: TryoutHistoryCreateManyPlayerInput | TryoutHistoryCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ActiveBoostCreateWithoutPlayerInput = {
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
    team: TeamCreateNestedOneWithoutActiveBoostsInput
    item: ItemCreateNestedOneWithoutActiveBoostsInput
  }

  export type ActiveBoostUncheckedCreateWithoutPlayerInput = {
    id?: number
    teamId: number
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type ActiveBoostCreateOrConnectWithoutPlayerInput = {
    where: ActiveBoostWhereUniqueInput
    create: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput>
  }

  export type ActiveBoostCreateManyPlayerInputEnvelope = {
    data: ActiveBoostCreateManyPlayerInput | ActiveBoostCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerEquipmentCreateWithoutPlayerInput = {
    equippedAt?: Date | string
    item: ItemCreateNestedOneWithoutPlayerEquipmentInput
  }

  export type PlayerEquipmentUncheckedCreateWithoutPlayerInput = {
    id?: number
    itemId: number
    equippedAt?: Date | string
  }

  export type PlayerEquipmentCreateOrConnectWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    create: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEquipmentCreateManyPlayerInputEnvelope = {
    data: PlayerEquipmentCreateManyPlayerInput | PlayerEquipmentCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutPlayersInput = {
    update: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlayersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamUpdateWithoutPlayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type ContractUpsertWithoutPlayerInput = {
    update: XOR<ContractUpdateWithoutPlayerInput, ContractUncheckedUpdateWithoutPlayerInput>
    create: XOR<ContractCreateWithoutPlayerInput, ContractUncheckedCreateWithoutPlayerInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutPlayerInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutPlayerInput, ContractUncheckedUpdateWithoutPlayerInput>
  }

  export type ContractUpdateWithoutPlayerInput = {
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillLinkWhereUniqueInput
    update: XOR<PlayerSkillLinkUpdateWithoutPlayerInput, PlayerSkillLinkUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerSkillLinkCreateWithoutPlayerInput, PlayerSkillLinkUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillLinkUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillLinkWhereUniqueInput
    data: XOR<PlayerSkillLinkUpdateWithoutPlayerInput, PlayerSkillLinkUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillLinkUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerSkillLinkScalarWhereInput
    data: XOR<PlayerSkillLinkUpdateManyMutationInput, PlayerSkillLinkUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerSkillLinkScalarWhereInput = {
    AND?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
    OR?: PlayerSkillLinkScalarWhereInput[]
    NOT?: PlayerSkillLinkScalarWhereInput | PlayerSkillLinkScalarWhereInput[]
    id?: IntFilter<"PlayerSkillLink"> | number
    playerId?: IntFilter<"PlayerSkillLink"> | number
    skillId?: IntFilter<"PlayerSkillLink"> | number
    currentTier?: IntFilter<"PlayerSkillLink"> | number
    acquiredAt?: DateTimeFilter<"PlayerSkillLink"> | Date | string
  }

  export type MarketplaceListingUpsertWithoutPlayerInput = {
    update: XOR<MarketplaceListingUpdateWithoutPlayerInput, MarketplaceListingUncheckedUpdateWithoutPlayerInput>
    create: XOR<MarketplaceListingCreateWithoutPlayerInput, MarketplaceListingUncheckedCreateWithoutPlayerInput>
    where?: MarketplaceListingWhereInput
  }

  export type MarketplaceListingUpdateToOneWithWhereWithoutPlayerInput = {
    where?: MarketplaceListingWhereInput
    data: XOR<MarketplaceListingUpdateWithoutPlayerInput, MarketplaceListingUncheckedUpdateWithoutPlayerInput>
  }

  export type MarketplaceListingUpdateWithoutPlayerInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerTeam?: TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput
    currentHighBidderTeam?: TeamUpdateOneWithoutHighBidderOnListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUncheckedUpdateManyWithoutListingNestedInput
  }

  export type PlayerMarketValueUpsertWithoutPlayerInput = {
    update: XOR<PlayerMarketValueUpdateWithoutPlayerInput, PlayerMarketValueUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerMarketValueCreateWithoutPlayerInput, PlayerMarketValueUncheckedCreateWithoutPlayerInput>
    where?: PlayerMarketValueWhereInput
  }

  export type PlayerMarketValueUpdateToOneWithWhereWithoutPlayerInput = {
    where?: PlayerMarketValueWhereInput
    data: XOR<PlayerMarketValueUpdateWithoutPlayerInput, PlayerMarketValueUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerMarketValueUpdateWithoutPlayerInput = {
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMarketValueUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    carRating?: FloatFieldUpdateOperationsInput | number
    potential?: FloatFieldUpdateOperationsInput | number
    minBuyNow?: BigIntFieldUpdateOperationsInput | bigint | number
    marketValue?: BigIntFieldUpdateOperationsInput | bigint | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TryoutHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: TryoutHistoryWhereUniqueInput
    update: XOR<TryoutHistoryUpdateWithoutPlayerInput, TryoutHistoryUncheckedUpdateWithoutPlayerInput>
    create: XOR<TryoutHistoryCreateWithoutPlayerInput, TryoutHistoryUncheckedCreateWithoutPlayerInput>
  }

  export type TryoutHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: TryoutHistoryWhereUniqueInput
    data: XOR<TryoutHistoryUpdateWithoutPlayerInput, TryoutHistoryUncheckedUpdateWithoutPlayerInput>
  }

  export type TryoutHistoryUpdateManyWithWhereWithoutPlayerInput = {
    where: TryoutHistoryScalarWhereInput
    data: XOR<TryoutHistoryUpdateManyMutationInput, TryoutHistoryUncheckedUpdateManyWithoutPlayerInput>
  }

  export type ActiveBoostUpsertWithWhereUniqueWithoutPlayerInput = {
    where: ActiveBoostWhereUniqueInput
    update: XOR<ActiveBoostUpdateWithoutPlayerInput, ActiveBoostUncheckedUpdateWithoutPlayerInput>
    create: XOR<ActiveBoostCreateWithoutPlayerInput, ActiveBoostUncheckedCreateWithoutPlayerInput>
  }

  export type ActiveBoostUpdateWithWhereUniqueWithoutPlayerInput = {
    where: ActiveBoostWhereUniqueInput
    data: XOR<ActiveBoostUpdateWithoutPlayerInput, ActiveBoostUncheckedUpdateWithoutPlayerInput>
  }

  export type ActiveBoostUpdateManyWithWhereWithoutPlayerInput = {
    where: ActiveBoostScalarWhereInput
    data: XOR<ActiveBoostUpdateManyMutationInput, ActiveBoostUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerEquipmentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    update: XOR<PlayerEquipmentUpdateWithoutPlayerInput, PlayerEquipmentUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerEquipmentCreateWithoutPlayerInput, PlayerEquipmentUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEquipmentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEquipmentWhereUniqueInput
    data: XOR<PlayerEquipmentUpdateWithoutPlayerInput, PlayerEquipmentUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEquipmentUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerEquipmentScalarWhereInput
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerEquipmentScalarWhereInput = {
    AND?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
    OR?: PlayerEquipmentScalarWhereInput[]
    NOT?: PlayerEquipmentScalarWhereInput | PlayerEquipmentScalarWhereInput[]
    id?: IntFilter<"PlayerEquipment"> | number
    playerId?: IntFilter<"PlayerEquipment"> | number
    itemId?: IntFilter<"PlayerEquipment"> | number
    equippedAt?: DateTimeFilter<"PlayerEquipment"> | Date | string
  }

  export type PlayerCreateWithoutCurrentEquipmentInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCurrentEquipmentInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCurrentEquipmentInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCurrentEquipmentInput, PlayerUncheckedCreateWithoutCurrentEquipmentInput>
  }

  export type ItemCreateWithoutPlayerEquipmentInput = {
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPlayerEquipmentInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPlayerEquipmentInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPlayerEquipmentInput, ItemUncheckedCreateWithoutPlayerEquipmentInput>
  }

  export type PlayerUpsertWithoutCurrentEquipmentInput = {
    update: XOR<PlayerUpdateWithoutCurrentEquipmentInput, PlayerUncheckedUpdateWithoutCurrentEquipmentInput>
    create: XOR<PlayerCreateWithoutCurrentEquipmentInput, PlayerUncheckedCreateWithoutCurrentEquipmentInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCurrentEquipmentInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCurrentEquipmentInput, PlayerUncheckedUpdateWithoutCurrentEquipmentInput>
  }

  export type PlayerUpdateWithoutCurrentEquipmentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCurrentEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutPlayerEquipmentInput = {
    update: XOR<ItemUpdateWithoutPlayerEquipmentInput, ItemUncheckedUpdateWithoutPlayerEquipmentInput>
    create: XOR<ItemCreateWithoutPlayerEquipmentInput, ItemUncheckedCreateWithoutPlayerEquipmentInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPlayerEquipmentInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPlayerEquipmentInput, ItemUncheckedUpdateWithoutPlayerEquipmentInput>
  }

  export type ItemUpdateWithoutPlayerEquipmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPlayerEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PlayerCreateWithoutContractInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutContractInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutContractInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutContractInput, PlayerUncheckedCreateWithoutContractInput>
  }

  export type StaffCreateWithoutContractInput = {
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutContractInput = {
    id?: number
    teamId: number
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutContractInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutContractInput, StaffUncheckedCreateWithoutContractInput>
  }

  export type PlayerUpsertWithoutContractInput = {
    update: XOR<PlayerUpdateWithoutContractInput, PlayerUncheckedUpdateWithoutContractInput>
    create: XOR<PlayerCreateWithoutContractInput, PlayerUncheckedCreateWithoutContractInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutContractInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutContractInput, PlayerUncheckedUpdateWithoutContractInput>
  }

  export type PlayerUpdateWithoutContractInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type StaffUpsertWithoutContractInput = {
    update: XOR<StaffUpdateWithoutContractInput, StaffUncheckedUpdateWithoutContractInput>
    create: XOR<StaffCreateWithoutContractInput, StaffUncheckedCreateWithoutContractInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutContractInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutContractInput, StaffUncheckedUpdateWithoutContractInput>
  }

  export type StaffUpdateWithoutContractInput = {
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkCreateWithoutSkillInput = {
    currentTier?: number
    acquiredAt?: Date | string
    player: PlayerCreateNestedOneWithoutSkillsInput
  }

  export type PlayerSkillLinkUncheckedCreateWithoutSkillInput = {
    id?: number
    playerId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type PlayerSkillLinkCreateOrConnectWithoutSkillInput = {
    where: PlayerSkillLinkWhereUniqueInput
    create: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput>
  }

  export type PlayerSkillLinkCreateManySkillInputEnvelope = {
    data: PlayerSkillLinkCreateManySkillInput | PlayerSkillLinkCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type PlayerSkillLinkUpsertWithWhereUniqueWithoutSkillInput = {
    where: PlayerSkillLinkWhereUniqueInput
    update: XOR<PlayerSkillLinkUpdateWithoutSkillInput, PlayerSkillLinkUncheckedUpdateWithoutSkillInput>
    create: XOR<PlayerSkillLinkCreateWithoutSkillInput, PlayerSkillLinkUncheckedCreateWithoutSkillInput>
  }

  export type PlayerSkillLinkUpdateWithWhereUniqueWithoutSkillInput = {
    where: PlayerSkillLinkWhereUniqueInput
    data: XOR<PlayerSkillLinkUpdateWithoutSkillInput, PlayerSkillLinkUncheckedUpdateWithoutSkillInput>
  }

  export type PlayerSkillLinkUpdateManyWithWhereWithoutSkillInput = {
    where: PlayerSkillLinkScalarWhereInput
    data: XOR<PlayerSkillLinkUpdateManyMutationInput, PlayerSkillLinkUncheckedUpdateManyWithoutSkillInput>
  }

  export type PlayerCreateWithoutSkillsInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSkillsInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSkillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutPlayerLinksInput = {
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonNullValueInput | InputJsonValue
  }

  export type SkillUncheckedCreateWithoutPlayerLinksInput = {
    id?: number
    name: string
    description: string
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    tiers: JsonNullValueInput | InputJsonValue
  }

  export type SkillCreateOrConnectWithoutPlayerLinksInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutPlayerLinksInput, SkillUncheckedCreateWithoutPlayerLinksInput>
  }

  export type PlayerUpsertWithoutSkillsInput = {
    update: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSkillsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type PlayerUpdateWithoutSkillsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SkillUpsertWithoutPlayerLinksInput = {
    update: XOR<SkillUpdateWithoutPlayerLinksInput, SkillUncheckedUpdateWithoutPlayerLinksInput>
    create: XOR<SkillCreateWithoutPlayerLinksInput, SkillUncheckedCreateWithoutPlayerLinksInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutPlayerLinksInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutPlayerLinksInput, SkillUncheckedUpdateWithoutPlayerLinksInput>
  }

  export type SkillUpdateWithoutPlayerLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
  }

  export type SkillUncheckedUpdateWithoutPlayerLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    tiers?: JsonNullValueInput | InputJsonValue
  }

  export type TeamCreateWithoutStaffInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutStaffInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutStaffInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutStaffInput, TeamUncheckedCreateWithoutStaffInput>
  }

  export type ContractCreateWithoutStaffInput = {
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
    player?: PlayerCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutStaffInput = {
    id?: number
    playerId?: number | null
    salary: number
    length: number
    signingBonus?: number
    startDate?: Date | string
  }

  export type ContractCreateOrConnectWithoutStaffInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
  }

  export type TeamUpsertWithoutStaffInput = {
    update: XOR<TeamUpdateWithoutStaffInput, TeamUncheckedUpdateWithoutStaffInput>
    create: XOR<TeamCreateWithoutStaffInput, TeamUncheckedCreateWithoutStaffInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutStaffInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutStaffInput, TeamUncheckedUpdateWithoutStaffInput>
  }

  export type TeamUpdateWithoutStaffInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type ContractUpsertWithoutStaffInput = {
    update: XOR<ContractUpdateWithoutStaffInput, ContractUncheckedUpdateWithoutStaffInput>
    create: XOR<ContractCreateWithoutStaffInput, ContractUncheckedCreateWithoutStaffInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutStaffInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutStaffInput, ContractUncheckedUpdateWithoutStaffInput>
  }

  export type ContractUpdateWithoutStaffInput = {
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    signingBonus?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateWithoutFinancesInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutFinancesInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutFinancesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutFinancesInput, TeamUncheckedCreateWithoutFinancesInput>
  }

  export type TeamUpsertWithoutFinancesInput = {
    update: XOR<TeamUpdateWithoutFinancesInput, TeamUncheckedUpdateWithoutFinancesInput>
    create: XOR<TeamCreateWithoutFinancesInput, TeamUncheckedCreateWithoutFinancesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutFinancesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutFinancesInput, TeamUncheckedUpdateWithoutFinancesInput>
  }

  export type TeamUpdateWithoutFinancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutFinancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamCreateWithoutStadiumInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutStadiumInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutStadiumInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutStadiumInput, TeamUncheckedCreateWithoutStadiumInput>
  }

  export type TeamUpsertWithoutStadiumInput = {
    update: XOR<TeamUpdateWithoutStadiumInput, TeamUncheckedUpdateWithoutStadiumInput>
    create: XOR<TeamCreateWithoutStadiumInput, TeamUncheckedCreateWithoutStadiumInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutStadiumInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutStadiumInput, TeamUncheckedUpdateWithoutStadiumInput>
  }

  export type TeamUpdateWithoutStadiumInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutStadiumInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type InventoryItemCreateWithoutItemInput = {
    quantity: number
    acquiredAt?: Date | string
    team: TeamCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutItemInput = {
    id?: number
    teamId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemCreateManyItemInputEnvelope = {
    data: InventoryItemCreateManyItemInput | InventoryItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ActiveBoostCreateWithoutItemInput = {
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
    team: TeamCreateNestedOneWithoutActiveBoostsInput
    player?: PlayerCreateNestedOneWithoutActiveBoostsInput
  }

  export type ActiveBoostUncheckedCreateWithoutItemInput = {
    id?: number
    teamId: number
    playerId?: number | null
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type ActiveBoostCreateOrConnectWithoutItemInput = {
    where: ActiveBoostWhereUniqueInput
    create: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput>
  }

  export type ActiveBoostCreateManyItemInputEnvelope = {
    data: ActiveBoostCreateManyItemInput | ActiveBoostCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PlayerEquipmentCreateWithoutItemInput = {
    equippedAt?: Date | string
    player: PlayerCreateNestedOneWithoutCurrentEquipmentInput
  }

  export type PlayerEquipmentUncheckedCreateWithoutItemInput = {
    id?: number
    playerId: number
    equippedAt?: Date | string
  }

  export type PlayerEquipmentCreateOrConnectWithoutItemInput = {
    where: PlayerEquipmentWhereUniqueInput
    create: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput>
  }

  export type PlayerEquipmentCreateManyItemInputEnvelope = {
    data: PlayerEquipmentCreateManyItemInput | PlayerEquipmentCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentRewardCreateWithoutItemInput = {
    boxId: number
    rarity: $Enums.ItemRarity
    weight: number
  }

  export type EquipmentRewardUncheckedCreateWithoutItemInput = {
    id?: number
    boxId: number
    rarity: $Enums.ItemRarity
    weight: number
  }

  export type EquipmentRewardCreateOrConnectWithoutItemInput = {
    where: EquipmentRewardWhereUniqueInput
    create: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput>
  }

  export type EquipmentRewardCreateManyItemInputEnvelope = {
    data: EquipmentRewardCreateManyItemInput | EquipmentRewardCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutItemInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutItemInput>
  }

  export type ActiveBoostUpsertWithWhereUniqueWithoutItemInput = {
    where: ActiveBoostWhereUniqueInput
    update: XOR<ActiveBoostUpdateWithoutItemInput, ActiveBoostUncheckedUpdateWithoutItemInput>
    create: XOR<ActiveBoostCreateWithoutItemInput, ActiveBoostUncheckedCreateWithoutItemInput>
  }

  export type ActiveBoostUpdateWithWhereUniqueWithoutItemInput = {
    where: ActiveBoostWhereUniqueInput
    data: XOR<ActiveBoostUpdateWithoutItemInput, ActiveBoostUncheckedUpdateWithoutItemInput>
  }

  export type ActiveBoostUpdateManyWithWhereWithoutItemInput = {
    where: ActiveBoostScalarWhereInput
    data: XOR<ActiveBoostUpdateManyMutationInput, ActiveBoostUncheckedUpdateManyWithoutItemInput>
  }

  export type PlayerEquipmentUpsertWithWhereUniqueWithoutItemInput = {
    where: PlayerEquipmentWhereUniqueInput
    update: XOR<PlayerEquipmentUpdateWithoutItemInput, PlayerEquipmentUncheckedUpdateWithoutItemInput>
    create: XOR<PlayerEquipmentCreateWithoutItemInput, PlayerEquipmentUncheckedCreateWithoutItemInput>
  }

  export type PlayerEquipmentUpdateWithWhereUniqueWithoutItemInput = {
    where: PlayerEquipmentWhereUniqueInput
    data: XOR<PlayerEquipmentUpdateWithoutItemInput, PlayerEquipmentUncheckedUpdateWithoutItemInput>
  }

  export type PlayerEquipmentUpdateManyWithWhereWithoutItemInput = {
    where: PlayerEquipmentScalarWhereInput
    data: XOR<PlayerEquipmentUpdateManyMutationInput, PlayerEquipmentUncheckedUpdateManyWithoutItemInput>
  }

  export type EquipmentRewardUpsertWithWhereUniqueWithoutItemInput = {
    where: EquipmentRewardWhereUniqueInput
    update: XOR<EquipmentRewardUpdateWithoutItemInput, EquipmentRewardUncheckedUpdateWithoutItemInput>
    create: XOR<EquipmentRewardCreateWithoutItemInput, EquipmentRewardUncheckedCreateWithoutItemInput>
  }

  export type EquipmentRewardUpdateWithWhereUniqueWithoutItemInput = {
    where: EquipmentRewardWhereUniqueInput
    data: XOR<EquipmentRewardUpdateWithoutItemInput, EquipmentRewardUncheckedUpdateWithoutItemInput>
  }

  export type EquipmentRewardUpdateManyWithWhereWithoutItemInput = {
    where: EquipmentRewardScalarWhereInput
    data: XOR<EquipmentRewardUpdateManyMutationInput, EquipmentRewardUncheckedUpdateManyWithoutItemInput>
  }

  export type EquipmentRewardScalarWhereInput = {
    AND?: EquipmentRewardScalarWhereInput | EquipmentRewardScalarWhereInput[]
    OR?: EquipmentRewardScalarWhereInput[]
    NOT?: EquipmentRewardScalarWhereInput | EquipmentRewardScalarWhereInput[]
    id?: IntFilter<"EquipmentReward"> | number
    boxId?: IntFilter<"EquipmentReward"> | number
    itemId?: IntFilter<"EquipmentReward"> | number
    rarity?: EnumItemRarityFilter<"EquipmentReward"> | $Enums.ItemRarity
    weight?: FloatFilter<"EquipmentReward"> | number
  }

  export type TeamCreateWithoutInventoryItemsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutInventoryItemsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutInventoryItemsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInventoryItemsInput, TeamUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ItemCreateWithoutInventoryItemsInput = {
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    activeBoosts?: ActiveBoostCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInventoryItemsInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInventoryItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
  }

  export type TeamUpsertWithoutInventoryItemsInput = {
    update: XOR<TeamUpdateWithoutInventoryItemsInput, TeamUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<TeamCreateWithoutInventoryItemsInput, TeamUncheckedCreateWithoutInventoryItemsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutInventoryItemsInput, TeamUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type TeamUpdateWithoutInventoryItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInventoryItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type ItemUpsertWithoutInventoryItemsInput = {
    update: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ItemUpdateWithoutInventoryItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    activeBoosts?: ActiveBoostUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUncheckedUpdateManyWithoutItemNestedInput
  }

  export type TeamCreateWithoutActiveBoostsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutActiveBoostsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutActiveBoostsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutActiveBoostsInput, TeamUncheckedCreateWithoutActiveBoostsInput>
  }

  export type PlayerCreateWithoutActiveBoostsInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutActiveBoostsInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutActiveBoostsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutActiveBoostsInput, PlayerUncheckedCreateWithoutActiveBoostsInput>
  }

  export type ItemCreateWithoutActiveBoostsInput = {
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutActiveBoostsInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutItemInput
    PremiumBoxRewards?: EquipmentRewardUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutActiveBoostsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutActiveBoostsInput, ItemUncheckedCreateWithoutActiveBoostsInput>
  }

  export type TeamUpsertWithoutActiveBoostsInput = {
    update: XOR<TeamUpdateWithoutActiveBoostsInput, TeamUncheckedUpdateWithoutActiveBoostsInput>
    create: XOR<TeamCreateWithoutActiveBoostsInput, TeamUncheckedCreateWithoutActiveBoostsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutActiveBoostsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutActiveBoostsInput, TeamUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type TeamUpdateWithoutActiveBoostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutActiveBoostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type PlayerUpsertWithoutActiveBoostsInput = {
    update: XOR<PlayerUpdateWithoutActiveBoostsInput, PlayerUncheckedUpdateWithoutActiveBoostsInput>
    create: XOR<PlayerCreateWithoutActiveBoostsInput, PlayerUncheckedCreateWithoutActiveBoostsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutActiveBoostsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutActiveBoostsInput, PlayerUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type PlayerUpdateWithoutActiveBoostsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutActiveBoostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutActiveBoostsInput = {
    update: XOR<ItemUpdateWithoutActiveBoostsInput, ItemUncheckedUpdateWithoutActiveBoostsInput>
    create: XOR<ItemCreateWithoutActiveBoostsInput, ItemUncheckedCreateWithoutActiveBoostsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutActiveBoostsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutActiveBoostsInput, ItemUncheckedUpdateWithoutActiveBoostsInput>
  }

  export type ItemUpdateWithoutActiveBoostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutActiveBoostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutItemNestedInput
    PremiumBoxRewards?: EquipmentRewardUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PlayerCreateWithoutMarketplaceListingInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMarketplaceListingInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMarketplaceListingInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarketplaceListingInput, PlayerUncheckedCreateWithoutMarketplaceListingInput>
  }

  export type TeamCreateWithoutMarketplaceListingsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutMarketplaceListingsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutMarketplaceListingsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMarketplaceListingsInput, TeamUncheckedCreateWithoutMarketplaceListingsInput>
  }

  export type TeamCreateWithoutHighBidderOnListingsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutHighBidderOnListingsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutHighBidderOnListingsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutHighBidderOnListingsInput, TeamUncheckedCreateWithoutHighBidderOnListingsInput>
  }

  export type BidCreateWithoutListingInput = {
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
    bidderTeam: TeamCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutListingInput = {
    id?: number
    bidderTeamId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutListingInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput>
  }

  export type BidCreateManyListingInputEnvelope = {
    data: BidCreateManyListingInput | BidCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type ListingHistoryCreateWithoutListingInput = {
    actionType: $Enums.ListingActionType
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
    team?: TeamCreateNestedOneWithoutListingHistoryInput
  }

  export type ListingHistoryUncheckedCreateWithoutListingInput = {
    id?: number
    actionType: $Enums.ListingActionType
    teamId?: number | null
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type ListingHistoryCreateOrConnectWithoutListingInput = {
    where: ListingHistoryWhereUniqueInput
    create: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput>
  }

  export type ListingHistoryCreateManyListingInputEnvelope = {
    data: ListingHistoryCreateManyListingInput | ListingHistoryCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutMarketplaceListingInput = {
    update: XOR<PlayerUpdateWithoutMarketplaceListingInput, PlayerUncheckedUpdateWithoutMarketplaceListingInput>
    create: XOR<PlayerCreateWithoutMarketplaceListingInput, PlayerUncheckedCreateWithoutMarketplaceListingInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMarketplaceListingInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMarketplaceListingInput, PlayerUncheckedUpdateWithoutMarketplaceListingInput>
  }

  export type PlayerUpdateWithoutMarketplaceListingInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarketplaceListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type TeamUpsertWithoutMarketplaceListingsInput = {
    update: XOR<TeamUpdateWithoutMarketplaceListingsInput, TeamUncheckedUpdateWithoutMarketplaceListingsInput>
    create: XOR<TeamCreateWithoutMarketplaceListingsInput, TeamUncheckedCreateWithoutMarketplaceListingsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMarketplaceListingsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMarketplaceListingsInput, TeamUncheckedUpdateWithoutMarketplaceListingsInput>
  }

  export type TeamUpdateWithoutMarketplaceListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMarketplaceListingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUpsertWithoutHighBidderOnListingsInput = {
    update: XOR<TeamUpdateWithoutHighBidderOnListingsInput, TeamUncheckedUpdateWithoutHighBidderOnListingsInput>
    create: XOR<TeamCreateWithoutHighBidderOnListingsInput, TeamUncheckedCreateWithoutHighBidderOnListingsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutHighBidderOnListingsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutHighBidderOnListingsInput, TeamUncheckedUpdateWithoutHighBidderOnListingsInput>
  }

  export type TeamUpdateWithoutHighBidderOnListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutHighBidderOnListingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type BidUpsertWithWhereUniqueWithoutListingInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutListingInput, BidUncheckedUpdateWithoutListingInput>
    create: XOR<BidCreateWithoutListingInput, BidUncheckedCreateWithoutListingInput>
  }

  export type BidUpdateWithWhereUniqueWithoutListingInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutListingInput, BidUncheckedUpdateWithoutListingInput>
  }

  export type BidUpdateManyWithWhereWithoutListingInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutListingInput>
  }

  export type ListingHistoryUpsertWithWhereUniqueWithoutListingInput = {
    where: ListingHistoryWhereUniqueInput
    update: XOR<ListingHistoryUpdateWithoutListingInput, ListingHistoryUncheckedUpdateWithoutListingInput>
    create: XOR<ListingHistoryCreateWithoutListingInput, ListingHistoryUncheckedCreateWithoutListingInput>
  }

  export type ListingHistoryUpdateWithWhereUniqueWithoutListingInput = {
    where: ListingHistoryWhereUniqueInput
    data: XOR<ListingHistoryUpdateWithoutListingInput, ListingHistoryUncheckedUpdateWithoutListingInput>
  }

  export type ListingHistoryUpdateManyWithWhereWithoutListingInput = {
    where: ListingHistoryScalarWhereInput
    data: XOR<ListingHistoryUpdateManyMutationInput, ListingHistoryUncheckedUpdateManyWithoutListingInput>
  }

  export type MarketplaceListingCreateWithoutBidsInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketplaceListingInput
    sellerTeam: TeamCreateNestedOneWithoutMarketplaceListingsInput
    currentHighBidderTeam?: TeamCreateNestedOneWithoutHighBidderOnListingsInput
    history?: ListingHistoryCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutBidsInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: ListingHistoryUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutBidsInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
  }

  export type TeamCreateWithoutBidsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutBidsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutBidsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutBidsInput, TeamUncheckedCreateWithoutBidsInput>
  }

  export type MarketplaceListingUpsertWithoutBidsInput = {
    update: XOR<MarketplaceListingUpdateWithoutBidsInput, MarketplaceListingUncheckedUpdateWithoutBidsInput>
    create: XOR<MarketplaceListingCreateWithoutBidsInput, MarketplaceListingUncheckedCreateWithoutBidsInput>
    where?: MarketplaceListingWhereInput
  }

  export type MarketplaceListingUpdateToOneWithWhereWithoutBidsInput = {
    where?: MarketplaceListingWhereInput
    data: XOR<MarketplaceListingUpdateWithoutBidsInput, MarketplaceListingUncheckedUpdateWithoutBidsInput>
  }

  export type MarketplaceListingUpdateWithoutBidsInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput
    sellerTeam?: TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput
    currentHighBidderTeam?: TeamUpdateOneWithoutHighBidderOnListingsNestedInput
    history?: ListingHistoryUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutBidsInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: ListingHistoryUncheckedUpdateManyWithoutListingNestedInput
  }

  export type TeamUpsertWithoutBidsInput = {
    update: XOR<TeamUpdateWithoutBidsInput, TeamUncheckedUpdateWithoutBidsInput>
    create: XOR<TeamCreateWithoutBidsInput, TeamUncheckedCreateWithoutBidsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutBidsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutBidsInput, TeamUncheckedUpdateWithoutBidsInput>
  }

  export type TeamUpdateWithoutBidsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutBidsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type MarketplaceListingCreateWithoutHistoryInput = {
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutMarketplaceListingInput
    sellerTeam: TeamCreateNestedOneWithoutMarketplaceListingsInput
    currentHighBidderTeam?: TeamCreateNestedOneWithoutHighBidderOnListingsInput
    bids?: BidCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingUncheckedCreateWithoutHistoryInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutListingInput
  }

  export type MarketplaceListingCreateOrConnectWithoutHistoryInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutHistoryInput, MarketplaceListingUncheckedCreateWithoutHistoryInput>
  }

  export type TeamCreateWithoutListingHistoryInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutListingHistoryInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutListingHistoryInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutListingHistoryInput, TeamUncheckedCreateWithoutListingHistoryInput>
  }

  export type MarketplaceListingUpsertWithoutHistoryInput = {
    update: XOR<MarketplaceListingUpdateWithoutHistoryInput, MarketplaceListingUncheckedUpdateWithoutHistoryInput>
    create: XOR<MarketplaceListingCreateWithoutHistoryInput, MarketplaceListingUncheckedCreateWithoutHistoryInput>
    where?: MarketplaceListingWhereInput
  }

  export type MarketplaceListingUpdateToOneWithWhereWithoutHistoryInput = {
    where?: MarketplaceListingWhereInput
    data: XOR<MarketplaceListingUpdateWithoutHistoryInput, MarketplaceListingUncheckedUpdateWithoutHistoryInput>
  }

  export type MarketplaceListingUpdateWithoutHistoryInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput
    sellerTeam?: TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput
    currentHighBidderTeam?: TeamUpdateOneWithoutHighBidderOnListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
  }

  export type TeamUpsertWithoutListingHistoryInput = {
    update: XOR<TeamUpdateWithoutListingHistoryInput, TeamUncheckedUpdateWithoutListingHistoryInput>
    create: XOR<TeamCreateWithoutListingHistoryInput, TeamUncheckedCreateWithoutListingHistoryInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutListingHistoryInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutListingHistoryInput, TeamUncheckedUpdateWithoutListingHistoryInput>
  }

  export type TeamUpdateWithoutListingHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutListingHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type PlayerCreateWithoutMarketValueInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMarketValueInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMarketValueInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarketValueInput, PlayerUncheckedCreateWithoutMarketValueInput>
  }

  export type PlayerUpsertWithoutMarketValueInput = {
    update: XOR<PlayerUpdateWithoutMarketValueInput, PlayerUncheckedUpdateWithoutMarketValueInput>
    create: XOR<PlayerCreateWithoutMarketValueInput, PlayerUncheckedCreateWithoutMarketValueInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMarketValueInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMarketValueInput, PlayerUncheckedUpdateWithoutMarketValueInput>
  }

  export type PlayerUpdateWithoutMarketValueInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarketValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type TeamCreateWithoutStrategyInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutStrategyInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutStrategyInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutStrategyInput, TeamUncheckedCreateWithoutStrategyInput>
  }

  export type TeamUpsertWithoutStrategyInput = {
    update: XOR<TeamUpdateWithoutStrategyInput, TeamUncheckedUpdateWithoutStrategyInput>
    create: XOR<TeamCreateWithoutStrategyInput, TeamUncheckedCreateWithoutStrategyInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutStrategyInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutStrategyInput, TeamUncheckedUpdateWithoutStrategyInput>
  }

  export type TeamUpdateWithoutStrategyInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutStrategyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamCreateWithoutLeagueInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutLeagueInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamCreateManyLeagueInputEnvelope = {
    data: TeamCreateManyLeagueInput | TeamCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutLeagueInput = {
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
    homeTeam: TeamCreateNestedOneWithoutHomeTeamGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayTeamGamesInput
    tournament?: TournamentCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutLeagueInput = {
    id?: number
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameCreateOrConnectWithoutLeagueInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameCreateManyLeagueInputEnvelope = {
    data: GameCreateManyLeagueInput | GameCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type LeagueStandingCreateWithoutLeagueInput = {
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
  }

  export type LeagueStandingUncheckedCreateWithoutLeagueInput = {
    id?: number
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
  }

  export type LeagueStandingCreateOrConnectWithoutLeagueInput = {
    where: LeagueStandingWhereUniqueInput
    create: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput>
  }

  export type LeagueStandingCreateManyLeagueInputEnvelope = {
    data: LeagueStandingCreateManyLeagueInput | LeagueStandingCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type SeasonCreateWithoutLeaguesInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutLeaguesInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutLeaguesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutLeaguesInput, SeasonUncheckedCreateWithoutLeaguesInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
  }

  export type TeamUpdateManyWithWhereWithoutLeagueInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutLeagueInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    userProfileId?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    isAI?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    camaraderie?: FloatFilter<"Team"> | number
    fanLoyalty?: FloatFilter<"Team"> | number
    homeField?: EnumFieldSizeFilter<"Team"> | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFilter<"Team"> | $Enums.TacticalFocus
    leagueId?: IntNullableFilter<"Team"> | number | null
    division?: IntNullableFilter<"Team"> | number | null
    subdivision?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    points?: IntFilter<"Team"> | number
  }

  export type GameUpsertWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameUpdateWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
  }

  export type GameUpdateManyWithWhereWithoutLeagueInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutLeagueInput>
  }

  export type LeagueStandingUpsertWithWhereUniqueWithoutLeagueInput = {
    where: LeagueStandingWhereUniqueInput
    update: XOR<LeagueStandingUpdateWithoutLeagueInput, LeagueStandingUncheckedUpdateWithoutLeagueInput>
    create: XOR<LeagueStandingCreateWithoutLeagueInput, LeagueStandingUncheckedCreateWithoutLeagueInput>
  }

  export type LeagueStandingUpdateWithWhereUniqueWithoutLeagueInput = {
    where: LeagueStandingWhereUniqueInput
    data: XOR<LeagueStandingUpdateWithoutLeagueInput, LeagueStandingUncheckedUpdateWithoutLeagueInput>
  }

  export type LeagueStandingUpdateManyWithWhereWithoutLeagueInput = {
    where: LeagueStandingScalarWhereInput
    data: XOR<LeagueStandingUpdateManyMutationInput, LeagueStandingUncheckedUpdateManyWithoutLeagueInput>
  }

  export type LeagueStandingScalarWhereInput = {
    AND?: LeagueStandingScalarWhereInput | LeagueStandingScalarWhereInput[]
    OR?: LeagueStandingScalarWhereInput[]
    NOT?: LeagueStandingScalarWhereInput | LeagueStandingScalarWhereInput[]
    id?: IntFilter<"LeagueStanding"> | number
    leagueId?: IntFilter<"LeagueStanding"> | number
    teamId?: IntFilter<"LeagueStanding"> | number
    teamName?: StringFilter<"LeagueStanding"> | string
    wins?: IntFilter<"LeagueStanding"> | number
    losses?: IntFilter<"LeagueStanding"> | number
    ties?: IntFilter<"LeagueStanding"> | number
    pointsFor?: IntFilter<"LeagueStanding"> | number
    pointsAgainst?: IntFilter<"LeagueStanding"> | number
    pointDifferential?: IntFilter<"LeagueStanding"> | number
    streak?: StringFilter<"LeagueStanding"> | string
    rank?: IntFilter<"LeagueStanding"> | number
    updatedAt?: DateTimeFilter<"LeagueStanding"> | Date | string
  }

  export type SeasonUpsertWithoutLeaguesInput = {
    update: XOR<SeasonUpdateWithoutLeaguesInput, SeasonUncheckedUpdateWithoutLeaguesInput>
    create: XOR<SeasonCreateWithoutLeaguesInput, SeasonUncheckedCreateWithoutLeaguesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutLeaguesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutLeaguesInput, SeasonUncheckedUpdateWithoutLeaguesInput>
  }

  export type SeasonUpdateWithoutLeaguesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tryoutHistory?: TryoutHistoryUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutLeaguesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type LeagueCreateWithoutStandingsInput = {
    division: number
    name: string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    schedule?: GameCreateNestedManyWithoutLeagueInput
    season: SeasonCreateNestedOneWithoutLeaguesInput
  }

  export type LeagueUncheckedCreateWithoutStandingsInput = {
    id?: number
    division: number
    name: string
    seasonId: string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    schedule?: GameUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutStandingsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutStandingsInput, LeagueUncheckedCreateWithoutStandingsInput>
  }

  export type LeagueUpsertWithoutStandingsInput = {
    update: XOR<LeagueUpdateWithoutStandingsInput, LeagueUncheckedUpdateWithoutStandingsInput>
    create: XOR<LeagueCreateWithoutStandingsInput, LeagueUncheckedCreateWithoutStandingsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutStandingsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutStandingsInput, LeagueUncheckedUpdateWithoutStandingsInput>
  }

  export type LeagueUpdateWithoutStandingsInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    schedule?: GameUpdateManyWithoutLeagueNestedInput
    season?: SeasonUpdateOneRequiredWithoutLeaguesNestedInput
  }

  export type LeagueUncheckedUpdateWithoutStandingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    schedule?: GameUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateWithoutScheduleInput = {
    division: number
    name: string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingCreateNestedManyWithoutLeagueInput
    season: SeasonCreateNestedOneWithoutLeaguesInput
  }

  export type LeagueUncheckedCreateWithoutScheduleInput = {
    id?: number
    division: number
    name: string
    seasonId: string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutScheduleInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutScheduleInput, LeagueUncheckedCreateWithoutScheduleInput>
  }

  export type TeamCreateWithoutHomeTeamGamesInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutHomeTeamGamesInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutHomeTeamGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutHomeTeamGamesInput, TeamUncheckedCreateWithoutHomeTeamGamesInput>
  }

  export type TeamCreateWithoutAwayTeamGamesInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
  }

  export type TeamUncheckedCreateWithoutAwayTeamGamesInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
  }

  export type TeamCreateOrConnectWithoutAwayTeamGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAwayTeamGamesInput, TeamUncheckedCreateWithoutAwayTeamGamesInput>
  }

  export type TournamentCreateWithoutGamesInput = {
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    entries?: TournamentEntryCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    entries?: TournamentEntryUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutGamesInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutGamesInput, TournamentUncheckedCreateWithoutGamesInput>
  }

  export type LeagueUpsertWithoutScheduleInput = {
    update: XOR<LeagueUpdateWithoutScheduleInput, LeagueUncheckedUpdateWithoutScheduleInput>
    create: XOR<LeagueCreateWithoutScheduleInput, LeagueUncheckedCreateWithoutScheduleInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutScheduleInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutScheduleInput, LeagueUncheckedUpdateWithoutScheduleInput>
  }

  export type LeagueUpdateWithoutScheduleInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUpdateManyWithoutLeagueNestedInput
    season?: SeasonUpdateOneRequiredWithoutLeaguesNestedInput
  }

  export type LeagueUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type TeamUpsertWithoutHomeTeamGamesInput = {
    update: XOR<TeamUpdateWithoutHomeTeamGamesInput, TeamUncheckedUpdateWithoutHomeTeamGamesInput>
    create: XOR<TeamCreateWithoutHomeTeamGamesInput, TeamUncheckedCreateWithoutHomeTeamGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutHomeTeamGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutHomeTeamGamesInput, TeamUncheckedUpdateWithoutHomeTeamGamesInput>
  }

  export type TeamUpdateWithoutHomeTeamGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutHomeTeamGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUpsertWithoutAwayTeamGamesInput = {
    update: XOR<TeamUpdateWithoutAwayTeamGamesInput, TeamUncheckedUpdateWithoutAwayTeamGamesInput>
    create: XOR<TeamCreateWithoutAwayTeamGamesInput, TeamUncheckedCreateWithoutAwayTeamGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAwayTeamGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAwayTeamGamesInput, TeamUncheckedUpdateWithoutAwayTeamGamesInput>
  }

  export type TeamUpdateWithoutAwayTeamGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAwayTeamGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
  }

  export type TournamentUpsertWithoutGamesInput = {
    update: XOR<TournamentUpdateWithoutGamesInput, TournamentUncheckedUpdateWithoutGamesInput>
    create: XOR<TournamentCreateWithoutGamesInput, TournamentUncheckedCreateWithoutGamesInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutGamesInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutGamesInput, TournamentUncheckedUpdateWithoutGamesInput>
  }

  export type TournamentUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: TournamentEntryUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: TournamentEntryUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type LeagueCreateWithoutSeasonInput = {
    division: number
    name: string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    schedule?: GameCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutSeasonInput = {
    id?: number
    division: number
    name: string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    schedule?: GameUncheckedCreateNestedManyWithoutLeagueInput
    standings?: LeagueStandingUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutSeasonInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput>
  }

  export type LeagueCreateManySeasonInputEnvelope = {
    data: LeagueCreateManySeasonInput | LeagueCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type TryoutHistoryCreateWithoutSeasonInput = {
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    team: TeamCreateNestedOneWithoutTryoutHistoryInput
    player?: PlayerCreateNestedOneWithoutTryoutHistoryInput
  }

  export type TryoutHistoryUncheckedCreateWithoutSeasonInput = {
    id?: number
    teamId: number
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type TryoutHistoryCreateOrConnectWithoutSeasonInput = {
    where: TryoutHistoryWhereUniqueInput
    create: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput>
  }

  export type TryoutHistoryCreateManySeasonInputEnvelope = {
    data: TryoutHistoryCreateManySeasonInput | TryoutHistoryCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithWhereUniqueWithoutSeasonInput = {
    where: LeagueWhereUniqueInput
    update: XOR<LeagueUpdateWithoutSeasonInput, LeagueUncheckedUpdateWithoutSeasonInput>
    create: XOR<LeagueCreateWithoutSeasonInput, LeagueUncheckedCreateWithoutSeasonInput>
  }

  export type LeagueUpdateWithWhereUniqueWithoutSeasonInput = {
    where: LeagueWhereUniqueInput
    data: XOR<LeagueUpdateWithoutSeasonInput, LeagueUncheckedUpdateWithoutSeasonInput>
  }

  export type LeagueUpdateManyWithWhereWithoutSeasonInput = {
    where: LeagueScalarWhereInput
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyWithoutSeasonInput>
  }

  export type LeagueScalarWhereInput = {
    AND?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    OR?: LeagueScalarWhereInput[]
    NOT?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    id?: IntFilter<"League"> | number
    division?: IntFilter<"League"> | number
    name?: StringFilter<"League"> | string
    seasonId?: StringFilter<"League"> | string
  }

  export type TryoutHistoryUpsertWithWhereUniqueWithoutSeasonInput = {
    where: TryoutHistoryWhereUniqueInput
    update: XOR<TryoutHistoryUpdateWithoutSeasonInput, TryoutHistoryUncheckedUpdateWithoutSeasonInput>
    create: XOR<TryoutHistoryCreateWithoutSeasonInput, TryoutHistoryUncheckedCreateWithoutSeasonInput>
  }

  export type TryoutHistoryUpdateWithWhereUniqueWithoutSeasonInput = {
    where: TryoutHistoryWhereUniqueInput
    data: XOR<TryoutHistoryUpdateWithoutSeasonInput, TryoutHistoryUncheckedUpdateWithoutSeasonInput>
  }

  export type TryoutHistoryUpdateManyWithWhereWithoutSeasonInput = {
    where: TryoutHistoryScalarWhereInput
    data: XOR<TryoutHistoryUpdateManyMutationInput, TryoutHistoryUncheckedUpdateManyWithoutSeasonInput>
  }

  export type TeamCreateWithoutNotificationsInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutNotificationsInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutNotificationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutNotificationsInput, TeamUncheckedCreateWithoutNotificationsInput>
  }

  export type TeamUpsertWithoutNotificationsInput = {
    update: XOR<TeamUpdateWithoutNotificationsInput, TeamUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TeamCreateWithoutNotificationsInput, TeamUncheckedCreateWithoutNotificationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutNotificationsInput, TeamUncheckedUpdateWithoutNotificationsInput>
  }

  export type TeamUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamCreateWithoutTryoutHistoryInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutTryoutHistoryInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tournamentEntries?: TournamentEntryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutTryoutHistoryInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTryoutHistoryInput, TeamUncheckedCreateWithoutTryoutHistoryInput>
  }

  export type SeasonCreateWithoutTryoutHistoryInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    leagues?: LeagueCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutTryoutHistoryInput = {
    id: string
    seasonNumber: number
    startDate: Date | string
    endDate: Date | string
    currentDay?: number
    phase?: $Enums.SeasonPhase
    createdAt?: Date | string
    leagues?: LeagueUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutTryoutHistoryInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutTryoutHistoryInput, SeasonUncheckedCreateWithoutTryoutHistoryInput>
  }

  export type PlayerCreateWithoutTryoutHistoryInput = {
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    contract?: ContractCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueCreateNestedOneWithoutPlayerInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTryoutHistoryInput = {
    id?: number
    teamId: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutPlayerInput
    skills?: PlayerSkillLinkUncheckedCreateNestedManyWithoutPlayerInput
    MarketplaceListing?: MarketplaceListingUncheckedCreateNestedOneWithoutPlayerInput
    marketValue?: PlayerMarketValueUncheckedCreateNestedOneWithoutPlayerInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutPlayerInput
    currentEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTryoutHistoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTryoutHistoryInput, PlayerUncheckedCreateWithoutTryoutHistoryInput>
  }

  export type TeamUpsertWithoutTryoutHistoryInput = {
    update: XOR<TeamUpdateWithoutTryoutHistoryInput, TeamUncheckedUpdateWithoutTryoutHistoryInput>
    create: XOR<TeamCreateWithoutTryoutHistoryInput, TeamUncheckedCreateWithoutTryoutHistoryInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTryoutHistoryInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTryoutHistoryInput, TeamUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type TeamUpdateWithoutTryoutHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTryoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type SeasonUpsertWithoutTryoutHistoryInput = {
    update: XOR<SeasonUpdateWithoutTryoutHistoryInput, SeasonUncheckedUpdateWithoutTryoutHistoryInput>
    create: XOR<SeasonCreateWithoutTryoutHistoryInput, SeasonUncheckedCreateWithoutTryoutHistoryInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutTryoutHistoryInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutTryoutHistoryInput, SeasonUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type SeasonUpdateWithoutTryoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutTryoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonNumber?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentDay?: IntFieldUpdateOperationsInput | number
    phase?: EnumSeasonPhaseFieldUpdateOperationsInput | $Enums.SeasonPhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type PlayerUpsertWithoutTryoutHistoryInput = {
    update: XOR<PlayerUpdateWithoutTryoutHistoryInput, PlayerUncheckedUpdateWithoutTryoutHistoryInput>
    create: XOR<PlayerCreateWithoutTryoutHistoryInput, PlayerUncheckedCreateWithoutTryoutHistoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutTryoutHistoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutTryoutHistoryInput, PlayerUncheckedUpdateWithoutTryoutHistoryInput>
  }

  export type PlayerUpdateWithoutTryoutHistoryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTryoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type RedeemCodeRecordCreateWithoutRedeemCodeInput = {
    redeemedAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutRedeemedCodesInput
  }

  export type RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput = {
    id?: number
    userProfileId: number
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordCreateOrConnectWithoutRedeemCodeInput = {
    where: RedeemCodeRecordWhereUniqueInput
    create: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput>
  }

  export type RedeemCodeRecordCreateManyRedeemCodeInputEnvelope = {
    data: RedeemCodeRecordCreateManyRedeemCodeInput | RedeemCodeRecordCreateManyRedeemCodeInput[]
    skipDuplicates?: boolean
  }

  export type RedeemCodeRecordUpsertWithWhereUniqueWithoutRedeemCodeInput = {
    where: RedeemCodeRecordWhereUniqueInput
    update: XOR<RedeemCodeRecordUpdateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedUpdateWithoutRedeemCodeInput>
    create: XOR<RedeemCodeRecordCreateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedCreateWithoutRedeemCodeInput>
  }

  export type RedeemCodeRecordUpdateWithWhereUniqueWithoutRedeemCodeInput = {
    where: RedeemCodeRecordWhereUniqueInput
    data: XOR<RedeemCodeRecordUpdateWithoutRedeemCodeInput, RedeemCodeRecordUncheckedUpdateWithoutRedeemCodeInput>
  }

  export type RedeemCodeRecordUpdateManyWithWhereWithoutRedeemCodeInput = {
    where: RedeemCodeRecordScalarWhereInput
    data: XOR<RedeemCodeRecordUpdateManyMutationInput, RedeemCodeRecordUncheckedUpdateManyWithoutRedeemCodeInput>
  }

  export type RedeemCodeCreateWithoutRedeemedByInput = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type RedeemCodeUncheckedCreateWithoutRedeemedByInput = {
    id: string
    description: string
    rewardType: $Enums.RewardType
    rewardValue: JsonNullValueInput | InputJsonValue
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type RedeemCodeCreateOrConnectWithoutRedeemedByInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutRedeemedByInput, RedeemCodeUncheckedCreateWithoutRedeemedByInput>
  }

  export type UserProfileCreateWithoutRedeemedCodesInput = {
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamCreateNestedOneWithoutUserInput
    adRewardMilestone?: AdRewardMilestoneCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutRedeemedCodesInput = {
    id?: number
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamUncheckedCreateNestedOneWithoutUserInput
    adRewardMilestone?: AdRewardMilestoneUncheckedCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutRedeemedCodesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutRedeemedCodesInput, UserProfileUncheckedCreateWithoutRedeemedCodesInput>
  }

  export type RedeemCodeUpsertWithoutRedeemedByInput = {
    update: XOR<RedeemCodeUpdateWithoutRedeemedByInput, RedeemCodeUncheckedUpdateWithoutRedeemedByInput>
    create: XOR<RedeemCodeCreateWithoutRedeemedByInput, RedeemCodeUncheckedCreateWithoutRedeemedByInput>
    where?: RedeemCodeWhereInput
  }

  export type RedeemCodeUpdateToOneWithWhereWithoutRedeemedByInput = {
    where?: RedeemCodeWhereInput
    data: XOR<RedeemCodeUpdateWithoutRedeemedByInput, RedeemCodeUncheckedUpdateWithoutRedeemedByInput>
  }

  export type RedeemCodeUpdateWithoutRedeemedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeUncheckedUpdateWithoutRedeemedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardType?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    rewardValue?: JsonNullValueInput | InputJsonValue
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpsertWithoutRedeemedCodesInput = {
    update: XOR<UserProfileUpdateWithoutRedeemedCodesInput, UserProfileUncheckedUpdateWithoutRedeemedCodesInput>
    create: XOR<UserProfileCreateWithoutRedeemedCodesInput, UserProfileUncheckedCreateWithoutRedeemedCodesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutRedeemedCodesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutRedeemedCodesInput, UserProfileUncheckedUpdateWithoutRedeemedCodesInput>
  }

  export type UserProfileUpdateWithoutRedeemedCodesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUpdateOneWithoutUserNestedInput
    adRewardMilestone?: AdRewardMilestoneUpdateOneWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutRedeemedCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUncheckedUpdateOneWithoutUserNestedInput
    adRewardMilestone?: AdRewardMilestoneUncheckedUpdateOneWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutAdRewardMilestoneInput = {
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamCreateNestedOneWithoutUserInput
    redeemedCodes?: RedeemCodeRecordCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutAdRewardMilestoneInput = {
    id?: number
    userId: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredBy?: string | null
    ndaAccepted?: boolean
    ndaAcceptedAt?: Date | string | null
    ndaVersion?: string | null
    Team?: TeamUncheckedCreateNestedOneWithoutUserInput
    redeemedCodes?: RedeemCodeRecordUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutAdRewardMilestoneInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutAdRewardMilestoneInput, UserProfileUncheckedCreateWithoutAdRewardMilestoneInput>
  }

  export type UserProfileUpsertWithoutAdRewardMilestoneInput = {
    update: XOR<UserProfileUpdateWithoutAdRewardMilestoneInput, UserProfileUncheckedUpdateWithoutAdRewardMilestoneInput>
    create: XOR<UserProfileCreateWithoutAdRewardMilestoneInput, UserProfileUncheckedCreateWithoutAdRewardMilestoneInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutAdRewardMilestoneInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutAdRewardMilestoneInput, UserProfileUncheckedUpdateWithoutAdRewardMilestoneInput>
  }

  export type UserProfileUpdateWithoutAdRewardMilestoneInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUpdateOneWithoutUserNestedInput
    redeemedCodes?: RedeemCodeRecordUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutAdRewardMilestoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    ndaAccepted?: BoolFieldUpdateOperationsInput | boolean
    ndaAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ndaVersion?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUncheckedUpdateOneWithoutUserNestedInput
    redeemedCodes?: RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type ItemCreateWithoutPremiumBoxRewardsInput = {
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPremiumBoxRewardsInput = {
    id?: number
    name: string
    description: string
    type: $Enums.ItemType
    slot?: $Enums.EquipmentSlot | null
    raceRestriction?: $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    creditPrice?: bigint | number | null
    gemPrice?: number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutItemInput
    PlayerEquipment?: PlayerEquipmentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPremiumBoxRewardsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPremiumBoxRewardsInput, ItemUncheckedCreateWithoutPremiumBoxRewardsInput>
  }

  export type ItemUpsertWithoutPremiumBoxRewardsInput = {
    update: XOR<ItemUpdateWithoutPremiumBoxRewardsInput, ItemUncheckedUpdateWithoutPremiumBoxRewardsInput>
    create: XOR<ItemCreateWithoutPremiumBoxRewardsInput, ItemUncheckedCreateWithoutPremiumBoxRewardsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPremiumBoxRewardsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPremiumBoxRewardsInput, ItemUncheckedUpdateWithoutPremiumBoxRewardsInput>
  }

  export type ItemUpdateWithoutPremiumBoxRewardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPremiumBoxRewardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    slot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    raceRestriction?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    statEffects?: NullableJsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    creditPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gemPrice?: NullableIntFieldUpdateOperationsInput | number | null
    effectValue?: NullableJsonNullValueInput | InputJsonValue
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutItemNestedInput
    PlayerEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type GameCreateWithoutTournamentInput = {
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutScheduleInput
    homeTeam: TeamCreateNestedOneWithoutHomeTeamGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayTeamGamesInput
  }

  export type GameUncheckedCreateWithoutTournamentInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameCreateOrConnectWithoutTournamentInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput>
  }

  export type GameCreateManyTournamentInputEnvelope = {
    data: GameCreateManyTournamentInput | GameCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type TournamentEntryCreateWithoutTournamentInput = {
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
    team: TeamCreateNestedOneWithoutTournamentEntriesInput
  }

  export type TournamentEntryUncheckedCreateWithoutTournamentInput = {
    id?: number
    teamId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type TournamentEntryCreateOrConnectWithoutTournamentInput = {
    where: TournamentEntryWhereUniqueInput
    create: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentEntryCreateManyTournamentInputEnvelope = {
    data: TournamentEntryCreateManyTournamentInput | TournamentEntryCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithWhereUniqueWithoutTournamentInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutTournamentInput, GameUncheckedUpdateWithoutTournamentInput>
    create: XOR<GameCreateWithoutTournamentInput, GameUncheckedCreateWithoutTournamentInput>
  }

  export type GameUpdateWithWhereUniqueWithoutTournamentInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutTournamentInput, GameUncheckedUpdateWithoutTournamentInput>
  }

  export type GameUpdateManyWithWhereWithoutTournamentInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentEntryUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentEntryWhereUniqueInput
    update: XOR<TournamentEntryUpdateWithoutTournamentInput, TournamentEntryUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentEntryCreateWithoutTournamentInput, TournamentEntryUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentEntryUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentEntryWhereUniqueInput
    data: XOR<TournamentEntryUpdateWithoutTournamentInput, TournamentEntryUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentEntryUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentEntryScalarWhereInput
    data: XOR<TournamentEntryUpdateManyMutationInput, TournamentEntryUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentCreateWithoutEntriesInput = {
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    games?: GameCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutEntriesInput = {
    id?: number
    name: string
    tournamentId?: string | null
    type: $Enums.TournamentType
    division?: number | null
    status?: $Enums.TournamentStatus
    startTime: Date | string
    registrationEndTime?: Date | string | null
    endTime?: Date | string | null
    entryFeeCredits?: bigint | number | null
    entryFeeGems?: number | null
    entryFeeItemId?: number | null
    prizePoolJson: JsonNullValueInput | InputJsonValue
    seasonDay?: number | null
    createdAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutEntriesInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutEntriesInput, TournamentUncheckedCreateWithoutEntriesInput>
  }

  export type TeamCreateWithoutTournamentEntriesInput = {
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    user: UserProfileCreateNestedOneWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
    staff?: StaffCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesCreateNestedOneWithoutTeamInput
    stadium?: StadiumCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTeamInput
    league?: LeagueCreateNestedOneWithoutTeamsInput
    activeBoosts?: ActiveBoostCreateNestedManyWithoutTeamInput
    strategy?: StrategyCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingCreateNestedManyWithoutSellerTeamInput
    bids?: BidCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryCreateNestedManyWithoutTeamInput
    notifications?: NotificationCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutTournamentEntriesInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    leagueId?: number | null
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
    staff?: StaffUncheckedCreateNestedManyWithoutTeamInput
    finances?: TeamFinancesUncheckedCreateNestedOneWithoutTeamInput
    stadium?: StadiumUncheckedCreateNestedOneWithoutTeamInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTeamInput
    activeBoosts?: ActiveBoostUncheckedCreateNestedManyWithoutTeamInput
    strategy?: StrategyUncheckedCreateNestedOneWithoutTeamInput
    marketplaceListings?: MarketplaceListingUncheckedCreateNestedManyWithoutSellerTeamInput
    bids?: BidUncheckedCreateNestedManyWithoutBidderTeamInput
    highBidderOnListings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrentHighBidderTeamInput
    listingHistory?: ListingHistoryUncheckedCreateNestedManyWithoutTeamInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeamInput
    tryoutHistory?: TryoutHistoryUncheckedCreateNestedManyWithoutTeamInput
    homeTeamGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayTeamGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutTournamentEntriesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTournamentEntriesInput, TeamUncheckedCreateWithoutTournamentEntriesInput>
  }

  export type TournamentUpsertWithoutEntriesInput = {
    update: XOR<TournamentUpdateWithoutEntriesInput, TournamentUncheckedUpdateWithoutEntriesInput>
    create: XOR<TournamentCreateWithoutEntriesInput, TournamentUncheckedCreateWithoutEntriesInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutEntriesInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutEntriesInput, TournamentUncheckedUpdateWithoutEntriesInput>
  }

  export type TournamentUpdateWithoutEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTournamentTypeFieldUpdateOperationsInput | $Enums.TournamentType
    division?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryFeeCredits?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    entryFeeGems?: NullableIntFieldUpdateOperationsInput | number | null
    entryFeeItemId?: NullableIntFieldUpdateOperationsInput | number | null
    prizePoolJson?: JsonNullValueInput | InputJsonValue
    seasonDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TeamUpsertWithoutTournamentEntriesInput = {
    update: XOR<TeamUpdateWithoutTournamentEntriesInput, TeamUncheckedUpdateWithoutTournamentEntriesInput>
    create: XOR<TeamCreateWithoutTournamentEntriesInput, TeamUncheckedCreateWithoutTournamentEntriesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTournamentEntriesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTournamentEntriesInput, TeamUncheckedUpdateWithoutTournamentEntriesInput>
  }

  export type TeamUpdateWithoutTournamentEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    league?: LeagueUpdateOneWithoutTeamsNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTournamentEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type RedeemCodeRecordCreateManyUserProfileInput = {
    id?: number
    redeemCodeId: string
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordUpdateWithoutUserProfileInput = {
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redeemCode?: RedeemCodeUpdateOneRequiredWithoutRedeemedByNestedInput
  }

  export type RedeemCodeRecordUncheckedUpdateWithoutUserProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    redeemCodeId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeRecordUncheckedUpdateManyWithoutUserProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    redeemCodeId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateManyTeamInput = {
    id?: number
    firstName: string
    lastName: string
    race: $Enums.Race
    age: number
    role: $Enums.PlayerRole
    speed: number
    power: number
    throwing: number
    catching: number
    kicking: number
    staminaAttribute: number
    leadership: number
    agility: number
    potentialRating: number
    dailyStaminaLevel?: number
    injuryStatus?: $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: number
    injuryRecoveryPointsCurrent?: number
    dailyItemsUsed?: number
    careerInjuries?: number
    gamesPlayedLastSeason?: number
    seasonMinutesLeague?: number
    seasonMinutesTournament?: number
    seasonMinutesExhibition?: number
    seasonMinutesTotal?: number
    isOnMarket?: boolean
    isRetired?: boolean
    camaraderieScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyTeamInput = {
    id?: number
    type: $Enums.StaffType
    name: string
    level?: number
    motivation?: number
    development?: number
    teaching?: number
    physiology?: number
    talentIdentification?: number
    potentialAssessment?: number
    tactics?: number
    age?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyTeamInput = {
    id?: number
    itemId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type ActiveBoostCreateManyTeamInput = {
    id?: number
    playerId?: number | null
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type MarketplaceListingCreateManySellerTeamInput = {
    id?: number
    playerId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    currentHighBidderTeamId?: number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateManyBidderTeamInput = {
    id?: number
    listingId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type MarketplaceListingCreateManyCurrentHighBidderTeamInput = {
    id?: number
    playerId: number
    sellerTeamId: number
    startBid: bigint | number
    buyNowPrice?: bigint | number | null
    minBuyNowPrice: bigint | number
    currentBid?: bigint | number | null
    expiryTimestamp: Date | string
    originalExpiryTimestamp: Date | string
    auctionExtensions?: number
    listingFee: bigint | number
    marketTaxRate?: number
    escrowAmount?: bigint | number
    listingStatus?: $Enums.MarketplaceStatus
    isOffSeasonConverted?: boolean
    autoDelistAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListingHistoryCreateManyTeamInput = {
    id?: number
    listingId: number
    actionType: $Enums.ListingActionType
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type NotificationCreateManyTeamInput = {
    id?: number
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    linkTo?: string | null
    createdAt?: Date | string
  }

  export type TournamentEntryCreateManyTeamInput = {
    id?: number
    tournamentId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type TryoutHistoryCreateManyTeamInput = {
    id?: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type GameCreateManyHomeTeamInput = {
    id?: number
    leagueId?: number | null
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type GameCreateManyAwayTeamInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type PlayerUpdateWithoutTeamInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutPlayerNestedInput
    skills?: PlayerSkillLinkUncheckedUpdateManyWithoutPlayerNestedInput
    MarketplaceListing?: MarketplaceListingUncheckedUpdateOneWithoutPlayerNestedInput
    marketValue?: PlayerMarketValueUncheckedUpdateOneWithoutPlayerNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutPlayerNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutPlayerNestedInput
    currentEquipment?: PlayerEquipmentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    age?: IntFieldUpdateOperationsInput | number
    role?: EnumPlayerRoleFieldUpdateOperationsInput | $Enums.PlayerRole
    speed?: IntFieldUpdateOperationsInput | number
    power?: IntFieldUpdateOperationsInput | number
    throwing?: IntFieldUpdateOperationsInput | number
    catching?: IntFieldUpdateOperationsInput | number
    kicking?: IntFieldUpdateOperationsInput | number
    staminaAttribute?: IntFieldUpdateOperationsInput | number
    leadership?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    potentialRating?: FloatFieldUpdateOperationsInput | number
    dailyStaminaLevel?: IntFieldUpdateOperationsInput | number
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryRecoveryPointsNeeded?: IntFieldUpdateOperationsInput | number
    injuryRecoveryPointsCurrent?: IntFieldUpdateOperationsInput | number
    dailyItemsUsed?: IntFieldUpdateOperationsInput | number
    careerInjuries?: IntFieldUpdateOperationsInput | number
    gamesPlayedLastSeason?: IntFieldUpdateOperationsInput | number
    seasonMinutesLeague?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTournament?: FloatFieldUpdateOperationsInput | number
    seasonMinutesExhibition?: FloatFieldUpdateOperationsInput | number
    seasonMinutesTotal?: FloatFieldUpdateOperationsInput | number
    isOnMarket?: BoolFieldUpdateOperationsInput | boolean
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    camaraderieScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutTeamInput = {
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    motivation?: IntFieldUpdateOperationsInput | number
    development?: IntFieldUpdateOperationsInput | number
    teaching?: IntFieldUpdateOperationsInput | number
    physiology?: IntFieldUpdateOperationsInput | number
    talentIdentification?: IntFieldUpdateOperationsInput | number
    potentialAssessment?: IntFieldUpdateOperationsInput | number
    tactics?: IntFieldUpdateOperationsInput | number
    age?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutTeamInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUpdateWithoutTeamInput = {
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutActiveBoostsNestedInput
    item?: ItemUpdateOneRequiredWithoutActiveBoostsNestedInput
  }

  export type ActiveBoostUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUpdateWithoutSellerTeamInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput
    currentHighBidderTeam?: TeamUpdateOneWithoutHighBidderOnListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutSellerTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutSellerTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currentHighBidderTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUpdateWithoutBidderTeamInput = {
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutBidderTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutBidderTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUpdateWithoutCurrentHighBidderTeamInput = {
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutMarketplaceListingNestedInput
    sellerTeam?: TeamUpdateOneRequiredWithoutMarketplaceListingsNestedInput
    bids?: BidUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutCurrentHighBidderTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutListingNestedInput
    history?: ListingHistoryUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    sellerTeamId?: IntFieldUpdateOperationsInput | number
    startBid?: BigIntFieldUpdateOperationsInput | bigint | number
    buyNowPrice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    minBuyNowPrice?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    originalExpiryTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionExtensions?: IntFieldUpdateOperationsInput | number
    listingFee?: BigIntFieldUpdateOperationsInput | bigint | number
    marketTaxRate?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    listingStatus?: EnumMarketplaceStatusFieldUpdateOperationsInput | $Enums.MarketplaceStatus
    isOffSeasonConverted?: BoolFieldUpdateOperationsInput | boolean
    autoDelistAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryUpdateWithoutTeamInput = {
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: MarketplaceListingUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ListingHistoryUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    listingId?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTeamInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    linkTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentEntryUpdateWithoutTeamInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
    tournament?: TournamentUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type TournamentEntryUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    tournamentId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentEntryUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    tournamentId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TryoutHistoryUpdateWithoutTeamInput = {
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutTryoutHistoryNestedInput
    player?: PlayerUpdateOneWithoutTryoutHistoryNestedInput
  }

  export type TryoutHistoryUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameUpdateWithoutHomeTeamInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutScheduleNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayTeamGamesNestedInput
    tournament?: TournamentUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutHomeTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutAwayTeamInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutScheduleNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeTeamGamesNestedInput
    tournament?: TournamentUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutAwayTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkCreateManyPlayerInput = {
    id?: number
    skillId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type TryoutHistoryCreateManyPlayerInput = {
    id?: number
    teamId: number
    seasonId: string
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
  }

  export type ActiveBoostCreateManyPlayerInput = {
    id?: number
    teamId: number
    itemId: number
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type PlayerEquipmentCreateManyPlayerInput = {
    id?: number
    itemId: number
    equippedAt?: Date | string
  }

  export type PlayerSkillLinkUpdateWithoutPlayerInput = {
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutPlayerLinksNestedInput
  }

  export type PlayerSkillLinkUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TryoutHistoryUpdateWithoutPlayerInput = {
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTryoutHistoryNestedInput
    season?: SeasonUpdateOneRequiredWithoutTryoutHistoryNestedInput
  }

  export type TryoutHistoryUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: StringFieldUpdateOperationsInput | string
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUpdateWithoutPlayerInput = {
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutActiveBoostsNestedInput
    item?: ItemUpdateOneRequiredWithoutActiveBoostsNestedInput
  }

  export type ActiveBoostUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUpdateWithoutPlayerInput = {
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutPlayerEquipmentNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkCreateManySkillInput = {
    id?: number
    playerId: number
    currentTier?: number
    acquiredAt?: Date | string
  }

  export type PlayerSkillLinkUpdateWithoutSkillInput = {
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type PlayerSkillLinkUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillLinkUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    currentTier?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyItemInput = {
    id?: number
    teamId: number
    quantity: number
    acquiredAt?: Date | string
  }

  export type ActiveBoostCreateManyItemInput = {
    id?: number
    teamId: number
    playerId?: number | null
    matchType: $Enums.MatchType
    isActive?: boolean
    appliedAt?: Date | string
  }

  export type PlayerEquipmentCreateManyItemInput = {
    id?: number
    playerId: number
    equippedAt?: Date | string
  }

  export type EquipmentRewardCreateManyItemInput = {
    id?: number
    boxId: number
    rarity: $Enums.ItemRarity
    weight: number
  }

  export type InventoryItemUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUpdateWithoutItemInput = {
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutActiveBoostsNestedInput
    player?: PlayerUpdateOneWithoutActiveBoostsNestedInput
  }

  export type ActiveBoostUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiveBoostUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUpdateWithoutItemInput = {
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCurrentEquipmentNestedInput
  }

  export type PlayerEquipmentUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEquipmentUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    playerId?: IntFieldUpdateOperationsInput | number
    equippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentRewardUpdateWithoutItemInput = {
    boxId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentRewardUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    boxId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentRewardUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    boxId?: IntFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type BidCreateManyListingInput = {
    id?: number
    bidderTeamId: number
    bidAmount: bigint | number
    escrowAmount?: bigint | number
    isWinningBid?: boolean
    isRefunded?: boolean
    placedAt?: Date | string
  }

  export type ListingHistoryCreateManyListingInput = {
    id?: number
    actionType: $Enums.ListingActionType
    teamId?: number | null
    amount?: bigint | number | null
    oldValue?: bigint | number | null
    newValue?: bigint | number | null
    description?: string | null
    timestamp?: Date | string
  }

  export type BidUpdateWithoutListingInput = {
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidderTeam?: TeamUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    bidderTeamId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    bidderTeamId?: IntFieldUpdateOperationsInput | number
    bidAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    escrowAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    isWinningBid?: BoolFieldUpdateOperationsInput | boolean
    isRefunded?: BoolFieldUpdateOperationsInput | boolean
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryUpdateWithoutListingInput = {
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutListingHistoryNestedInput
  }

  export type ListingHistoryUncheckedUpdateWithoutListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingHistoryUncheckedUpdateManyWithoutListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: EnumListingActionTypeFieldUpdateOperationsInput | $Enums.ListingActionType
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    oldValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    newValue?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyLeagueInput = {
    id?: number
    userProfileId: number
    name: string
    logoUrl?: string | null
    isAI?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    camaraderie?: number
    fanLoyalty?: number
    homeField?: $Enums.FieldSize
    tacticalFocus?: $Enums.TacticalFocus
    division?: number | null
    subdivision?: string | null
    wins?: number
    losses?: number
    points?: number
  }

  export type GameCreateManyLeagueInput = {
    id?: number
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    tournamentId?: number | null
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type LeagueStandingCreateManyLeagueInput = {
    id?: number
    teamId: number
    teamName: string
    wins?: number
    losses?: number
    ties?: number
    pointsFor?: number
    pointsAgainst?: number
    pointDifferential?: number
    streak?: string
    rank?: number
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutLeagueInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
    staff?: StaffUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTeamNestedInput
    finances?: TeamFinancesUncheckedUpdateOneWithoutTeamNestedInput
    stadium?: StadiumUncheckedUpdateOneWithoutTeamNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTeamNestedInput
    activeBoosts?: ActiveBoostUncheckedUpdateManyWithoutTeamNestedInput
    strategy?: StrategyUncheckedUpdateOneWithoutTeamNestedInput
    marketplaceListings?: MarketplaceListingUncheckedUpdateManyWithoutSellerTeamNestedInput
    bids?: BidUncheckedUpdateManyWithoutBidderTeamNestedInput
    highBidderOnListings?: MarketplaceListingUncheckedUpdateManyWithoutCurrentHighBidderTeamNestedInput
    listingHistory?: ListingHistoryUncheckedUpdateManyWithoutTeamNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeamNestedInput
    tournamentEntries?: TournamentEntryUncheckedUpdateManyWithoutTeamNestedInput
    tryoutHistory?: TryoutHistoryUncheckedUpdateManyWithoutTeamNestedInput
    homeTeamGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayTeamGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isAI?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    camaraderie?: FloatFieldUpdateOperationsInput | number
    fanLoyalty?: FloatFieldUpdateOperationsInput | number
    homeField?: EnumFieldSizeFieldUpdateOperationsInput | $Enums.FieldSize
    tacticalFocus?: EnumTacticalFocusFieldUpdateOperationsInput | $Enums.TacticalFocus
    division?: NullableIntFieldUpdateOperationsInput | number | null
    subdivision?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type GameUpdateWithoutLeagueInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneRequiredWithoutHomeTeamGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayTeamGamesNestedInput
    tournament?: TournamentUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    tournamentId?: NullableIntFieldUpdateOperationsInput | number | null
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueStandingUpdateWithoutLeagueInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueStandingUncheckedUpdateWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueStandingUncheckedUpdateManyWithoutLeagueInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    teamName?: StringFieldUpdateOperationsInput | string
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    pointsFor?: IntFieldUpdateOperationsInput | number
    pointsAgainst?: IntFieldUpdateOperationsInput | number
    pointDifferential?: IntFieldUpdateOperationsInput | number
    streak?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateManySeasonInput = {
    id?: number
    division: number
    name: string
  }

  export type TryoutHistoryCreateManySeasonInput = {
    id?: number
    teamId: number
    tryoutType: string
    cost: number
    playersAdded: number
    conductedAt?: Date | string
    playerId?: number | null
  }

  export type LeagueUpdateWithoutSeasonInput = {
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    schedule?: GameUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    schedule?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    standings?: LeagueStandingUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateManyWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    division?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TryoutHistoryUpdateWithoutSeasonInput = {
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTryoutHistoryNestedInput
    player?: PlayerUpdateOneWithoutTryoutHistoryNestedInput
  }

  export type TryoutHistoryUncheckedUpdateWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TryoutHistoryUncheckedUpdateManyWithoutSeasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    tryoutType?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    playersAdded?: IntFieldUpdateOperationsInput | number
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RedeemCodeRecordCreateManyRedeemCodeInput = {
    id?: number
    userProfileId: number
    redeemedAt?: Date | string
  }

  export type RedeemCodeRecordUpdateWithoutRedeemCodeInput = {
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutRedeemedCodesNestedInput
  }

  export type RedeemCodeRecordUncheckedUpdateWithoutRedeemCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeRecordUncheckedUpdateManyWithoutRedeemCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userProfileId?: IntFieldUpdateOperationsInput | number
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateManyTournamentInput = {
    id?: number
    leagueId?: number | null
    homeTeamId: number
    awayTeamId: number
    homeScore?: number | null
    awayScore?: number | null
    gameDate: Date | string
    simulated?: boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: $Enums.MatchType
    round?: number | null
    status?: $Enums.GameStatus
    createdAt?: Date | string
  }

  export type TournamentEntryCreateManyTournamentInput = {
    id?: number
    teamId: number
    registeredAt?: Date | string
    finalRank?: number | null
    rewardsClaimed?: boolean
  }

  export type GameUpdateWithoutTournamentInput = {
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutScheduleNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeTeamGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayTeamGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    leagueId?: NullableIntFieldUpdateOperationsInput | number | null
    homeTeamId?: IntFieldUpdateOperationsInput | number
    awayTeamId?: IntFieldUpdateOperationsInput | number
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    gameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    simulated?: BoolFieldUpdateOperationsInput | boolean
    simulationLog?: NullableJsonNullValueInput | InputJsonValue
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    round?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentEntryUpdateWithoutTournamentInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutTournamentEntriesNestedInput
  }

  export type TournamentEntryUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentEntryUncheckedUpdateManyWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    rewardsClaimed?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}