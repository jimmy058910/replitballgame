import { Router, type Request, type Response, type NextFunction } from "express";
import { requireAuth } from "../middleware/firebaseAuth.js";

const router = Router();

/**
 * Reset all team standings and generate league schedule for Days 5-14
 * Admin endpoint for development purposes
 */
router.post('/reset-and-schedule', requireAuth, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user.claims.sub;
    
    // Only allow specific admin user for development
    if (userId !== 'dev-user-123') {
      return res.status(403).json({ message: "Admin access required for this operation" });
    }

    console.log('üßπ === STEP 1: CLEARING ALL RESULTS AND STANDINGS ===');
    
    // Import database client (matching pattern from other routes)
    const { getPrismaClient } = await import('../database.js');
    const prisma = await getPrismaClient();
    
    // Reset all team records to 0
    const teamUpdate = await prisma.team.updateMany({
      data: {
        wins: 0,
        losses: 0,
        points: 0
      }
    });
    console.log(`‚úÖ Reset ${teamUpdate.count} team standings to 0`);
    
    // Delete all existing LEAGUE games (keep EXHIBITION and TOURNAMENT)
    const deletedGames = await prisma.game.deleteMany({
      where: {
        matchType: 'LEAGUE'
      }
    });
    console.log(`‚úÖ Deleted ${deletedGames.count} league games`);
    
    // REPLACE DELETED_AI_TEAM with proper AI team (maintain 8 teams total)
    const deletedTeam = await prisma.team.findFirst({
      where: { name: 'DELETED_AI_TEAM' }
    });
    
    if (deletedTeam) {
      // Generate a unique AI team name
      const aiTeamNames = ['Storm Raiders', 'Void Hunters', 'Mystic Eagles', 'Thunder Wolves', 'Crimson Lions'];
      const randomName = aiTeamNames[Math.floor(Math.random() * aiTeamNames.length)];
      const suffix = Math.floor(Math.random() * 900) + 100;
      const newTeamName = `${randomName} ${suffix}`;
      
      // Update DELETED_AI_TEAM to be a proper AI team
      await prisma.team.update({
        where: { id: deletedTeam.id },
        data: {
          name: newTeamName,
          isAI: true
        }
      });
      console.log(`‚úÖ Converted DELETED_AI_TEAM ‚Üí ${newTeamName} (maintaining 8 teams in Division 7 Alpha)`);
    } else {
      console.log(`‚úÖ DELETED_AI_TEAM not found - already converted`);
    }
    
    // Skip player stats clearing for now - continue with scheduling
    console.log(`‚úÖ Skipped player stats clearing (no dedicated stats table found)`);
    
    console.log('\nüìÖ === STEP 2: GENERATING PROPER LEAGUE SCHEDULE ===');
    
    // Use ONLY the main seasonal flow service to prevent duplicate game creation
    const { SeasonalFlowService } = await import('../services/seasonalFlowService.js');
    const scheduleResult = await SeasonalFlowService.generateSeasonSchedule(2);  // Season 2
    
    console.log(`‚úÖ Generated ${scheduleResult.matchesGenerated} matches across ${scheduleResult.schedulesCreated} leagues`);
    
    // The schedule has been generated by the service above
    const totalGamesCreated = scheduleResult.matchesGenerated;
    
    console.log(`\nüéâ === COMPLETE: Generated ${totalGamesCreated} league games ===`);
    
    res.json({
      success: true,
      message: "Reset and schedule generation completed successfully",
      summary: {
        teamsReset: teamUpdate.count,
        gamesDeleted: deletedGames.count,
        statsCleared: 0,
        gamesCreated: totalGamesCreated
      },
      details: {
        eachTeamPlays: 10,
        daysScheduled: "5-14",
        gameTime: "3PM EDT daily with 15-minute intervals"
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error in reset and schedule:', error);
    next(error);
  }
});

/**
 * MANUAL: Convert DELETED_AI_TEAM to proper AI team
 */
router.post('/convert-deleted-team', requireAuth, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { getPrismaClient } = await import('../database.js');
    const prisma = await getPrismaClient();
    
    const deletedTeam = await prisma.team.findFirst({
      where: { name: 'DELETED_AI_TEAM' }
    });
    
    if (deletedTeam) {
      const newName = 'Storm Raiders 456';
      await prisma.team.update({
        where: { id: deletedTeam.id },
        data: {
          name: newName,
          isAI: true
        }
      });
      
      res.json({
        success: true,
        message: `Converted DELETED_AI_TEAM to ${newName}`,
        teamId: deletedTeam.id
      });
    } else {
      res.json({
        success: false,
        message: "DELETED_AI_TEAM not found - already converted"
      });
    }
  } catch (error) {
    console.error('‚ùå Error converting team:', error);
    next(error);
  }
});

/**
 * Generate matches for a single day ensuring each team plays exactly once
 * Uses round-robin rotation for fair scheduling
 */
function generateDayMatches(teams: any[], day: number): { homeTeam: any, awayTeam: any }[] {
  const matches: { homeTeam: any, awayTeam: any }[] = [];
  const numTeams = teams.length;
  
  if (numTeams < 8) return matches;
  
  // Round-robin algorithm: rotate teams to create balanced schedule
  const teamList = [...teams];
  const rotationOffset = (day - 5) % (numTeams - 1); // Days 5-14 mapped to 0-9
  
  // Apply rotation
  for (let i = 0; i < rotationOffset; i++) {
    teamList.push(teamList.shift());
  }
  
  // Create 4 matches from 8 teams
  for (let i = 0; i < 4; i++) {
    const homeTeam = teamList[i];
    const awayTeam = teamList[i + 4];
    
    matches.push({
      homeTeam: homeTeam,
      awayTeam: awayTeam
    });
  }
  
  return matches;
}

/**
 * DIRECT TEST ENDPOINT for schedule generation (no auth required for testing)
 */
router.post('/test-schedule-generation', async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('üß™ === TESTING NEW ROBUST SCHEDULE GENERATION ===');
    
    const { getPrismaClient } = await import('../database.js');
    const prisma = await getPrismaClient();
    
    // Get one league for testing
    const testLeague = await prisma.league.findFirst({
      include: {
        teams: true
      }
    });
    
    if (!testLeague || testLeague.teams.length === 0) {
      return res.status(404).json({ 
        error: "No leagues with teams found for testing",
        suggestion: "Create some teams first"
      });
    }
    
    console.log(`Testing with league ${testLeague.id} containing ${testLeague.teams.length} teams`);
    
    // Clear existing games for this league only
    await prisma.game.deleteMany({
      where: { leagueId: testLeague.id }
    });
    
    // Test the new schedule generation
    const { ScheduleGenerationService } = await import('../services/scheduleGenerationService.js');
    const result = await ScheduleGenerationService.generateLeagueSchedule(
      testLeague.id.toString(), 
      testLeague.teams
    );
    
    // Get created games for verification
    const createdGames = await prisma.game.findMany({
      where: { leagueId: testLeague.id },
      include: {
        homeTeam: { select: { name: true } },
        awayTeam: { select: { name: true } }
      },
      orderBy: { gameDate: 'asc' }
    });
    
    // Analyze schedule quality
    const analysis = analyzeScheduleQuality(createdGames);
    
    res.json({
      success: true,
      message: "Schedule generation test completed",
      league: {
        id: testLeague.id,
        name: testLeague.name,
        teamCount: testLeague.teams.length
      },
      results: {
        gamesCreated: result,
        gamesInDatabase: createdGames.length,
        analysis: analysis
      },
      sampleGames: createdGames.slice(0, 5).map(game => ({
        homeTeam: game.homeTeam.name,
        awayTeam: game.awayTeam.name,
        gameDate: game.gameDate,
        time: game.gameDate.toTimeString().substring(0, 8)
      }))
    });
    
  } catch (error) {
    console.error('‚ùå Test schedule generation error:', error);
    res.status(500).json({
      error: "Schedule generation test failed",
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Analyze schedule quality to detect duplicates and conflicts
 */
function analyzeScheduleQuality(games: any[]) {
  const matchups = new Set<string>();
  const timeSlots = new Map<string, number>();
  let duplicates = 0;
  
  for (const game of games) {
    // Check for duplicate matchups
    const team1 = Math.min(game.homeTeamId, game.awayTeamId);
    const team2 = Math.max(game.homeTeamId, game.awayTeamId);
    const matchupKey = `${team1}-${team2}`;
    
    if (matchups.has(matchupKey)) {
      duplicates++;
    } else {
      matchups.add(matchupKey);
    }
    
    // Check time distribution
    const timeKey = game.gameDate.toISOString().substring(0, 16); // YYYY-MM-DDTHH:MM
    timeSlots.set(timeKey, (timeSlots.get(timeKey) || 0) + 1);
  }
  
  const maxGamesAtSameTime = Math.max(...Array.from(timeSlots.values()));
  
  return {
    totalGames: games.length,
    uniqueMatchups: matchups.size,
    duplicateMatchups: duplicates,
    maxGamesAtSameTime: maxGamesAtSameTime,
    timeSlots: timeSlots.size,
    qualityScore: duplicates === 0 && maxGamesAtSameTime === 1 ? "EXCELLENT" : 
                  duplicates === 0 ? "GOOD" : "NEEDS_IMPROVEMENT"
  };
}

export default router;