import { Router, Request, Response, NextFunction } from 'express';
import { DynamicMarketplaceService } from '../services/dynamicMarketplaceService.js';
import { requireAuth } from "../middleware/firebaseAuth.js";
import { getPrismaClient } from "../database.js";
import { storage } from '../storage/index.js';
import { teamFinancesStorage } from '../storage/teamFinancesStorage.js';
import { itemStorage } from '../storage/itemStorage.js';
import { z } from 'zod';

// Equipment marketplace schemas
const equipmentPriceSchema = z.object({
  price: z.number().min(100).max(500000),
});

const router = Router();

// Get active marketplace listings
router.get('/listings', requireAuth, async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string) || 50;
    const offset = parseInt(req.query.offset as string) || 0;
    
    const listings = await DynamicMarketplaceService.getActiveListings(limit, offset);
    
    res.json({ listings });
  } catch (error) {
    console.error('Error fetching marketplace listings:', error);
    res.status(500).json({ error: 'Failed to fetch marketplace listings' });
  }
});

// Get specific listing details with bid history
router.get('/listings/:listingId', requireAuth, async (req: Request, res: Response) => {
  try {
    const listingId = parseInt(req.params.listingId);
    const listing = await DynamicMarketplaceService.getListingDetails(listingId);
    
    if (!listing) {
      return res.status(404).json({ error: 'Listing not found' });
    }

    res.json({ listing });
  } catch (error) {
    console.error('Error fetching listing details:', error);
    res.status(500).json({ error: 'Failed to fetch listing details' });
  }
});

// Get user's team listings
router.get('/my-listings', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Get user's team via userProfile lookup
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
      where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
      return res.status(404).json({ error: 'User profile not found' });
    }

    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const listings = await DynamicMarketplaceService.getTeamListings(team.id.toString());
    
    res.json({ listings });
  } catch (error) {
    console.error('Error fetching team listings:', error);
    res.status(500).json({ error: 'Failed to fetch team listings' });
  }
});

// List a player for auction
router.post('/list-player', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { playerId, startBid, durationHours, buyNowPrice } = req.body;

    // Validation
    if (!playerId || !startBid || !durationHours) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (startBid < 100) {
      return res.status(400).json({ error: 'Start bid must be at least 100 credits' });
    }

    const validDurations = [12, 24, 72, 168]; // 12h, 24h, 3d, 7d
    if (!validDurations.includes(durationHours)) {
      return res.status(400).json({ error: 'Invalid auction duration' });
    }

    // Get user's team via userProfile lookup
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
      where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
      return res.status(404).json({ error: 'User profile not found' });
    }

    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const result = await DynamicMarketplaceService.listPlayer(
      team.id,
      parseInt(playerId, 10),
      startBid,
      durationHours,
      buyNowPrice
    );

    if (result.success) {
      res.json({ 
        success: true, 
        message: 'Player listed successfully',
        listingId: result.listingId 
      });
    } else {
      res.status(400).json({ 
        success: false, 
        error: result.error 
      });
    }
  } catch (error) {
    console.error('Error listing player:', error);
    res.status(500).json({ error: 'Failed to list player' });
  }
});

// Place a bid on a listing
router.post('/listings/:listingId/bid', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const listingId = parseInt(req.params.listingId, 10);
    const { bidAmount } = req.body;

    if (!bidAmount || bidAmount < 1) {
      return res.status(400).json({ error: 'Invalid bid amount' });
    }

    // Get user's team via userProfile lookup
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
      where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
      return res.status(404).json({ error: 'User profile not found' });
    }

    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const result = await DynamicMarketplaceService.placeBid(
      team.id,
      listingId,
      bidAmount
    );

    if (result.success) {
      res.json({
        success: true,
        message: result.message,
        newExpiryTime: result.newExpiryTime
      });
    } else {
      res.status(400).json({
        success: false,
        error: result.error
      });
    }
  } catch (error) {
    console.error('Error placing bid:', error);
    res.status(500).json({ error: 'Failed to place bid' });
  }
});

// Buy now - instant purchase
router.post('/listings/:listingId/buy-now', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const listingId = parseInt(req.params.listingId, 10);

    // Get user's team
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
      where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
      return res.status(404).json({ error: 'User profile not found' });
    }
    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const result = await DynamicMarketplaceService.buyNow(team.id, listingId);

    if (result.success) {
      res.json({
        success: true,
        message: result.message
      });
    } else {
      res.status(400).json({
        success: false,
        error: result.error
      });
    }
  } catch (error) {
    console.error('Error with buy-now purchase:', error);
    res.status(500).json({ error: 'Failed to complete purchase' });
  }
});

// Calculate minimum buy-now price for a player (helper endpoint)
router.get('/calculate-min-price/:playerId', requireAuth, async (req: Request, res: Response) => {
  try {
    const { playerId } = req.params;
    
    const prisma = await getPrismaClient();
    const player = await prisma.player.findFirst({
      where: { id: parseInt(playerId, 10) }
    });
    
    if (!player) {
      return res.status(404).json({ error: 'Player not found' });
    }

    const minimumPrice = DynamicMarketplaceService.calculateMinimumBuyNowPrice(player);
    
    res.json({ minimumPrice });
  } catch (error) {
    console.error('Error calculating minimum price:', error);
    res.status(500).json({ error: 'Failed to calculate minimum price' });
  }
});

// Get team's marketplace stats
router.get('/team-stats', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Get user's team
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
        where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
        return res.status(404).json({ error: 'User profile not found' });
    }
    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const activeListings = await DynamicMarketplaceService.getTeamActiveListings(team.id.toString());
    const playerCount = await DynamicMarketplaceService.getTeamPlayerCount(team.id.toString());
    
    res.json({
      activeListings,
      maxListings: 3,
      playerCount,
      minPlayersRequired: 10,
      canListMore: activeListings < 3 && playerCount > 10
    });
  } catch (error) {
    console.error('Error fetching team stats:', error);
    res.status(500).json({ error: 'Failed to fetch team stats' });
  }
});

// Get general marketplace statistics
router.get('/stats', requireAuth, async (req: Request, res: Response) => {
  try {
    const stats = await DynamicMarketplaceService.getMarketplaceStats();
    res.json(stats);
  } catch (error) {
    console.error('Error fetching marketplace stats:', error);
    res.status(500).json({ error: 'Failed to fetch marketplace stats' });
  }
});

// Get user's bids
router.get('/my-bids', requireAuth, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).send({ success: false, message: 'Unauthorized' });
    }
    const userId = (req.user as any).claims.sub;
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Get user's team via userProfile lookup
    const prisma = await getPrismaClient();
    const userProfileData = await prisma.userProfile.findFirst({
      where: { id: (req.user as any).claims.sub }
    });
    if (!userProfileData) {
      return res.status(404).json({ error: 'User profile not found' });
    }

    const team = await prisma.team.findFirst({
      where: { userProfileId: userProfileData.id }
    });
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    const bids = await DynamicMarketplaceService.getUserBids(team.id.toString());
    res.json({ bids });
  } catch (error) {
    console.error('Error fetching user bids:', error);
    res.status(500).json({ error: 'Failed to fetch user bids' });
  }
});

// Admin endpoint: Process expired auctions
router.post('/admin/process-expired', requireAuth, async (req: Request, res: Response) => {
  try {
    // Add admin permission check here if needed
    const results = await DynamicMarketplaceService.processExpiredAuctions();
    
    res.json({
      message: 'Expired auctions processed',
      results
    });
  } catch (error) {
    console.error('Error processing expired auctions:', error);
    res.status(500).json({ error: 'Failed to process expired auctions' });
  }
});

// ========================
// EQUIPMENT MARKETPLACE ROUTES
// ========================
// These routes were moved from marketplaceRoutes.ts due to route conflict fixes
// Equipment trading was broken because the original routes were overwritten

// Get equipment marketplace listings
router.get('/equipment', requireAuth, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const marketItems = await itemStorage.getMarketplaceItems("EQUIPMENT");
    res.json(marketItems);
  } catch (error) {
    console.error("Error fetching equipment marketplace:", error);
    next(error);
  }
});

// Buy equipment from marketplace
router.post('/equipment/:itemId/buy', requireAuth, async (req: any, res: Response, next: NextFunction) => {
  try {
    const { itemId } = req.params;
    const buyerUserId = req.user.claims.sub;

    const buyerTeam = await storage.teams.getTeamByUserId(buyerUserId);
    if (!buyerTeam) return res.status(404).json({ message: "Your team not found." });

    const itemToBuy = await itemStorage.getItemById(parseInt(itemId));
    if (!itemToBuy) return res.status(404).json({ message: "Equipment not available for purchase or price not set." });

    const buyerFinances = await teamFinancesStorage.getTeamFinances(buyerTeam.id);
    const price = 1000; // Fixed price for equipment

    if (!buyerFinances || (buyerFinances.credits || 0) < price) {
      return res.status(400).json({ 
        message: `Insufficient credits. Required: ${price}, Available: ${buyerFinances.credits || 0}` 
      });
    }

    // Handle seller credits if equipment is owned by another team
    if ((itemToBuy as any).teamId) {
      const sellerTeam = await storage.teams.getTeamById((itemToBuy as any).teamId);
      if (sellerTeam) {
        const sellerFinances = await teamFinancesStorage.getTeamFinances(sellerTeam.id);
        await teamFinancesStorage.updateTeamFinances(sellerTeam.id, { 
          credits: (sellerFinances.credits || 0) + price 
        });
      }
    }

    // Update buyer finances
    await teamFinancesStorage.updateTeamFinances(buyerTeam.id, { 
      credits: (buyerFinances.credits || 0) - price 
    });

    res.json({ 
      success: true, 
      message: `Successfully purchased ${itemToBuy.name} for ${price} credits.` 
    });
  } catch (error) {
    console.error("Error buying equipment:", error);
    next(error);
  }
});

// Sell equipment to marketplace
router.post('/equipment/:itemId/sell', requireAuth, async (req: any, res: Response, next: NextFunction) => {
  try {
    const { itemId } = req.params;
    const { price } = equipmentPriceSchema.parse(req.body);
    const sellerUserId = req.user.claims.sub;

    const sellerTeam = await storage.teams.getTeamByUserId(sellerUserId);
    if (!sellerTeam) return res.status(404).json({ message: "Your team not found." });

    const itemToSell = await itemStorage.getItemById(parseInt(itemId));
    if (!itemToSell || (itemToSell as any).teamId !== sellerTeam.id) {
      return res.status(404).json({ message: "Equipment not found on your team." });
    }

    // Update item for marketplace listing
    await itemStorage.updateItem(parseInt(itemId), { });
    
    res.json({ 
      success: true, 
      message: `${itemToSell.name} listed for ${price} credits.` 
    });
  } catch (error) {
    console.error("Error listing equipment:", error);
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        message: "Invalid price data", 
        errors: error.errors 
      });
    }
    next(error);
  }
});

export default router;