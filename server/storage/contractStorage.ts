import { db } from "../db";
import {
    playerContracts,
    salaryCap,
    type PlayerContract, type InsertPlayerContract,
    type SalaryCap, type InsertSalaryCap
} from "@shared/schema";
import { eq, and, desc, asc } from "drizzle-orm";
import { nanoid } from "nanoid";

export class ContractStorage {

  // PlayerContract Operations
  async createPlayerContract(contractData: Omit<InsertPlayerContract, 'id' | 'signedDate' | 'expiryDate' | 'isActive' | 'createdAt' | 'updatedAt'>): Promise<PlayerContract> {
    const duration = contractData.duration || 1; // Default duration if not provided
    const signedDate = new Date();
    const expiryDate = new Date(signedDate.getFullYear() + duration, signedDate.getMonth(), signedDate.getDate());

    const dataToInsert: InsertPlayerContract = {
      id: nanoid(),
      ...contractData,
      duration, // Ensure duration is set
      remainingYears: contractData.remainingYears === undefined ? duration : contractData.remainingYears,
      signedDate,
      expiryDate,
      isActive: true,
      contractType: contractData.contractType || 'standard',
      bonuses: typeof contractData.bonuses === 'object' ? contractData.bonuses : contractData.bonuses || {},
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    const [newContract] = await db.insert(playerContracts).values(dataToInsert).returning();
    return newContract;
  }

  async getPlayerContractById(id: string): Promise<PlayerContract | undefined> {
    const [contract] = await db.select().from(playerContracts).where(eq(playerContracts.id, id)).limit(1);
    return contract;
  }

  async getActiveContractsByPlayer(playerId: string): Promise<PlayerContract[]> {
    return await db.select().from(playerContracts)
      .where(and(eq(playerContracts.playerId, playerId), eq(playerContracts.isActive, true)))
      .orderBy(desc(playerContracts.expiryDate));
  }

  async getActiveContractsByTeam(teamId: string): Promise<PlayerContract[]> {
    return await db.select().from(playerContracts)
      .where(and(eq(playerContracts.teamId, teamId), eq(playerContracts.isActive, true)))
      .orderBy(desc(playerContracts.salary));
  }

  async getAllContractsByTeam(teamId: string): Promise<PlayerContract[]> {
    return await db.select().from(playerContracts)
      .where(eq(playerContracts.teamId, teamId))
      .orderBy(desc(playerContracts.signedDate));
  }


  async updatePlayerContract(id: string, updates: Partial<Omit<InsertPlayerContract, 'id' | 'playerId' | 'teamId' | 'signedDate' | 'createdAt' >>): Promise<PlayerContract | undefined> {
    const existing = await this.getPlayerContractById(id);
    if (!existing) {
        console.warn(`Contract with ID ${id} not found for update.`);
        return undefined;
    }

    if (updates.duration && !updates.expiryDate) {
        updates.expiryDate = new Date(existing.signedDate.getFullYear() + updates.duration, existing.signedDate.getMonth(), existing.signedDate.getDate());
    }
    if (updates.bonuses && typeof updates.bonuses === 'object') {
        // updates.bonuses = JSON.stringify(updates.bonuses); // Drizzle jsonb handles objects
    }

    const [updatedContract] = await db.update(playerContracts)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(playerContracts.id, id))
      .returning();
    return updatedContract;
  }

  async deactivatePlayerContract(id: string): Promise<PlayerContract | undefined> {
    return this.updatePlayerContract(id, { isActive: false });
  }

  // SalaryCap Operations
  async getTeamSalaryCap(teamId: string, season: number): Promise<SalaryCap | undefined> {
    const [cap] = await db.select().from(salaryCap)
      .where(and(eq(salaryCap.teamId, teamId), eq(salaryCap.season, season)))
      .limit(1);
    return cap;
  }

  async upsertTeamSalaryCap(capData: InsertSalaryCap): Promise<SalaryCap> {
    // Ensure all required fields for InsertSalaryCap are present or have defaults
    const dataToUpsert: InsertSalaryCap = {
        id: capData.id || nanoid(), // Provide ID if not auto-generated by DB or ensure it's in capData
        teamId: capData.teamId,
        season: capData.season,
        totalSalary: capData.totalSalary || 0,
        capLimit: capData.capLimit || 50000000, // Default cap limit
        capSpace: capData.capSpace === undefined ? (capData.capLimit || 50000000) - (capData.totalSalary || 0) : capData.capSpace,
        luxuryTax: capData.luxuryTax || 0,
        penalties: capData.penalties || 0,
        updatedAt: new Date(),
        // createdAt: capData.createdAt // Handled by DB or default if new
    };

    const [cap] = await db.insert(salaryCap)
      .values(dataToUpsert)
      .onConflictDoUpdate({ // Assumes unique constraint on (teamId, season)
        target: [salaryCap.teamId, salaryCap.season],
        set: {
            totalSalary: dataToUpsert.totalSalary,
            capLimit: dataToUpsert.capLimit,
            capSpace: dataToUpsert.capSpace,
            luxuryTax: dataToUpsert.luxuryTax,
            penalties: dataToUpsert.penalties,
            updatedAt: new Date()
        }
      })
      .returning();
    return cap;
  }
}

export const contractStorage = new ContractStorage();
